<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=author content="Thalium Team"><meta name=description content="Thalium blog."><meta name=keywords content="blog,tech"><meta name=viewport content="width=device-width,minimum-scale=1,initial-scale=1"><meta name=generator content="Hugo 0.120.3"><link rel=canonical href=/posts/windows-full-memory-introspection-with-icebox/><meta property="og:title" content="Windows Memory Introspection with IceBox"><meta property="og:description" content="Virtual Machine Introspection (VMI) is an extremely powerful technique to explore a guest OS. Directly acting on the hypervisor allows a stealth and precise control of the guest state, which means its CPU context as well as its memory.
Basically, a common use case in VMI consists in (1) setting a breakpoint on an address, (2) wait for a break and (3) finally read some virtual memory. For example, to simply monitor the user file writing activity on Windows, just set a breakpoint on the NtWriteFile function in kernel land."><meta property="og:type" content="article"><meta property="og:url" content="/posts/windows-full-memory-introspection-with-icebox/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-06-22T12:00:00+01:00"><meta property="article:modified_time" content="2020-06-22T12:00:00+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Windows Memory Introspection with IceBox"><meta name=twitter:description content="Virtual Machine Introspection (VMI) is an extremely powerful technique to explore a guest OS. Directly acting on the hypervisor allows a stealth and precise control of the guest state, which means its CPU context as well as its memory.
Basically, a common use case in VMI consists in (1) setting a breakpoint on an address, (2) wait for a break and (3) finally read some virtual memory. For example, to simply monitor the user file writing activity on Windows, just set a breakpoint on the NtWriteFile function in kernel land."><meta itemprop=name content="Windows Memory Introspection with IceBox"><meta itemprop=description content="Virtual Machine Introspection (VMI) is an extremely powerful technique to explore a guest OS. Directly acting on the hypervisor allows a stealth and precise control of the guest state, which means its CPU context as well as its memory.
Basically, a common use case in VMI consists in (1) setting a breakpoint on an address, (2) wait for a break and (3) finally read some virtual memory. For example, to simply monitor the user file writing activity on Windows, just set a breakpoint on the NtWriteFile function in kernel land."><meta itemprop=datePublished content="2020-06-22T12:00:00+01:00"><meta itemprop=dateModified content="2020-06-22T12:00:00+01:00"><meta itemprop=wordCount content="4232"><meta itemprop=keywords content><link rel=stylesheet href=/css/layout.css><link rel=stylesheet href=/css/default-dark.css><link rel=icon href=/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-141692648-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><title>Windows Memory Introspection with IceBox
</title><script>MathJax={tex:{inlineMath:[["∳","∳"]],displayMath:[["∳∳","∳∳"]],processEscapes:!0},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script></head><body><style>@font-face{font-family:days_one;src:url(/days_one.ttf)format('truetype')}.siteTitle{margin-top:24px}.siteTitle img{display:inline-block;vertical-align:middle;margin-top:-24px;margin-right:-10px}.siteTitle span{font-family:days_one,Fallback,sans-serif;color:#fff;font-size:160%}</style><div class=main><header><div class=header-bar><nav><div class=siteTitle><a href=/><img src=/shard_only_no_background.png width=12%></img>
<span>THALIUM</span></a></div><a class=nav-item href=/posts/><div class=nav-item-title>Posts</div></a><a class=nav-item href=/joinus/><div class=nav-item-title>Join Us</div></a><a class=nav-item href=/about/><div class=nav-item-title>About</div></a></nav><div class=social-links-header><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>Github</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div></div></header><article class=post><h1 class=title>Windows Memory Introspection with IceBox</h1><div class=content><p><strong>Virtual Machine Introspection (VMI)</strong> is an extremely powerful technique to explore a guest OS.
Directly acting on the hypervisor allows a stealth and precise control of the guest state, which means its CPU context as well as its memory.</p><p>Basically, a common use case in VMI consists in (1) setting a breakpoint on an address, (2) wait for a break and (3) finally read some virtual memory.
For example, to simply monitor the user file writing activity on Windows, just set a breakpoint on the <code>NtWriteFile</code> function in kernel land.
Once triggered, you can retrieve the involved process and capture its corresponding callstack.
All these actions eventually require accessing the guest virtual memory.</p><p>Accessing this memory sounds quite simple at first sight. Nevertheless, the reality turns out to be a bit more complex on Windows.
Indeed, everyone has already heard about the <strong>paging</strong> mechanism.
Briefly, paging consists in backing up a physical memory page on the disk to make it available for further access in order to <em>somehow</em> increase the physical memory space. By default, Windows stores these backed up pages into paging files (by default <code>pagefile.sys</code>, also known as the swapping file).
Consequently, the whole content of a process virtual memory may not be directly accessible when a breakpoint is hit as some pages may have been <em>paged out</em>.</p><p>Disabling paging files is a well-known feature on Windows and seems to be a simple approach to keep all pages in physical memory.
Unfortunately, as we will see through this article, this technique is not sufficient. Indeed, Windows implements several optimizations to deal with physical memory.</p><p>The first part of this article describes the Windows virtual address translation mechanism. More precisely, all the software states involved in the description of a physical memory page are described.</p><p>Then, in a second part, it focuses on how <a href=https://github.com/thalium/icebox>IceBox</a> can automatically configure the OS during its initialization phase to offer full physical memory access of a Windows guest.</p><h2 id=windows-virtual-address-translation>Windows Virtual Address Translation</h2><h3 id=the-hardware-part>The hardware part</h3><p>Software memory management relies on the underlying hardware support.
From a hardware point of view, the <em>Memory Management Unit</em> (MMU) is in charge of virtual address translation to access physical memory.
For a complete description see the <a href=https://software.intel.com/en-us/articles/intel-sdm>Intel® 64 and IA-32 Architectures Software Developer Manuals</a>.
Here, we just present the most common current case: 64-bits 4-level paging mode.</p><p>This translation process starts with the CR3 register and of course, a virtual address.</p><p>The upper 16 bits of the address are unused, the 48 following ones are split in 4 values of 9 bits which correspond to the 4 levels of the Page Table hierarchy:</p><ul><li>Level 0 is <em>Page-Map Level-4 Offset</em> (PML4).</li><li>Level 1 is <em>Page-Directory-Pointer Offset</em> (PDP).</li><li>Level 2 is <em>Page-Directory Offset</em> (PDP).</li><li>Level 3 is <em>Page Table Offset</em> (PT).</li></ul><p>The last 12 bits correspond to the offset in a page.</p><p>The whole process is illustrated in the next figure:</p><p><a href=/posts/img/Amd64Paging.png target=_blank><img src=/posts/img/Amd64Paging.png alt=fig_amd64_paging></a></p><ul><li>The CR3 contains the <em>Page-Map Level-4 Base-Address</em> also known as the <em>Directory Table Base</em> (DTB) (bits 12 to 51).</li><li>The PML4E gives the base of the <em>Page-Directory-Pointer Table</em> (PDPT) from which the PDPE can be read at the PDP offset.</li><li>The PDPE gives the base of the <em>Page-Directory Table</em> (PDT) from which the PDE can be read at the PD offset.</li><li>The PDE gives the base of the <em>Page Table</em> (PT) from which the PTE can be read at the PT offset.</li></ul><p>At the end, the <em>Page Table Entry</em> (PTE) describes the state of a page in physical memory.
In Windows, this hardware state is defined by the <code>_MMPTE_HARDWARE</code> structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>nt<span style=color:#f92672>!</span>_MMPTE_HARDWARE
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Valid               : Pos <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Dirty1              : Pos <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Owner               : Pos <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> WriteThrough        : Pos <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> CacheDisable        : Pos <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Accessed            : Pos <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Dirty               : Pos <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> LargePage           : Pos <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Global              : Pos <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> CopyOnWrite         : Pos <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Unused              : Pos <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Write               : Pos <span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFrameNumber     : Pos <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>36</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ReservedForHardware : Pos <span style=color:#ae81ff>48</span>, <span style=color:#ae81ff>4</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ReservedForSoftware : Pos <span style=color:#ae81ff>52</span>, <span style=color:#ae81ff>4</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> WsleAge             : Pos <span style=color:#ae81ff>56</span>, <span style=color:#ae81ff>4</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> WsleProtection      : Pos <span style=color:#ae81ff>60</span>, <span style=color:#ae81ff>3</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> NoExecute           : Pos <span style=color:#ae81ff>63</span>, <span style=color:#ae81ff>1</span> Bit
</span></span></code></pre></div><p>For our purpose, the only important bits are:</p><ul><li>The <code>Valid</code> flag indicating to the hardware that all the others bits are valid and the target physical page can be safely accessed.</li><li>The <code>PageFrameNumber</code> standing for the page index in physical memory.</li></ul><p>When a page is valid, the physical address can easily be computed as follows:</p><blockquote><p><em>PhysicalAddress = <code>_MMPTE_HARDWARE.PageFrameNumber</code> * 0x1000 + PageOffset</em></p></blockquote><h3 id=the-software-part>The software part</h3><p>In Windows, the <strong>Working Set (WS)</strong> is a key concept concerning memory management.
It basically corresponds to the set of pages that can be accessed without incurring a page fault.
Three types of WS exist: process, system and session one, each with its own limit.</p><p>Throughout this article, we use the following simplified WS figure to illustrate how Windows virtual address translation behaves:</p><p><a href=/posts/img/InitWorkingSet.png target=_blank><img src=/posts/img/InitWorkingSet.png alt=fig_working_set></a></p><p>Here, we consider the working set of a single process.
For the sake of simplicity, this WS is represented on the left as a set of PTEs.
Each of theses PTEs refers to a valid page as represented on the right side. A valid PTE has the <code>Valid</code> bit set, in which case, the MMU plays its role and performs the translation to physical address.</p><p>When the <code>Valid</code> bit is not set, the MMU ignores all the other PTE flags and accessing such a page will result in a page fault.
This offers the possibility for the OS to use these bits for any purpose and especially to optimize the way it manages its memory.
As a consequence, Windows defines several internal states for a page through a specific union named <code>_MMPTE</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>nt<span style=color:#f92672>!</span>_MMPTE
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> u  : 
</span></span><span style=display:flex><span>      <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Long         : Uint8B
</span></span><span style=display:flex><span>      <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> VolatileLong : Uint8B
</span></span><span style=display:flex><span>      <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Hard         : _MMPTE_HARDWARE
</span></span><span style=display:flex><span>      <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Proto        : _MMPTE_PROTOTYPE
</span></span><span style=display:flex><span>      <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Soft         : _MMPTE_SOFTWARE
</span></span><span style=display:flex><span>      <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> TimeStamp    : _MMPTE_TIMESTAMP
</span></span><span style=display:flex><span>      <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Trans        : _MMPTE_TRANSITION
</span></span><span style=display:flex><span>      <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Subsect      : _MMPTE_SUBSECTION
</span></span><span style=display:flex><span>      <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> List         : _MMPTE_LIST
</span></span></code></pre></div><p>Apart from the already presented <code>_MMPTE_HARDWARE</code>, all the other structures represent <em>software</em> states for a PTE, used by the OS to implement several optimizations.
As detailed in the next sections, looking at the <code>_MMPTE_SOFTWARE</code> tells us what structure is to be considered:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>nt<span style=color:#f92672>!</span>_MMPTE_SOFTWARE
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Valid                : Pos <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span> Bit     <span style=color:#75715e>//_MMPTE_HARDWARE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFileReserved     : Pos <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFileAllocated    : Pos <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ColdPage             : Pos <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> SwizzleBit           : Pos <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Protection           : Pos <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>5</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Prototype            : Pos <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>1</span> Bit    <span style=color:#75715e>//_MMPTE_PROTOTYPE/_MMPTE_SUBSECTION
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Transition           : Pos <span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>1</span> Bit    <span style=color:#75715e>//_MMPTE_TRANSITION
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFileLow          : Pos <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>4</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> UsedPageTableEntries : Pos <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>10</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ShadowStack          : Pos <span style=color:#ae81ff>26</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Unused               : Pos <span style=color:#ae81ff>27</span>, <span style=color:#ae81ff>5</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFileHigh         : Pos <span style=color:#ae81ff>32</span>, <span style=color:#ae81ff>32</span> Bits  <span style=color:#75715e>//_MMPTE_SOFTWARE
</span></span></span></code></pre></div><p>The following sections are already well documented by the <a href=http://blog.rekall-forensic.com/2014/10/windows-virtual-address-translation-and.html>Rekall forensics project</a>.
However, we remind all the possible <em>software</em> PTE states involved in the Windows virtual address translation and their evolutions to mitigate recent CPU speculative execution flaws (CVE-2018-3615 <em>L1 Terminal Fault</em>, aka <em>Foreshadow</em>).</p><h4 id=transition-pte>Transition PTE</h4><p>In Windows, the <strong>Balance Set Manager</strong> (<code>KeBalanceSetManager</code>) is in charge of the Working Sets.
When the available physical memory falls under a certain threshold, this component can decide to remove some rarely used pages from the WS (see <a href=https://www.microsoftpressstore.com/store/windows-internals-part-1-system-architecture-processes-9780735684188>Windows Internals 7th edition chaper 5 : Memory Management</a> for more information concerning the balance set manager).
This is achieved by changing the current state of a PTE from <em>valid</em> (<code>_MMPTE.u.hard.Valid=1</code>) to <em>transition</em> (<code>_MMPTE.u.Hard.Valid=0</code> and <code>_MMPTE.u.Soft.Transition=1</code>).
This step is illustrated in the next figure:</p><p><a href=/posts/img/Transition.png target=_blank><img src=/posts/img/Transition.png alt=fig_transition></a></p><p>In gray, a previously valid page was removed from the working set and the corresponding PTE is marked in <em>transition</em> state.</p><p>Although the page cannot be directly accessed, its content is still present and valid in physical memory.
Upon access, a page fault is triggered which will restore the PTE state from <em>transition</em> to <em>valid</em>.
This <em>transition</em> state corresponds to a <code>_MMPTE_TRANSITION</code> structure:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>nt<span style=color:#f92672>!</span>_MMPTE_TRANSITION
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Valid            : Pos <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span> Bit     <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Write            : Pos <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Spare            : Pos <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> IoTracker        : Pos <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> SwizzleBit       : Pos <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Protection       : Pos <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>5</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Prototype        : Pos <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Transition       : Pos <span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>1</span> Bit    <span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFrameNumber  : Pos <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>36</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Unused           : Pos <span style=color:#ae81ff>48</span>, <span style=color:#ae81ff>16</span> Bits
</span></span></code></pre></div><p>In the <em>transition</em> state, the target physical address of a PTE is calculated as for a <em>valid</em> one:</p><blockquote><p><em>PhysicalAddress = <code>_MMPTE.u.Trans.PageFrameNumber</code> * 0x1000 + PageOffset</em></p></blockquote><h4 id=paging-file-pte>Paging file PTE</h4><p>Later, a page in the <em>transition</em> state will be paged-out to a paging file located on the disk.
This step frees the page from the physical memory and backs it up to the disk as illustrated by the following figure:</p><p><a href=/posts/img/PagingFile.png target=_blank><img src=/posts/img/PagingFile.png alt=fig_paging_file></a></p><p>The corresponding structure is the already viewed <code>_MMPTE_SOFTWARE</code> with <code>Valid</code>, <code>Prototype</code> and <code>Transition</code> flags set to zero but a non null <code>PageFileHigh</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>nt<span style=color:#f92672>!</span>_MMPTE_SOFTWARE
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Valid                : Pos <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span> Bit     <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFileReserved     : Pos <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFileAllocated    : Pos <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ColdPage             : Pos <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> SwizzleBit           : Pos <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Protection           : Pos <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>5</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Prototype            : Pos <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>1</span> Bit    <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Transition           : Pos <span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>1</span> Bit    <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFileLow          : Pos <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>4</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> UsedPageTableEntries : Pos <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>10</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ShadowStack          : Pos <span style=color:#ae81ff>26</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Unused               : Pos <span style=color:#ae81ff>27</span>, <span style=color:#ae81ff>5</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFileHigh         : Pos <span style=color:#ae81ff>32</span>, <span style=color:#ae81ff>32</span> Bits  <span style=color:#75715e>// !=0
</span></span></span></code></pre></div><p>In this case, the only way to retrieve the page content is to read it back from the corresponding paging file.
By default, the OS defines one paging file by drive.
Each paging file is identified by an index.
When a page is backed, the target paging file index corresponds to the <code>PageFileLow</code> field and the page offset in the file (<em>PageFileOffset</em>) is resolved as follows:</p><blockquote><p><em>PageFileOffset = <code>_MMPTE.u.Soft.PageFileHigh</code> * 0x1000 + PageOffset</em></p></blockquote><h4 id=demand-zero-pte>Demand-zero PTE</h4><p>Instead of saving a zero-filled page, the OS simply keeps this information in the corresponding PTE structure.
When such a page has to be restored, the <strong>Balance Set Manager</strong> gets one from the zero page list to update the corresponding PTE.
This list of zero pages is maintained by the zero page thread (<code>MiZeroPageThread</code>) to satisfy demand-zero page faults.</p><p>A demand-zero page presents a non-null PTE value (<code>_MMPTE.u.Long</code>) but the following flags are set to zero in the <code>_MMPTE_SOFTWARE</code> structure: <code>Valid</code>, <code>Prototype</code>, <code>Transition</code> and <code>PageFileHigh</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>nt<span style=color:#f92672>!</span>_MMPTE_SOFTWARE
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Valid                : Pos <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span> Bit     <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFileReserved     : Pos <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFileAllocated    : Pos <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ColdPage             : Pos <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> SwizzleBit           : Pos <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Protection           : Pos <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>5</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Prototype            : Pos <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>1</span> Bit    <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Transition           : Pos <span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>1</span> Bit    <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFileLow          : Pos <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>4</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> UsedPageTableEntries : Pos <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>10</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ShadowStack          : Pos <span style=color:#ae81ff>26</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Unused               : Pos <span style=color:#ae81ff>27</span>, <span style=color:#ae81ff>5</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> PageFileHigh         : Pos <span style=color:#ae81ff>32</span>, <span style=color:#ae81ff>32</span> Bits  <span style=color:#75715e>// 0
</span></span></span></code></pre></div><h4 id=prototype-pte>Prototype PTE</h4><p><em>Prototype</em> PTE aims at describing the memory represented by section objects.
A section object can be created by the <code>CreateFileMapping</code> function, opened by <code>OpenFileMapping</code> and mapped with <code>MapViewOfFile</code>.
Basically, section objects correspond to shared memory as illustrated below:</p><p><a href=/posts/img/Section.png target=_blank><img src=/posts/img/Section.png alt=fig_section></a></p><p>We have two processes, each one owns the same section object (<em>sectionX</em>), which points to the same physical pages.
Here, all the PTE are <em>valid</em>.</p><p>The difficulty concerning the OS is to synchronize the trimming of shared pages.
Indeed, as several PTEs can reference the same physical page, if the OS decides to remove a shared page from physical memory, it has to look for all the PTEs referencing this page to update their current state.
Since this approach appears very inefficient, Windows uses <em>prototype</em> PTEs to address this problem.</p><p>For a complete description of <em>Prototype</em> PTEs and their relation with section objects, the reader can look at this <a href=https://artemonsecurity.blogspot.com/2018/10/what-is-proto-pte-and-how-windows-vmm.html>article</a>.</p><p>In short, when the <strong>Balance Set Manager</strong> trims shared pages, it sets the <code>_MMPTE.u.Soft.Prototype</code> flag in the corresponding PTEs.
In this case, the involved structure is the <code>_MMPTE_PROTOTYPE</code> defined below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>nt<span style=color:#f92672>!</span>_MMPTE_PROTOTYPE
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Valid                : Pos <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span> Bit   <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> DemandFillProto      : Pos <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> HiberVerifyConverted : Pos <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ReadOnly             : Pos <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> SwizzleBit           : Pos <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Protection           : Pos <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>5</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Prototype            : Pos <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>1</span> Bit  <span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Combined             : Pos <span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Unused1              : Pos <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>4</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ProtoAddress         : Pos <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>48</span> Bits
</span></span></code></pre></div><p>In this structure, the <code>ProtoAddress</code> points to another PTE named <em>prototype</em> PTE.
This <em>prototype</em> PTE, allocated in the kernel PagedPool, actually describes the current page state.
Since then, when removing a page, the OS just has to update the corresponding <em>prototype</em> PTE.</p><p>Now, a <em>prototype</em> PTE can itself present all the previously described states : <strong>valid</strong>, <strong>transition</strong>, <strong>paged</strong>, <strong>demand zero</strong>.
Technically other states exists (see Prototype PTEs in <a href=https://www.microsoftpressstore.com/store/windows-internals-part-1-system-architecture-processes-9780735684188>Windows Internals 7th edition chaper 5 : Memory Management</a>) but are not involved in virtual address translation.</p><p>For example, the next figure illustrates a prototype PTE in <em>transition</em> state, which means its <code>PageFrameNumber</code> still targets a physical page with valid content:</p><p><a href=/posts/img/PrototypePTE.png target=_blank><img src=/posts/img/PrototypePTE.png alt=fig_prototype></a></p><h4 id=subsection-pte>Subsection PTE</h4><p>Concerning image file mapping, the system implements a special optimization relying on <em>prototype</em> PTEs.
Indeed, these files includes several non-writable constant pages.
This way, there is no need for the system to back up such pages in the paging files as they already reside in the original file.</p><p>To deal with this case, the system sets the <code>PTE.u.Soft.Prototype</code> flag in the targeted <em>prototype</em> PTE.
The corresponding structure for this PTE is then a <code>_MMPTE_SUBSECTION</code> defined as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>nt<span style=color:#f92672>!</span>_MMPTE_SUBSECTION
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Valid             : Pos <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span> Bit    <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Unused0           : Pos <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> SwizzleBit        : Pos <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Protection        : Pos <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>5</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Prototype         : Pos <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>1</span> Bit   <span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ColdPage          : Pos <span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Unused1           : Pos <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>3</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ExecutePrivilege  : Pos <span style=color:#ae81ff>15</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> SubsectionAddress : Pos <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>48</span> Bits
</span></span></code></pre></div><p>The following figure illustrates this case where a page from the <code>ntdll.dll</code> is removed from both working sets:</p><p><a href=/posts/img/SubsectionPTE.png target=_blank><img src=/posts/img/SubsectionPTE.png alt=fig_subsection></a></p><p>Without entering into details, the <code>_MMPTE.u.Subsect.SubsectionAddress</code> points to a <code>_CONTROL_AREA</code> structure, which itselfs points to a <code>_FILE_OBJECT</code>.
(To locate the page-content described by a <code>_MMPTE_SUBSECTION</code>, thea reader can have a look this <a href=http://blog.rekall-forensic.com/2014/10/windows-virtual-address-translation-and.html>rekall&rsquo;s article</a>).</p><p><strong>Unfortunately, concerning subsection PTEs, their content cannot be accessed without reading the original image file on the file system.</strong></p><h4 id=vad-based-pte>VAD based PTE</h4><p>A last optimization is implemented by Windows.
When the PTE value is null (<code>_MMPTE.u.Long=0</code>) the process <em>Virtual Adress Descriptors</em> (VADs) must be inspected to locate the corresponding <em>prototype</em> PTE (this state is named <em>unknown</em> in Windows Internals and <em>VAD Hardware PTE</em> in the rekall project).
The same case exists when the <code>_MMPTE.u.Soft.Prototype</code> flag is set and the <code>PTE.u.Proto.ProtoAddress</code> equals 0xFFFFFFFF0000 (this state is named <em>Virtual Address Descriptor</em> in Windows Internals and <em>VAD Prototype PTE</em> in the rekall project).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>nt<span style=color:#f92672>!</span>_MMPTE_PROTOTYPE
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Valid                : Pos <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span> Bit     <span style=color:#75715e>// 0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> DemandFillProto      : Pos <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> HiberVerifyConverted : Pos <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ReadOnly             : Pos <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> SwizzleBit           : Pos <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Protection           : Pos <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>5</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Prototype            : Pos <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>1</span> Bit    <span style=color:#75715e>// 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Combined             : Pos <span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>1</span> Bit
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> Unused1              : Pos <span style=color:#ae81ff>12</span>, <span style=color:#ae81ff>4</span> Bits
</span></span><span style=display:flex><span>   <span style=color:#f92672>+</span><span style=color:#ae81ff>0x000</span> ProtoAddress         : Pos <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>48</span> Bits  <span style=color:#75715e>// 0xFFFFFFFF0000
</span></span></span></code></pre></div><p>The following figure illustrates how we can access the desired <em>prototype</em> PTE in such cases.</p><p><a href=/posts/img/VAD_PTEs.png target=_blank><img src=/posts/img/VAD_PTEs.png alt=fig_vad_pte></a></p><p>First, this VAD-based case only happens in the context of a user process.
Starting from the corresponding <code>_EPROCESS</code> structures (in blue), we have to locate the corresponding memory area.
Such an area is called a <em>Virtual Adress Descriptor</em> (VAD) defined with the <code>_MMVAD</code> kernel structure.
Each process owns a set of VADs organized into a self-balanced AVL tree starting from the <code>VadRoot</code> field.
Briefly, each VAD has a starting address (<code>StartingVpn</code> standing for <em>Starting Virtual Page Number</em>) and an ending address (<code>EndingVpn</code>) field.
Three cases are possible:</p><ul><li>The wanted address is below the <code>StartingVpn</code><ul><li>The left child (in red) is to be considered.</li></ul></li><li>The wanted address is above the <code>EndingVpn</code><ul><li>The right child (in blue) is to be considered.</li></ul></li><li>Otherwise the wanted address is withing the range defined by <code>StartingVpn</code> and <code>EndingVpn</code><ul><li>The desired VAD is found (in dark-gray).</li></ul></li></ul><p>Now each VAD exposes an array of <em>prototype</em> PTEs as <code>FirstPrototype</code> field.
As a <em>prototype</em> PTE stands for a 4KB page, it&rsquo;s easy to compute the targeted prototype PTE (in dark-green in this example).
Finally, the obtained <em>prototype</em> PTE is processed as previously seen.</p><h3 id=mitigation-of-l1-terminal-fault-foreshadow>Mitigation of L1 Terminal Fault (Foreshadow)</h3><p>Starting from august 2018, the previous virtual address translation approach evolved.
Indeed, just using the <code>!pte</code> <strong>kd</strong> command on a virtual address could output the following result:</p><pre tabindex=0><code>kd&gt; !pte 7ff743655000
... PTE at FFFFE93FFBA1B2A8
... contains 000020000891F860
... not valid
...   Transition: 891F
...   Protect: 3 - ExecuteRead
</code></pre><p>As you can see the corresponding PTE is not valid (value 000020000891F860).
It&rsquo;s easy to verify that the content stands for a transition PTE with a <code>PageFrameNumber</code> of 0x<strong>2</strong>0000891F.
But <strong>kd</strong> shows a different transition PFN value of 0x891F.
Where does this difference come from?</p><p>A complete answer is given by the <a href=https://msrc-blog.microsoft.com/2018/08/14/analysis-and-mitigation-of-l1-terminal-fault-l1tf/>Microsoft Security Response Center (MSRC)</a>:
a new mitigation concerning a speculative execution side channel vulnerability known as L1 Terminal Fault (L1TF) was introduced.</p><p>In a nutshell, the official MMU behavior, as explained in the Intel manual, is different from the speculative one.
When the <code>_MMPTE_HARDWARE.Valid</code> flag is not set, the CPU speculatively tries to access the page targeted by the <code>PageFrameNumber</code> in the L1 cache.
If present, instructions are prefetched, which can lead to a leak of sensitive information like kernel addresses.</p><p>To mitigate this CPU flaw, Windows now ensures that each invalid PTE has a <code>PageFrameNumber</code> outside the limits of available physical memory.
This is achieved by the <code>MiSwizzleInvalidPte</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>_MMPTE <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>MiSwizzleInvalidPte</span>(_MMPTE pte)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( gKiSwizzleBit )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>(gKiSwizzleBit <span style=color:#f92672>&amp;</span> pte.u.Long) )
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> (_MMPTE)(pte.u.Long <span style=color:#f92672>|</span> gKiSwizzleBit);
</span></span><span style=display:flex><span>    pte.u.Long <span style=color:#f92672>|=</span> MMPTE_SWIZZLE_BIT;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> pte;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>gKiSwizzleBit</code> global value is defined during system initialization in the <code>MiInitializeSystemDefaults</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>KiSwizzleBit <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>i64 <span style=color:#f92672>&lt;&lt;</span> (KiImplementedPhysicalBits <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span></code></pre></div><p>Note that this <code>gKiSwizzleBit</code> is not an official name but just a proposed one for this article.</p><p>The <code>KiImplementedPhysicalBits</code> value is initialized using the <code>cpuid</code> instruction to get the maximum amount of physical memory (see the <code>KiDetectKvaLeakage</code> function).</p><h3 id=summary>Summary</h3><p>The whole PTE resolution algorithm can be summarized in the following figure:</p><p><a href=/posts/img/WindowsPaging.png target=_blank><img src=/posts/img/WindowsPaging.png alt=fig_windows_paging></a></p><p>We are now able to handle all the software PTE states involved in the Windows virtual address translation:</p><ul><li>in green, cases where we can access the content of the targeted page</li><li>in red, the two remaining cases, which still require accessing the file system:<ul><li><strong>paging files PTEs</strong></li><li><strong>subsection PTEs</strong>.</li></ul></li></ul><h2 id=icebox-and-windows-memory-access>IceBox and Windows memory access</h2><p>Instead of looking for a way to parse the virtual disk for paging files (as rekall can do) and executables, <code>IceBox</code> focuses on a more practical approach.
In the ideal case, we&rsquo;d like to boot a VM and access its physical memory without any particular configuration or user action.</p><h3 id=disabling-the-paging-files>Disabling the paging files</h3><p>Disabling the paging files is a well known feature using the <code>sysdm.cpl</code> as illustrated in the following figure:</p><p><a href=/posts/img/sysdm.png target=_blank><img src=/posts/img/sysdm.png alt=fig_sysdm></a></p><p>Modifications are saved in the registry under the <code>\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management</code> key, with a multi-string value named <code>PagingFiles</code> as shown in the following screenshot:</p><p><a href=/posts/img/PagingFilesRegistry.png target=_blank><img src=/posts/img/PagingFilesRegistry.png alt=fig_registry></a></p><p>Paging files are created by the first user process named <code>smss.exe</code>, which is launched during kernel initialization (<code>Phase1InitializationIoReady</code>).
Everything starts in the <code>SmpLoadDataFromRegistry</code> function where the <code>SmpPagingFileList</code> is built from the registry.
Each entry contains the path to a paging file (<code>c:\pagefile.sys</code> and <code>e:\pagefile.sys</code> in our example).
Later the <code>SmpCreatePagingFiles</code> function walks through <code>SmpPagingFileList</code> to finally invoke the <code>NtCreatePagingFile</code> syscall on each paging file.</p><p>To disable paging files in <strong>IceBox</strong> the <code>NtCreatePagingFile</code> function is disabled.
For stealth purpose, no hook is performed.
Instead, a temporary breakpoint is set on <code>NtCreatePagingFile</code>.
When triggered by <code>smss.exe</code>, the control flow is redirected to a RET instruction by modifying the RIP register.
Once initialized, <code>smss.exe</code> launches the first <code>csrss.exe</code> process.
This process start-up allow us to delete the previous breakpoint on <code>NtCreatePagingFile</code>.</p><h3 id=disabling-subsection-ptes>Disabling subsection PTEs</h3><p>To address this problem, let&rsquo;s go deeper into how the system creates and maps <code>_SECTION</code> objects.
It starts with <code>NtCreateSection</code> and its subfunctions:</p><pre tabindex=0><code>NtCreateSection
 NtCreateSectionCommon
  MiCreateSection
   MiCreateImageOrDataSection
    MiCreateNewSection
     MiCreateImageFileMap
</code></pre><p>In this last function, the interesting pseudo-code portion can be summed up as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>status <span style=color:#f92672>=</span> <span style=color:#a6e22e>MiBuildImageControlArea</span>(...,<span style=color:#f92672>&amp;</span>FileSize,<span style=color:#f92672>&amp;</span>pNewControlArea);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>NT_SUCCESS</span>(Status)) <span style=color:#66d9ef>goto</span> CleanUp;
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>IoIsDeviceEjectable</span>(arg0_pFileObject<span style=color:#f92672>-&gt;</span>DeviceObject))
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    bIsEjectable <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (bIsEjectable)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    pNewControlArea<span style=color:#f92672>-&gt;</span>u.ImageControlAreaOnRemovableMedia <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Basically, if the target device object is considered as ejectable, the <code>ImageControlAreaOnRemovableMedia</code> flag is set in the newly created control area.
This flag is then checked in the <code>MiCreateNewSection</code>.
When set, the <code>MiSetPagesModified</code> function is called.
This function updates the state of each PTE describing the section from <em>prototype</em> to <em>transition</em>.
As the paging file is disabled these PTEs will always stay in <em>transition</em> state, which is a state handled by <strong>IceBox</strong>.</p><p>In order to achieve this, the <code>IoIsDeviceEjectable</code> function needs to return true:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>IoIsDeviceEjectable</span>(PDEVICE_OBJECT pDeviceObject)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> (((pDeviceObject<span style=color:#f92672>-&gt;</span>Characteristics <span style=color:#f92672>&amp;</span> FILE_FLOPPY_DISKETTE) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>&amp;</span> <span style=color:#f92672>!</span>_bittest(<span style=color:#f92672>&amp;</span>InitWinPEModeType, <span style=color:#ae81ff>31u</span>)) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Thus, we have two options:</p><ul><li>Force the <code>Characteristics</code> of the volume device to add the <code>FILE_FLOPPY_DISKETTE</code> flag.</li><li>Modify the <code>InitWinPEModeType</code> value.</li></ul><p>The first option requires to detect when the device is created, to update as soon as possible its <code>Characteristics</code>.
The second option seems easier.
Indeed, the <code>InitWinPEModeType</code> is initialized in the <code>Phase1InitializationDiscard</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> ( Options <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>strstr</span>(Options, <span style=color:#e6db74>&#34;MININT&#34;</span>) )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    InitIsWinPEMode <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( <span style=color:#a6e22e>strstr</span>(Options, <span style=color:#e6db74>&#34;INRAM&#34;</span>) )
</span></span><span style=display:flex><span>      InitWinPEModeType <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0x80000000</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>      InitWinPEModeType <span style=color:#f92672>|=</span> <span style=color:#ae81ff>1u</span>;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>This option corresponds to the Windows PE (WinPE) functionality.
According to Microsoft, <a href=https://docs.microsoft.com/en-us/windows-hardware/manufacture/desktop/winpe-intro>WinPE</a> is a small operating system used to deploy, install and repair Windows desktop and server installations.
As this system is launched from an ISO file, it makes sense that the subsection PTE limitation is not a problem with this option.
Cherry on the cake, this option is present (at least) since Windows XP.</p><p><strong>IceBox currently enables the WinPE mode</strong> by forcing this <code>InitWinPEModeType</code> global to 0x80000000 during the OS boot.</p><h3 id=what-about-memory-compression>What about memory compression?</h3><p><strong>Memory compression</strong> is a feature introduced in Windows 10 and backported to Windows 8 and 7.
This mechanism compresses private pages on client Windows versions to increase the amount of available memory.
Memory Compression includes kernel and user parts:</p><ul><li>In the kernel, the core functionality is implemented in a dedicated component named the <strong>Store Manager</strong> (SM) (all the public and private kernel functions prefixed by <code>Sm</code> and <code>Smp</code>).</li><li>In user-space, the <em>Superfetch</em> service (<code>sysmain.dll</code> hosted in a <code>svchost.exe</code> instance) calls the SM by the <code>NtSetSystemInformation</code> to manage store.</li></ul><p>For a complete description of how Memory Compression behaves, see <a href=https://www.microsoftpressstore.com/store/windows-internals-part-1-system-architecture-processes-9780735684188>Windows Internals 7th edition chaper 5 : Memory Management (MemoryCompression)</a>.
As compression is just a memory optimization, we are just interested in disabling this feature.</p><p>The <em>MemoryCompression</em> process is created by the kernel with <code>PsCreateMinimalProcess</code> in the <code>SmFirstTimeInit</code> function .
Just before creating this process, the <code>MmStoreCheckPagefiles</code> function ensures at least one paging file exists, otherwise the status <code>STATUS_NOT_SUPPORTED</code> is returned.</p><p><strong>By disabling the paging files, the memory compression feature is implicitly disabled.</strong></p><h2 id=limitations>Limitations</h2><p>Of course, the previous modifications concerning paging files and the WinPE mode impact the system.
First, <strong>disabling paging files</strong> presents several limitations:</p><ul><li>Paging files represent a second memory storage to virtually increase the physical memory size.
Consequently, disabling paging files directly limits the total amount of available physical memory.
This limitation can easily be overcome by increasing the physical memory of the Virtual Machine.</li><li>In case of system crash, the paging files are involved to temporarily store the resulting crash dump.
Disabling paging files prevents the crash dump from being created.</li><li>As previously mentioned, memory compression requires paging files.
Therefore, disabling paging files prevents from analyzing memory compression internals.</li></ul><p>Second, from a stealth point of view, the <strong>WinPE mode</strong> can easily be detected.
This point is currently not considered in our <strong>IceBox</strong> implementation.</p><h2 id=conclusion>Conclusion</h2><p>This article focused on guest memory access from a VMI point of view.
More precisely, we described some <strong>Windows virtual address translation internals</strong> and recent mitigations with regards to speculative execution side channels vulnerabilities called L1 Terminal Fault.
This fine understanding of memory internals allows us to access any physical page as long as it is still present in memory. It also permits to highlight some cases where the pages are not mapped into the physical memory but only present on the file system.</p><p>We then described how VMI allows an automatic configuration of a Windows guest during its initialization phase to force any pages to be mapped in a persistent way into the memory.
All these aspects are implemented in <a href=https://github.com/thalium/icebox>IceBox</a> which automatically:</p><ul><li><strong>Disables the paging files</strong> to avoid the paged-out mechanism.</li><li><strong>Enables the WinPE</strong> mode to avoid <em>subsection</em> PTEs which directly references pages on the disk.</li></ul><p>Concerning the impact on the system, the induced modifications suffer minor drawbacks compared to the benefits of a full memory introspection.</p><p><strong>Finally, you just have to boot your VM once with icebox, take a snapshot and have fun with memory!</strong></p></div><footer class=post-footer><div class=post-footer-data><div class=tags></div><span class=date>2020-06-22
<span class=author>by
Jean-Marie Borello</span></span></div></footer></article><footer><div class=social-links-footer><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>GitHub</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div><div class=copyright>Copyright (c) 2020, all rights reserved.</div><div class=poweredby>Powered by <a href=https://gohugo.io/>Hugo</a>.</div></footer></div></body></html>