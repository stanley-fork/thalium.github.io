<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=author content="Thalium Team"><meta name=description content="Thalium blog."><meta name=keywords content="blog,tech"><meta name=viewport content="width=device-width,minimum-scale=1,initial-scale=1"><meta name=generator content="Hugo 0.120.4"><link rel=canonical href=/posts/nt_py_icebox/><meta property="og:title" content="NT objects access tracing"><meta property="og:description" content="Draw me a map As homework during the lockdown, I wanted to automate the attack surface analysis of a target on Windows. The main objective was to construct a view of a software architecture to highlight the attack surface (whether remote or local).
The software architecture can be composed of several elements:
processes privileges ipc etc Usually, software architecture analysis is done with tools that give a view at a specific time (ProcessHacker, WinObjEx, etc)."><meta property="og:type" content="article"><meta property="og:url" content="/posts/nt_py_icebox/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-06-07T12:00:00+01:00"><meta property="article:modified_time" content="2021-06-07T12:00:00+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="NT objects access tracing"><meta name=twitter:description content="Draw me a map As homework during the lockdown, I wanted to automate the attack surface analysis of a target on Windows. The main objective was to construct a view of a software architecture to highlight the attack surface (whether remote or local).
The software architecture can be composed of several elements:
processes privileges ipc etc Usually, software architecture analysis is done with tools that give a view at a specific time (ProcessHacker, WinObjEx, etc)."><meta itemprop=name content="NT objects access tracing"><meta itemprop=description content="Draw me a map As homework during the lockdown, I wanted to automate the attack surface analysis of a target on Windows. The main objective was to construct a view of a software architecture to highlight the attack surface (whether remote or local).
The software architecture can be composed of several elements:
processes privileges ipc etc Usually, software architecture analysis is done with tools that give a view at a specific time (ProcessHacker, WinObjEx, etc)."><meta itemprop=datePublished content="2021-06-07T12:00:00+01:00"><meta itemprop=dateModified content="2021-06-07T12:00:00+01:00"><meta itemprop=wordCount content="2879"><meta itemprop=keywords content><link rel=stylesheet href=/css/layout.css><link rel=stylesheet href=/css/default-dark.css><link rel=icon href=/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-141692648-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><title>NT objects access tracing
</title><script>MathJax={tex:{inlineMath:[["∳","∳"]],displayMath:[["∳∳","∳∳"]],processEscapes:!0},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script></head><body><style>@font-face{font-family:days_one;src:url(/days_one.ttf)format('truetype')}.siteTitle{margin-top:24px}.siteTitle img{display:inline-block;vertical-align:middle;margin-top:-24px;margin-right:-10px}.siteTitle span{font-family:days_one,Fallback,sans-serif;color:#fff;font-size:160%}</style><div class=main><header><div class=header-bar><nav><div class=siteTitle><a href=/><img src=/shard_only_no_background.png width=12%></img>
<span>THALIUM</span></a></div><a class=nav-item href=/posts/><div class=nav-item-title>Posts</div></a><a class=nav-item href=/joinus/><div class=nav-item-title>Join Us</div></a><a class=nav-item href=/about/><div class=nav-item-title>About</div></a></nav><div class=social-links-header><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>Github</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div></div></header><article class=post><h1 class=title>NT objects access tracing</h1><div class=content><h1 id=draw-me-a-map>Draw me a map</h1><p>As homework during the lockdown, I wanted to automate the attack surface analysis of a target on <strong>Windows</strong>. The main objective was to construct a view of a software architecture to highlight the attack surface (whether remote or local).</p><p>The software architecture can be composed of several elements:</p><ul><li>processes</li><li>privileges</li><li>ipc</li><li>etc</li></ul><p>Usually, software architecture analysis is done with tools that give a view at a specific time (<code>ProcessHacker</code>, <code>WinObjEx</code>, etc). However, the different components of the software architecture might be invoked dynamically and temporarily on certain conditions. Monitoring tools such as <code>ProcMon</code> can help in this context but these involve manual operations.</p><p>Thus, the changes in the software architecture should be considered in order to obtain an exhaustive view of it.</p><p>Enter <a href=https://github.com/thalium/icebox>Icebox</a>, a VMI (Virtual Machine Introspection) framework, which gives the ability to <strong>monitor</strong> a virtual machine and its overlying operating system.
Nonetheless, basic support for Windows needs to be implemented before we can consider constructing a view of the software architecture and its attack surface.</p><p>Especially, with primitive support for the <code>NT Object namespace</code>, we will be able to collect essential information to construct the attack surface.
The output of this support will be, at first, a basic textual log of collected information.</p><p>Finally, with VMI, code execution inside the virtual machine is not an option. Thus, we will have to reimplement Windows kernel functions to mimic their behavior.
Projects such as <a href=https://github.com/google/rekall>Rekall</a> and <a href=https://github.com/volatilityfoundation/volatility>Volatility</a> are good open source entry points. I also tend to intensively use the kernel itself (<code>ntoskrnl.exe</code>) or even WinDBG to validate my assumptions.</p><p>This blogpost does not intend to present new Windows concepts (everything below has already been documented). However, it shows a practical/playful way to navigate inside the Windows kernel with Icebox.</p><p><strong>Disclaimer: the implementation given below has no intention to fully support Windows with all its versions and all their specificities.</strong></p><p><strong>Disclaimer 2: I worked on this subject without publication in mind. I failed to record every resource I used and some references might be missing. Feel free to let me know if you spot anything wrong.</strong></p><h1 id=processes>Processes</h1><p>With Icebox, there are two ways to monitor processes:</p><ul><li>list living processes</li><li>observe the creation of processes</li></ul><p>These two methods have been documented in a <a href=/posts/getting_started/>previous blogpost</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> icebox
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vm <span style=color:#f92672>=</span> icebox<span style=color:#f92672>.</span>attach(<span style=color:#e6db74>&#34;win10&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># list current processes</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> proc <span style=color:#f92672>in</span> vm<span style=color:#f92672>.</span>processes():
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>%d</span><span style=color:#e6db74>: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> (proc<span style=color:#f92672>.</span>pid(), proc<span style=color:#f92672>.</span>name()))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>on_create</span>(proc):
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>&#34;+ </span><span style=color:#e6db74>%d</span><span style=color:#e6db74>: </span><span style=color:#e6db74>%s</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>%</span> (proc<span style=color:#f92672>.</span>pid(), proc<span style=color:#f92672>.</span>name()))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># break on process creation</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>with</span> vm<span style=color:#f92672>.</span>processes<span style=color:#f92672>.</span>break_on_create(on_create):
</span></span><span style=display:flex><span>    vm<span style=color:#f92672>.</span>exec()
</span></span></code></pre></div><p>Obviously, all of the output of these methods won&rsquo;t necessarily be related to our software, some of these processes need to be filtered out.
A good criterion to filter the processes is the image file name location (e.g. in the software installation folder).</p><h1 id=windows-ipc>Windows IPC</h1><p>From the established list of processes, it is possible to monitor all interactions between them and other Windows objects. The focal point of these interactions is the creation by a process of a <code>HANDLE</code> to another Windows object.</p><p>Some of the Windows objects accessed could be used by the target software as a way to receive data. Analyzing these objects and their <code>security descriptor</code> will give a representation of the prime attack surface.</p><h2 id=break-at-some-point>Break at some point</h2><p>The <code>HANDLE</code> creation is done by Windows through the kernel function <code>nt!ObpCreateHandle</code>. By breaking onto this function, it is possible to monitor all accesses to the objects by the software processes.</p><p>The prototype of this function is given below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>NTSTATUS
</span></span><span style=display:flex><span><span style=color:#a6e22e>ObpCreateHandle</span>(
</span></span><span style=display:flex><span>  IN  OB_OPEN_REASON OpenReason,
</span></span><span style=display:flex><span>  IN  PVOID Object,
</span></span><span style=display:flex><span>  IN  POBJECT_TYPE ExpectedObjectType OPTIONAL,
</span></span><span style=display:flex><span>  IN  PACCESS_STATE AccessState,
</span></span><span style=display:flex><span>  IN  ULONG ObjectPointerBias OPTIONAL,
</span></span><span style=display:flex><span>  IN  ULONG Attributes,
</span></span><span style=display:flex><span>  IN  POBP_LOOKUP_CONTEXT LookupContext,
</span></span><span style=display:flex><span>  IN  KPROCESSOR_MODE AccessMode,
</span></span><span style=display:flex><span>  OUT PVOID <span style=color:#f92672>*</span>ReferencedNewObject OPTIONAL,
</span></span><span style=display:flex><span>  OUT PHANDLE Handle
</span></span><span style=display:flex><span>  );
</span></span></code></pre></div><p>The parameter of interest is <code>PVOID Object</code> which is a pointer to the body of the object.</p><p>In order to break onto this function and obtain said pointer through Icebox, we can use the following snippet:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> icebox
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> nt_types <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># specify the targeted VM</span>
</span></span><span style=display:flex><span>vm <span style=color:#f92672>=</span> icebox<span style=color:#f92672>.</span>attach(<span style=color:#e6db74>&#34;win10&#34;</span>)
</span></span><span style=display:flex><span>proc <span style=color:#f92672>=</span> vm<span style=color:#f92672>.</span>processes<span style=color:#f92672>.</span>current()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># get the address of the given symbol</span>
</span></span><span style=display:flex><span>addr <span style=color:#f92672>=</span> proc<span style=color:#f92672>.</span>symbols<span style=color:#f92672>.</span>address(<span style=color:#e6db74>&#34;nt!ObpCreateHandle&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># breakpoint callback</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>on_break</span>():
</span></span><span style=display:flex><span>    p <span style=color:#f92672>=</span> vm<span style=color:#f92672>.</span>processes<span style=color:#f92672>.</span>current()
</span></span><span style=display:flex><span>    p<span style=color:#f92672>.</span>symbols<span style=color:#f92672>.</span>load_modules()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># access the argument stored in rdx</span>
</span></span><span style=display:flex><span>    _object <span style=color:#f92672>=</span> nt_Object(p, vm<span style=color:#f92672>.</span>registers<span style=color:#f92672>.</span>rdx)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># break on the address of nt!ObpCreateHandle and execute the callback on_break</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> vm<span style=color:#f92672>.</span>break_on(addr, on_break):
</span></span><span style=display:flex><span>        vm<span style=color:#f92672>.</span>exec()
</span></span></code></pre></div><p>At this point, the object has an opaque structure, it might be needed to support the specificities of each object type. Indeed, the <code>PVOID</code> pointer will be used as specific type pointer by the NT Object Manager:</p><ul><li><code>nt!_FILE_OBJECT</code></li><li><code>nt!_SECTION_OBJECT</code></li><li><code>nt!_ALPC_PORT</code></li><li>etc</li></ul><p>To go further, we need to obtain generic information about the object. This has been done through the implementation of the <code>nt_Object</code> class.</p><h2 id=generic-object-handling>Generic object handling</h2><p>In Windows, an <code>nt object</code> is <strong>roughly</strong> composed of two parts:</p><ul><li>an object header containing metadata such as: <code>object type</code>, <code>security descriptor</code>, <code>creator information</code>, <code>object name</code>, etc</li><li>an object body containing all the specific information of the <code>nt object</code></li></ul><p>In order to access these data through the opaque nt object pointer we have, it is required to implement the object specifities through Icebox.</p><p>Here is an example of the <code>nt_Object</code> class <a href=https://github.com/agatignol/NtPy/blob/master/handle_tracer/nt_types.py#L531>implementation</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>nt_Object</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, proc, p_object):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>object <span style=color:#f92672>=</span> p_object
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># obtain a pointer to the header of the object</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>object_header <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_object_header(proc)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># obtain the info mask in order to obtain metadata on the object</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>object_header_info_mask <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_object_header_info_mask(proc)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># obtain the pointer to the security descriptor of the object</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>sd <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_object_sd(proc)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># obtain the object type</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>object_type <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_object_type(proc)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># obtain a pointer to the body of the object</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>object_body <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_object_body(proc)
</span></span></code></pre></div><p>In order to get a better handling of the object body, it is necessary to identify the object type.</p><p>To obtain the object type, the Windows kernel uses the <code>nt!ObGetObjectType</code> function. Below, one implementation of this function is given.
This implementation relies on two functions:</p><ul><li>an accesser to the encoded object type: <code>__get_object_type</code></li><li>a decoder to retrieve the real object type: <code>__get_type_index</code></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__get_type_index</span>(self, proc, ObHeaderCookie):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        offset <span style=color:#f92672>=</span> get_symbol_offset(proc, <span style=color:#e6db74>&#34;nt!_OBJECT_HEADER&#34;</span>, <span style=color:#e6db74>&#34;TypeIndex&#34;</span>)
</span></span><span style=display:flex><span>        typeindex <span style=color:#f92672>=</span> read_byte(proc, self<span style=color:#f92672>.</span>object_header <span style=color:#f92672>+</span> offset)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        cookie <span style=color:#f92672>=</span> read_byte(proc, ObHeaderCookie)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        addr_lsb <span style=color:#f92672>=</span> get_n_byte(self<span style=color:#f92672>.</span>object_header, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># use the cookie to get the real index</span>
</span></span><span style=display:flex><span>        index <span style=color:#f92672>=</span> typeindex <span style=color:#f92672>^</span> cookie <span style=color:#f92672>^</span> int(addr_lsb, <span style=color:#ae81ff>16</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> index
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__get_object_type</span>(self, proc):
</span></span><span style=display:flex><span>       <span style=color:#75715e># nt!ObGetObjectType</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>object_header <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e># array of object type</span>
</span></span><span style=display:flex><span>       ObTypeIndexTable <span style=color:#f92672>=</span> proc<span style=color:#f92672>.</span>symbols<span style=color:#f92672>.</span>address(<span style=color:#e6db74>&#34;nt!ObTypeIndexTable&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e># object type protection cookie</span>
</span></span><span style=display:flex><span>       ObHeaderCookie <span style=color:#f92672>=</span> proc<span style=color:#f92672>.</span>symbols<span style=color:#f92672>.</span>address(<span style=color:#e6db74>&#34;nt!ObHeaderCookie&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       index <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_type_index(proc, ObHeaderCookie)
</span></span><span style=display:flex><span>       a_object_type <span style=color:#f92672>=</span> ObTypeIndexTable <span style=color:#f92672>+</span> (index <span style=color:#f92672>*</span> <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>       object_type <span style=color:#f92672>=</span> read_uint64(proc, a_object_type)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       o_name <span style=color:#f92672>=</span> get_symbol_offset(proc, <span style=color:#e6db74>&#34;nt!_OBJECT_TYPE&#34;</span>, <span style=color:#e6db74>&#34;Name&#34;</span>)
</span></span><span style=display:flex><span>       name_string <span style=color:#f92672>=</span> object_type <span style=color:#f92672>+</span> o_name
</span></span><span style=display:flex><span>       object_type_name <span style=color:#f92672>=</span> get_unicode_string(proc, name_string)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>return</span> object_type_name
</span></span></code></pre></div><p>Apart from the kernel itself, more details are given in the following blogpost to retrieve the object type:</p><ul><li><a href=https://medium.com/@ashabdalhalim/a-light-on-windows-10s-object-header-typeindex-value-e8f907e7073a>https://medium.com/@ashabdalhalim/a-light-on-windows-10s-object-header-typeindex-value-e8f907e7073a</a></li></ul><p>To summarize, we are now able to get three properties regarding a requested <code>HANDLE</code>:</p><ul><li>the object <strong>type</strong></li><li>the object <strong>header</strong></li><li>the object <strong>body</strong></li></ul><p>Once the object type is determined, it is possible to gather object type-specific information through type-specific handlers.</p><p>For instance, the <code>nt_Process</code> class, used to represent <code>nt!_EPROCESS</code>, implements the <code>__get_mitigations</code> method to gather its <code>MitigationFlagsValues</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> icebox
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> argparse
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> utils <span style=color:#f92672>import</span> <span style=color:#f92672>*</span>
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> nt_types <span style=color:#f92672>import</span> nt_Process
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MITIGATIONS <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00000001</span>: <span style=color:#e6db74>&#34;ControlFlowGuardEnabled&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00000002</span>: <span style=color:#e6db74>&#34;ControlFlowGuardExportSuppressionEnabled&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00000004</span>: <span style=color:#e6db74>&#34;ControlFlowGuardStrict&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00000008</span>: <span style=color:#e6db74>&#34;DisallowStrippedImages&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00000010</span>: <span style=color:#e6db74>&#34;ForceRelocateImages&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00000020</span>: <span style=color:#e6db74>&#34;HighEntropyASLREnabled&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00000040</span>: <span style=color:#e6db74>&#34;StackRandomizationDisabled&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00000080</span>: <span style=color:#e6db74>&#34;ExtensionPointDisable&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00000100</span>: <span style=color:#e6db74>&#34;DisableDynamicCode&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00000200</span>: <span style=color:#e6db74>&#34;DisableDynamicCodeAllowOptOut&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00000400</span>: <span style=color:#e6db74>&#34;DisableDynamicCodeAllowRemoteDowngrade&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00000800</span>: <span style=color:#e6db74>&#34;AuditDisableDynamicCode&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00001000</span>: <span style=color:#e6db74>&#34;DisallowWin32kSystemCalls&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00002000</span>: <span style=color:#e6db74>&#34;AuditDisallowWin32kSystemCalls&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00004000</span>: <span style=color:#e6db74>&#34;EnableFilteredWin32kAPIs&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00008000</span>: <span style=color:#e6db74>&#34;AuditFilteredWin32kAPIs&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00010000</span>: <span style=color:#e6db74>&#34;DisableNonSystemFonts&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00020000</span>: <span style=color:#e6db74>&#34;AuditNonSystemFontLoading&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00040000</span>: <span style=color:#e6db74>&#34;PreferSystem32Images&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00080000</span>: <span style=color:#e6db74>&#34;ProhibitRemoteImageMap&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00100000</span>: <span style=color:#e6db74>&#34;AuditProhibitRemoteImageMap&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00200000</span>: <span style=color:#e6db74>&#34;ProhibitLowILImageMap&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00400000</span>: <span style=color:#e6db74>&#34;AuditProhibitLowILImageMap&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x00800000</span>: <span style=color:#e6db74>&#34;SignatureMitigationOptIn&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x01000000</span>: <span style=color:#e6db74>&#34;AuditBlockNonMicrosoftBinaries&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x02000000</span>: <span style=color:#e6db74>&#34;AuditBlockNonMicrosoftBinariesAllowStore&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x04000000</span>: <span style=color:#e6db74>&#34;LoaderIntegrityContinuityEnabled&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x08000000</span>: <span style=color:#e6db74>&#34;AuditLoaderIntegrityContinuity&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x10000000</span>: <span style=color:#e6db74>&#34;EnableModuleTamperingProtection&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x20000000</span>: <span style=color:#e6db74>&#34;EnableModuleTamperingProtectionNoInherit&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>nt_Process</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, proc, body):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>process <span style=color:#f92672>=</span> body
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_process_name(proc)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>pid <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_pid(proc)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>token <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_token(proc)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>parent <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_parent(proc)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>mitigations <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_mitigations(proc)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>il <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>token <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>il <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>token<span style=color:#f92672>.</span>get_il()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __str__(self):
</span></span><span style=display:flex><span>        info <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>            <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Process: </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;ParentId: </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>parent<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        )
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>mitigations:
</span></span><span style=display:flex><span>            info <span style=color:#f92672>+=</span> <span style=color:#e6db74>&#34;Mitigations:&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> mitigation <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>mitigations:
</span></span><span style=display:flex><span>                info <span style=color:#f92672>+=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>{</span>mitigation<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        info <span style=color:#f92672>+=</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Integrity level: </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>il<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> os<span style=color:#f92672>.</span>linesep<span style=color:#f92672>.</span>join(info)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_name</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_pid</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>pid
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_mitigations</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>mitigations
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_parent_pid</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>parent
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__get_token</span>(self, proc):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>process <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        o_token <span style=color:#f92672>=</span> get_symbol_offset(
</span></span><span style=display:flex><span>            proc, <span style=color:#e6db74>&#34;nt!_EPROCESS&#34;</span>, <span style=color:#e6db74>&#34;Token&#34;</span>)
</span></span><span style=display:flex><span>        a_token <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>process <span style=color:#f92672>+</span> o_token
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        token <span style=color:#f92672>=</span> read_uint64(proc, a_token)
</span></span><span style=display:flex><span>        token <span style=color:#f92672>=</span> token <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xfffffffffffffff0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> token <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> nt_Token(proc, token)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__get_parent</span>(self, proc):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>process <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        o_pid <span style=color:#f92672>=</span> get_symbol_offset(
</span></span><span style=display:flex><span>            proc, <span style=color:#e6db74>&#34;nt!_EPROCESS&#34;</span>, <span style=color:#e6db74>&#34;OwnerProcessId&#34;</span>)
</span></span><span style=display:flex><span>        a_pid <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>process <span style=color:#f92672>+</span> o_pid
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> read_uint64(proc, a_pid)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__resolve_mitigations</span>(self, proc, mitigationflag, mitigationflag2):
</span></span><span style=display:flex><span>        mitigations <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> k, v <span style=color:#f92672>in</span> MITIGATIONS<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> k <span style=color:#f92672>&amp;</span> mitigationflag:
</span></span><span style=display:flex><span>                mitigations<span style=color:#f92672>.</span>append(v)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> k, v <span style=color:#f92672>in</span> MITIGATIONS2<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> k <span style=color:#f92672>&amp;</span> mitigationflag2:
</span></span><span style=display:flex><span>                mitigations<span style=color:#f92672>.</span>append(v)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mitigations
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__get_mitigations</span>(self, proc):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>process <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        o_flag <span style=color:#f92672>=</span> get_symbol_offset(
</span></span><span style=display:flex><span>            proc, <span style=color:#e6db74>&#34;nt!_EPROCESS&#34;</span>, <span style=color:#e6db74>&#34;MitigationFlags&#34;</span>)
</span></span><span style=display:flex><span>        a_flag <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>process <span style=color:#f92672>+</span> o_flag
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        flag_b <span style=color:#f92672>=</span> proc<span style=color:#f92672>.</span>memory[a_flag:a_flag <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>        flag <span style=color:#f92672>=</span> unpack_from(<span style=color:#e6db74>&#34;&lt;I&#34;</span>, flag_b)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        o_flag2 <span style=color:#f92672>=</span> get_symbol_offset(
</span></span><span style=display:flex><span>            proc, <span style=color:#e6db74>&#34;nt!_EPROCESS&#34;</span>, <span style=color:#e6db74>&#34;MitigationFlags2&#34;</span>)
</span></span><span style=display:flex><span>        a_flag2 <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>process <span style=color:#f92672>+</span> o_flag2
</span></span><span style=display:flex><span>        flag2_b <span style=color:#f92672>=</span> proc<span style=color:#f92672>.</span>memory[a_flag2:a_flag2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>        flag2 <span style=color:#f92672>=</span> unpack_from(<span style=color:#e6db74>&#34;&lt;I&#34;</span>, flag2_b)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        mitigations <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__resolve_mitigations(proc, flag, flag2)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> mitigations
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__get_pid</span>(self, proc):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>process <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        o_pid <span style=color:#f92672>=</span> get_symbol_offset(
</span></span><span style=display:flex><span>            proc, <span style=color:#e6db74>&#34;nt!_EPROCESS&#34;</span>, <span style=color:#e6db74>&#34;UniqueProcessId&#34;</span>)
</span></span><span style=display:flex><span>        a_pid <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>process <span style=color:#f92672>+</span> o_pid
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> read_uint64(proc, a_pid)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__get_process_name</span>(self, proc):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>process <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        o_name <span style=color:#f92672>=</span> get_symbol_offset(
</span></span><span style=display:flex><span>            proc, <span style=color:#e6db74>&#34;nt!_EPROCESS&#34;</span>, <span style=color:#e6db74>&#34;ImageFileName&#34;</span>)
</span></span><span style=display:flex><span>        a_name <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>process <span style=color:#f92672>+</span> o_name
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>__read_process_name(proc, a_name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__read_process_name</span>(self, proc, a_name):
</span></span><span style=display:flex><span>        name <span style=color:#f92672>=</span> bytearray()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>15</span>):
</span></span><span style=display:flex><span>            name <span style=color:#f92672>+=</span> read_byte(proc, a_name <span style=color:#f92672>+</span> i)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> name<span style=color:#f92672>.</span>decode(<span style=color:#e6db74>&#34;utf8&#34;</span>, <span style=color:#e6db74>&#34;ignore&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vm <span style=color:#f92672>=</span> icebox<span style=color:#f92672>.</span>attach(<span style=color:#e6db74>&#34;win10&#34;</span>)
</span></span><span style=display:flex><span>process <span style=color:#f92672>=</span> nt_Process(vm<span style=color:#f92672>.</span>processes<span style=color:#f92672>.</span>current(), vm<span style=color:#f92672>.</span>processes<span style=color:#f92672>.</span>current()<span style=color:#f92672>.</span>native())
</span></span><span style=display:flex><span>print(process)
</span></span></code></pre></div><p>An example output for this would be:</p><pre tabindex=0><code>Process: svchost.exe (1184)
ParentId: 566
Mitigations:
        ControlFlowGuardEnabled
        HighEntropyASLREnabled
Integrity level: System
</code></pre><h2 id=security-descriptor-and-inner-structures>Security descriptor and inner structures</h2><p>The handling of the <code>object header</code> gives access to generic information such as <code>nt!_SECURITY_DESCRIPTOR</code> and the related <code>ACL</code> and <code>ACE</code>.</p><p>This security information is used to determine whether it is possible to access the object with a given identity.</p><p>There will be some cases where the <code>nt!_SECURITY_DESCRIPTOR</code> is <code>NULL</code>. Usually, this means that anyone can access the object.</p><blockquote><p>However, this is not true regarding <code>files</code>. Indeed, the <code>nt namespace object</code> does not manage the security of files on the filesystem.</p></blockquote><p>For most of the object types, the <code>security descriptor</code> in the object header is representative.</p><p>To get access to it, the Windows kernel uses the <code>nt!ObGetObjectSecurity</code> function, which is reimplemented below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__get_object_sd</span>(self, proc):
</span></span><span style=display:flex><span>        <span style=color:#75715e># nt!ObGetObjectSecurity</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        o_sd <span style=color:#f92672>=</span> get_symbol_offset(
</span></span><span style=display:flex><span>            proc, <span style=color:#e6db74>&#34;nt!_OBJECT_HEADER&#34;</span>, <span style=color:#e6db74>&#34;SecurityDescriptor&#34;</span>)
</span></span><span style=display:flex><span>        a_sd <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>object_header <span style=color:#f92672>+</span> o_sd
</span></span><span style=display:flex><span>        sd <span style=color:#f92672>=</span> read_uint64(proc, a_sd)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> sd <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sd <span style=color:#f92672>=</span> sd <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xfffffffffffffff0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> nt_SecurityDescriptor(proc, sd)
</span></span></code></pre></div><p>Here is an example of the <code>nt_SecurityDescriptor</code> class implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>nt_SecurityDescriptor</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, proc, sd):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>sd <span style=color:#f92672>=</span> sd
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>revision <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_revision(proc)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>control <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_control_flags(proc)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>dacl <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>sacl <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>control <span style=color:#f92672>&amp;</span> SE_DACL_PRESENT:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>dacl <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_dacl(proc)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>control <span style=color:#f92672>&amp;</span> SE_SACL_PRESENT:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>sacl <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_sacl(proc)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>owner_sid <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_owner_sid(proc)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>group_sid <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_group_sid(proc)
</span></span></code></pre></div><p>The important member of this class is the <code>dacl</code>.</p><p><code>dacl</code> identifies the trustees that are allowed or denied access to a securable object.</p><p>Both <code>dacl</code> and <code>sacl</code> are access control list (<code>ACL</code>):</p><ul><li><code>dacl</code>: identifies the users and groups that are allowed or denied access</li><li><code>sacl</code>: controls how access is audited</li></ul><p>In Windows, the <code>dacl</code> is implemented as a list of access control entries (<code>ACE</code>).
An <code>ACE</code> is a pair of trustee with its access to the targeted securable object.</p><p>The <a href=https://docs.microsoft.com/en-us/windows/win32/secauthz/access-control-lists>Microsoft documentation</a> describes in further details its ACL mechanisms.</p><p>To obtain the <code>dacl</code> of a <code>security descriptor</code>, an implementation of the kernel function <code>nt!RtlGetDaclSecurityDescriptor</code> is required. Below, one possible implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__get_dacl</span>(self, proc):
</span></span><span style=display:flex><span>        <span style=color:#75715e># nt!RtlGetDaclSecurityDescriptor</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>sd <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># only revision 1 is supported</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>revision <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        o_group <span style=color:#f92672>=</span> get_symbol_offset(
</span></span><span style=display:flex><span>            proc, <span style=color:#e6db74>&#34;nt!_SECURITY_DESCRIPTOR&#34;</span>, <span style=color:#e6db74>&#34;Group&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        group_value <span style=color:#f92672>=</span> read_uint64(proc, self<span style=color:#f92672>.</span>sd <span style=color:#f92672>+</span> o_group)
</span></span><span style=display:flex><span>        group_value <span style=color:#f92672>=</span> group_value <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x00000000ffffffff</span>
</span></span><span style=display:flex><span>        dacl <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>sd <span style=color:#f92672>+</span> group_value
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> nt_Acl(proc, dacl)
</span></span></code></pre></div><p>This <code>dacl</code> is then read through the <code>nt_Acl</code> class:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>nt_Acl</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, proc, acl):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>acl <span style=color:#f92672>=</span> acl
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>revision, sbz, self<span style=color:#f92672>.</span>acl_size, self<span style=color:#f92672>.</span>ace_count, sbz2 <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_acl_info(
</span></span><span style=display:flex><span>            proc)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>ace_list <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_ace_list(proc)
</span></span></code></pre></div><blockquote><p>A good reference to extract information from <code>ACL</code> has been the following stackoverflow post:</p><ul><li><a href=https://stackoverflow.com/questions/34698927/python-get-windows-folder-acl-permissions>https://stackoverflow.com/questions/34698927/python-get-windows-folder-acl-permissions</a>
I have reused a good portion of the code given in example.</li></ul></blockquote><p>The list of <code>ACE</code> is walked through with the following function, which is a reimplementation of <code>nt!RtlGetAce</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__get_ace_list</span>(self, proc):
</span></span><span style=display:flex><span>        <span style=color:#75715e># nt!RtlGetAce</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ace_list <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ace_array <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>acl <span style=color:#f92672>+</span> proc<span style=color:#f92672>.</span>symbols<span style=color:#f92672>.</span>struc(<span style=color:#e6db74>&#34;nt!_ACL&#34;</span>)<span style=color:#f92672>.</span>size
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>ace_count <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> ace_list
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        offset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> ace <span style=color:#f92672>in</span> range(self<span style=color:#f92672>.</span>ace_count):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (ace_array <span style=color:#f92672>+</span> offset <span style=color:#f92672>&gt;=</span> self<span style=color:#f92672>.</span>acl <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>acl_size):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            ace_addr <span style=color:#f92672>=</span> ace_array <span style=color:#f92672>+</span> offset
</span></span><span style=display:flex><span>            acestr <span style=color:#f92672>=</span> proc<span style=color:#f92672>.</span>memory[ace_addr:ace_addr <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>]
</span></span><span style=display:flex><span>            ace_type, ace_flags, ace_size <span style=color:#f92672>=</span> unpack_from(<span style=color:#e6db74>&#34;&lt;BBH&#34;</span>, acestr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (ace_size <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e># documentation: windows_protocols/ms-dtyp (https://docs.microsoft.com/openspecs/windows_protocols/ms-dtyp)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (ace_type <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x00</span>):
</span></span><span style=display:flex><span>                <span style=color:#75715e># struct ACCESS_ALLOWED_ACE_TYPE</span>
</span></span><span style=display:flex><span>                ace_mask <span style=color:#f92672>=</span> read_uint64(proc, ace_array <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>+</span> offset)
</span></span><span style=display:flex><span>                ace_mask <span style=color:#f92672>=</span> ace_mask <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x00000000ffffffff</span>
</span></span><span style=display:flex><span>                ace_sid <span style=color:#f92672>=</span> get_sid_string(proc, ace_array <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>+</span> offset)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>elif</span> (ace_type <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x01</span>):
</span></span><span style=display:flex><span>                <span style=color:#75715e># struct ACCESS_DENIED_ACE_TYPE</span>
</span></span><span style=display:flex><span>                ace_mask <span style=color:#f92672>=</span> read_uint64(proc, ace_array <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span> <span style=color:#f92672>+</span> offset)
</span></span><span style=display:flex><span>                ace_mask <span style=color:#f92672>=</span> ace_mask <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x00000000ffffffff</span>
</span></span><span style=display:flex><span>                ace_sid <span style=color:#f92672>=</span> get_sid_string(proc, ace_array <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>+</span> offset)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e># ACE Type not handled</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            offset <span style=color:#f92672>=</span> offset <span style=color:#f92672>+</span> ace_size
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            trustee <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>            ace <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_ace(proc, ace_type,
</span></span><span style=display:flex><span>                                 ace_flags, ace_mask, ace_sid, trustee)
</span></span><span style=display:flex><span>            ace_list<span style=color:#f92672>.</span>append(ace)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> ace_list
</span></span></code></pre></div><p>Unfortunately, the types <code>_ACE_HEADER</code> and <code>_ACE</code> are not published in the Windows symbols. The definition used in the implementation of <code>nt!RtlGetAce</code> is given below:</p><pre tabindex=0><code>    # 00000000 _ACE            struc
    # (sizeof=0x8, align=0x4, copyof_2324)
    # 00000000 Header          ACE_HEADER ?
    # 00000004 AccessMask      dd ?
    # 00000008 _ACE            ends

    # 00000000 ACE_HEADER      struc
    # (sizeof=0x4, align=0x2, copyof_2325)
    # 00000000 AceType         db ?
    # 00000001 AceFlags        db ?
    # 00000002 AceSize         dw ?
    # 00000004 ACE_HEADER      ends

    # 00000000 _ACCESS_ALLOWED_ACE struc
    # (sizeof=0xC, align=0x4, copyof_2328)
    # 00000000 Header          ACE_HEADER ?
    # 00000004 Mask            dd ?
    # 00000008 SidStart        dd ?
    # 0000000C _ACCESS_ALLOWED_ACE ends
</code></pre><p>And finally, an <code>ACE</code> object is initialized in an <code>nt_Ace</code> class. This class will interpret the <code>AccessMask</code> and render the <code>Sid</code> of the trustee.</p><p>As a result, we are now able to get the list of authorized accesses for every object accessed through a <code>HANDLE</code> request.</p><p>An example of output for this would be:</p><pre tabindex=0><code>Object: 0xffffd9025e00c060
Object type: Token

DACL:
	S-1-5-18:(DE,RC,WDAC,WO,RD,WD,AD,REA,WEA,X,DC,RA,WA)
	S-1-3-4:(RC)
	S-1-5-80-3635958274-2059881490-2225992882-984577281-633327304:(DE,RC,WDAC,WO,RD,WD,AD,REA,WEA,X,DC,RA,WA)
	S-1-5-32-544:(REA)
SACL:
	S-1-16-16384:(RD)
</code></pre><h1 id=privileges>Privileges</h1><p>From there, it is possible to construct a complete map of the target software:</p><ul><li>a list of processes</li><li>a list of interactions through nt objects</li><li>the ACL of the nt objects used</li></ul><p>The attack surface is almost established. The privileges of the involved processes are not known yet.
Indeed, from an attacker point of view, it is interesting to target processes that have more privileges (e.g. privilege escalation). As a standard user has a <code>Medium integrity level</code>, then all processes running with a lower integrity level are not interesting.</p><p>To obtain this information, it is required to analyze the token of the processes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>
</span></span><span style=display:flex><span>INTEGRITY_LEVEL <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x0000</span>: <span style=color:#e6db74>&#34;Untrusted&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x1000</span>: <span style=color:#e6db74>&#34;Low&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x2000</span>: <span style=color:#e6db74>&#34;Medium&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x3000</span>: <span style=color:#e6db74>&#34;High&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x4000</span>: <span style=color:#e6db74>&#34;System&#34;</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>nt_Token</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, proc, p_token):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>token <span style=color:#f92672>=</span> p_token
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>il <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>__get_il(proc)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_il</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>il
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__get_il</span>(self, proc):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>token <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        o_sidhash <span style=color:#f92672>=</span> get_symbol_offset(
</span></span><span style=display:flex><span>            proc, <span style=color:#e6db74>&#34;nt!_TOKEN&#34;</span>, <span style=color:#e6db74>&#34;SidHash&#34;</span>)
</span></span><span style=display:flex><span>        a_sidhash <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>token <span style=color:#f92672>+</span> o_sidhash
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> a_sidhash <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        count <span style=color:#f92672>=</span> read_uint64(proc, a_sidhash)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        o_arraysid <span style=color:#f92672>=</span> get_symbol_offset(
</span></span><span style=display:flex><span>            proc, <span style=color:#e6db74>&#34;nt!_TOKEN&#34;</span>, <span style=color:#e6db74>&#34;UserAndGroups&#34;</span>)
</span></span><span style=display:flex><span>        a_arraysid <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>token <span style=color:#f92672>+</span> o_arraysid
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        arraysid <span style=color:#f92672>=</span> read_uint64(proc, a_arraysid)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        size <span style=color:#f92672>=</span> proc<span style=color:#f92672>.</span>symbols<span style=color:#f92672>.</span>struc(<span style=color:#e6db74>&#34;nt!_SID_AND_ATTRIBUTES&#34;</span>)<span style=color:#f92672>.</span>size
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sid <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>        ptr <span style=color:#f92672>=</span> arraysid
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> arraysid <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> sid <span style=color:#f92672>in</span> range(count):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            o_attributes <span style=color:#f92672>=</span> get_symbol_offset(
</span></span><span style=display:flex><span>                proc, <span style=color:#e6db74>&#34;nt!_SID_AND_ATTRIBUTES&#34;</span>, <span style=color:#e6db74>&#34;Attributes&#34;</span>)
</span></span><span style=display:flex><span>            a_attributes <span style=color:#f92672>=</span> ptr <span style=color:#f92672>+</span> o_attributes
</span></span><span style=display:flex><span>            attributes <span style=color:#f92672>=</span> read_uint64(proc, a_attributes)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> attributes <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0x20</span>:  <span style=color:#75715e># SE_GROUP_INTEGRITY = 0x00000020L</span>
</span></span><span style=display:flex><span>                o_sid <span style=color:#f92672>=</span> get_symbol_offset(
</span></span><span style=display:flex><span>                    proc, <span style=color:#e6db74>&#34;nt!_SID_AND_ATTRIBUTES&#34;</span>, <span style=color:#e6db74>&#34;Sid&#34;</span>)
</span></span><span style=display:flex><span>                a_sid <span style=color:#f92672>=</span> ptr <span style=color:#f92672>+</span> o_sid
</span></span><span style=display:flex><span>                sid <span style=color:#f92672>=</span> read_uint64(proc, a_sid)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                subauthority <span style=color:#f92672>=</span> get_sid_subauthority(proc, sid)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span> k, v <span style=color:#f92672>in</span> INTEGRITY_LEVEL<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> k <span style=color:#f92672>&amp;</span> subauthority:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> v
</span></span><span style=display:flex><span>            ptr <span style=color:#f92672>+=</span> size
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>The integrity level of a token can now be obtained and the attack surface is now complete.</p><p>Indeed, we can choose the attack surface to analyze with the following criteria:</p><ul><li>accessible surface (ACL)</li><li>object type used to interact</li><li>targeted process privileges (integrity level)</li></ul><h1 id=showtime-live-windows>Showtime: Live Windows</h1><p>As a demonstration of the tool, here is a sample of the kind of information you can collect on a running Windows:</p><pre tabindex=0><code>--------------------------------
Process: dwm.exe         (948)
ParentId: 540
Mitigations:
	ControlFlowGuardEnabled
	HighEntropyASLREnabled
Integrity level: System

Object: 0xffffd9025e00c060
Object type: Token
Owner: NT Authority
DACL:
	S-1-5-18:(DE,RC,WDAC,WO,RD,WD,AD,REA,WEA,X,DC,RA,WA)
	S-1-3-4:(RC)
	S-1-5-80-3635958274-2059881490-2225992882-984577281-633327304:(DE,RC,WDAC,WO,RD,WD,AD,REA,WEA,X,DC,RA,WA)
	S-1-5-32-544:(REA)
SACL:
	S-1-16-16384:(RD)

--------------------------------
Process: dwm.exe         (948)
ParentId: 540
Mitigations:
	ControlFlowGuardEnabled
	HighEntropyASLREnabled
Integrity level: System

Object: 0xffff820f667444a0
Object type: File

Security Descriptor: NULL

--------------------------------
Process: dwm.exe         (948)
ParentId: 540
Mitigations:
	ControlFlowGuardEnabled
	HighEntropyASLREnabled
Integrity level: System

Object: 0xffff820f69f442e0
Object type: Event

Security Descriptor: NULL
</code></pre><p>As we can see, the process <code>dwm.exe</code> which is running with <code>SystemIL</code> has asked access to (in the output order):</p><ul><li>a <code>token</code> which has specific <code>dacl</code></li><li>a <code>file</code> (<code>ACL</code> on files are handled differently)</li><li>an <code>event</code> that is accessible to <code>everyone</code></li></ul><p>Obviously, it is possible to also get the <a href=https://github.com/thalium/icebox/blob/2bce97eb589ccbefe8fd1260fef3cb4cb158fb71/src/icebox/icebox_py/examples/getting_started.py#L12>callstack</a> of the handle creation.</p><p>The code of this POC is available <a href=https://github.com/agatignol/NtPy/tree/master/handle_tracer>here</a>.</p><h1 id=further-work>Further work</h1><p>At this point, it is possible to imagine several ways to improve the process:</p><ol><li>store the data in <a href=https://neo4j.com/>Neo4j</a> to improve the visualization</li></ol><p>The textual log output is not optimal to play with. A graph visualization could be a lot more intuitive to observe links between processes and objects.</p><ol start=2><li>start the reverse of <code>ntfs.sys</code> to obtain the ACL on files</li></ol><p><code>ACL</code> on files are not stored in the <code>Object Manager</code>, it would be interesting to deep dive into <code>ntfs.sys</code> to understand how the <code>ACL</code> can be accessed through memory if possible.</p><ol start=3><li>implement a scenario to autoloot vulnerabilities (e.g. based on privileged file operations)</li></ol><p>Even if Windows 10 implements hardlink mitigations that reduce the likelihood of privileged file operation vulnerabilities, it would be interesting to correct this kind of <a href=https://offsec.almond.consulting/intro-to-file-operation-abuse-on-Windows.html>bugs</a>.</p></div><footer class=post-footer><div class=post-footer-data><div class=tags></div><span class=date>2021-06-07
<span class=author>by
<a href=https://twitter.com/_anyfun>Arnaud Gatignol</a></span></span></div></footer></article><footer><div class=social-links-footer><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>GitHub</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div><div class=copyright>Copyright (c) 2020, all rights reserved.</div><div class=poweredby>Powered by <a href=https://gohugo.io/>Hugo</a>.</div></footer></div></body></html>