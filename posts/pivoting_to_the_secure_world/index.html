<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=author content="Thalium Team"><meta name=description content="Thalium blog."><meta name=keywords content="blog,tech"><meta name=viewport content="width=device-width,minimum-scale=1,initial-scale=1"><meta name=generator content="Hugo 0.121.1"><link rel=canonical href=/posts/pivoting_to_the_secure_world/><meta property="og:title" content="ARM TrustZone: pivoting to the secure world"><meta property="og:description" content="
Discovery of two vulnerabilities in secure world components
Exploitation to get code execution in a trusted driver, while not having a debugger for this obscure environment
Leverage of aarch32 T32 instruction set to find nice stack pivots
Turning an arbitrary write into an arbitrary code execution
"><meta property="og:type" content="article"><meta property="og:url" content="/posts/pivoting_to_the_secure_world/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-24T13:37:00+00:00"><meta property="article:modified_time" content="2023-03-24T13:37:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="ARM TrustZone: pivoting to the secure world"><meta name=twitter:description content="
Discovery of two vulnerabilities in secure world components
Exploitation to get code execution in a trusted driver, while not having a debugger for this obscure environment
Leverage of aarch32 T32 instruction set to find nice stack pivots
Turning an arbitrary write into an arbitrary code execution
"><meta itemprop=name content="ARM TrustZone: pivoting to the secure world"><meta itemprop=description content="
Discovery of two vulnerabilities in secure world components
Exploitation to get code execution in a trusted driver, while not having a debugger for this obscure environment
Leverage of aarch32 T32 instruction set to find nice stack pivots
Turning an arbitrary write into an arbitrary code execution
"><meta itemprop=datePublished content="2023-03-24T13:37:00+00:00"><meta itemprop=dateModified content="2023-03-24T13:37:00+00:00"><meta itemprop=wordCount content="6498"><meta itemprop=keywords content="Android,Exploit,Vulnerability Research,"><link rel=stylesheet href=/css/layout.css><link rel=stylesheet href=/css/default-dark.css><link rel=icon href=/favicon.ico><script>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-141692648-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><title>ARM TrustZone: pivoting to the secure world
</title><script>MathJax={tex:{inlineMath:[["∳","∳"]],displayMath:[["∳∳","∳∳"]],processEscapes:!0},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script></head><body><style>@font-face{font-family:days_one;src:url(/days_one.ttf)format('truetype')}.siteTitle{margin-top:24px}.siteTitle img{display:inline-block;vertical-align:middle;margin-top:-24px;margin-right:-10px}.siteTitle span{font-family:days_one,Fallback,sans-serif;color:#fff;font-size:160%}</style><div class=main><header><div class=header-bar><nav><div class=siteTitle><a href=/><img src=/shard_only_no_background.png width=12%></img>
<span>THALIUM</span></a></div><a class=nav-item href=/posts/><div class=nav-item-title>Posts</div></a><a class=nav-item href=/joinus/><div class=nav-item-title>Join Us</div></a><a class=nav-item href=/about/><div class=nav-item-title>About</div></a></nav><div class=social-links-header><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>Github</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div></div></header><article class=post><h1 class=title>ARM TrustZone: pivoting to the secure world</h1><div class=content><ol><li>Discovery of two vulnerabilities in secure world components</li><li>Exploitation to get code execution in a trusted driver, while not having a debugger for this obscure environment</li><li>Leverage of aarch32 T32 instruction set to find nice stack pivots</li><li>Turning an arbitrary write into an arbitrary code execution</li></ol><h2 id=the-hidden-world-beneath-android>The hidden world beneath Android</h2><p>The story starts where one of the previous stories you have heard about Android ends, with arbitrary code execution in both userland and kernel. Let&rsquo;s assume we have defused SELinux, bypassed seccomp limitations and have full privileges over Linux kernel. What could we do next?</p><p>While Android lives in plain sight, the secure world lives in its shadow. Let us put light on it! First, let&rsquo;s coin a few terms:</p><ul><li><strong>ARM TrustZone</strong>: security extensions that ship with ARM v7-A and v8-A. They basically allow <strong>the hardware to be partitioned in two: a normal and a secure worlds</strong>. In this model, the secure world embeds the most privileged exception level, <code>S-EL3</code>, and secure OS, <code>S-EL1</code>, holds a powerful hand on the hardware devices</li><li><strong>Trusted Execution Environment</strong>: aka <strong>TEE</strong> encompasses the applets, libraries and operating system living in the secure world</li><li><strong>Samsung Knox</strong>: a set of trusted components and normal world application components, such as Android apps and libraries. The terms &ldquo;secure&rdquo; and &ldquo;trusted&rdquo; are swappable for the rest of the article. It indicates a small, mastered TCB hosted in a secure execution environment</li><li><strong>TEEgris</strong>: Samsung Trusted OS that ships some Exynos-based devices. In the past, Samsung used to ship with Kinibi, a different trusted OS which has been the subject of security publications. Even Samsung models may ship with Qualcomm SoCs, and its own trusted OS called QSEE. High level descriptions of various TEE and their vulnerabilities can be found in <a href=#SoK>SoK</a></li></ul><img src=/posts/img/pivoting-to-the-secure-world/teegris-ARM-TrustZone.svg alt="TEEgris names on ARM TrustZone"><p>TEEgris information is rather scarce on the Internet, we have only found a few sources: <a href=#menaniri>Federico menaniri @RISCURE</a>, who exploits several vulnerabilities to gain secure memory write from normal world and <a href=#tarasikov>Alexander tarasikov</a>, who emulates secure boot using <code>qemu</code> and performs <code>afl</code> fuzzing of trusted applets</p><ul><li><p><strong>Trusted applets</strong>: applications that run in the TEE, to provide additional security protections against compromise in the normal world. For example, quoting Google Android documentation:</p><p><code>Android applications concerned by security may use Android keystore to save their sensitive cryptographic keys to be compromised in the normal world</code></p></li></ul><p>For the rest of the article, the device we used is <code>SM-J330FN</code>, with early 2019 firmware <code>J330FNXXU3BSA2_J330FNXEF3BSA2_XEF</code>. It ships <code>Exynos7570 SoC</code>, which is based on ARMv8-A design. Samsung has brought to our attention the firmwares based on version Android 12 (or upper) no longer contain the vulnerabilities we present here. More details will be found in sections describing vulnerabilities.</p><h2 id=how-do-normal-world-applications-talk-to-the-secure-world>How do normal world applications talk to the secure world</h2><p>The single software component able to switch the processor state between normal and secure is the trusted firmware operating at EL3. Code running at lower exception levels can use <code>smc</code> instructions to trigger it. As this ARM instruction is not accessible from EL0, <strong>giving normal world applications access to the TEE will require EL1 support</strong>. For our case study:</p><ul><li>a userspace daemon <code>tzdaemon</code> has the adequate SELinux profile to access the device <code>/dev/tz_wormhole</code>;</li><li>kernel-side, <code>/dev/tz_wormhole</code> implements EL3 triggering mechanism together with sanitization.</li></ul><p>The source code of <code>tz_wormhole</code> is located in <code>drivers/misc/tzdev</code> in Samsung&rsquo;s Android kernel sources.</p><img src=/posts/img/pivoting-to-the-secure-world/teegris-Samsung-TEE.svg alt="Samsung TEEgris"><p>TEEGris is the S-EL1 component, and features are brought by the trusted applets, living in S-EL0.</p><h2 id=finding-the-trusted-applets>Finding the trusted applets</h2><p>This is not the case for all TEE designs, but we are lucky this time. The normal world, which we have total control of, stores trusted applets as files. For our device, those files are in <code>/system/tee/</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>j3y17lte:/system/tee $ ls -lR
</span></span><span style=display:flex><span>.:
</span></span><span style=display:flex><span>total <span style=color:#ae81ff>6736</span>
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root   <span style=color:#ae81ff>67121</span> 2008-12-31 16:00 00000000-0000-0000-0000-00000000dead
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root  <span style=color:#ae81ff>298529</span> 2008-12-31 16:00 00000000-0000-0000-0000-000000534b4d
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root <span style=color:#ae81ff>1895418</span> 2008-12-31 16:00 00000000-0000-0000-0000-0000534b504d
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root   <span style=color:#ae81ff>95561</span> 2008-12-31 16:00 00000000-0000-0000-0000-00535453540a
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root   <span style=color:#ae81ff>85969</span> 2008-12-31 16:00 00000000-0000-0000-0000-00535453540c
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root  <span style=color:#ae81ff>218181</span> 2008-12-31 16:00 00000000-0000-0000-0000-00535453540d
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root   <span style=color:#ae81ff>59405</span> 2008-12-31 16:00 00000000-0000-0000-0000-00535453540f
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root   <span style=color:#ae81ff>85785</span> 2008-12-31 16:00 00000000-0000-0000-0000-0053545354ab
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root  <span style=color:#ae81ff>615917</span> 2008-12-31 16:00 00000000-0000-0000-0000-00575644524d
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root   <span style=color:#ae81ff>23765</span> 2008-12-31 16:00 00000000-0000-0000-0000-474154454b45
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root  <span style=color:#ae81ff>109985</span> 2008-12-31 16:00 00000000-0000-0000-0000-4b45594d5354
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root  <span style=color:#ae81ff>393312</span> 2008-12-31 16:00 00000000-0000-0000-0000-505256544545
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root  <span style=color:#ae81ff>571553</span> 2008-12-31 16:00 00000000-0000-0000-0000-534543445256
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root  <span style=color:#ae81ff>162133</span> 2008-12-31 16:00 00000000-0000-0000-0000-534543535452
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root  <span style=color:#ae81ff>789777</span> 2008-12-31 16:00 00000000-0000-0000-0000-564c544b5052
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root   <span style=color:#ae81ff>47333</span> 2008-12-31 16:00 00000000-0000-0000-582f-586d3efb39b4
</span></span><span style=display:flex><span>drwxr-xr-x <span style=color:#ae81ff>2</span> root root    <span style=color:#ae81ff>4096</span> 2008-12-31 16:00 driver
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root <span style=color:#ae81ff>1344367</span> 2008-12-31 16:00 startup.tzar
</span></span><span style=display:flex><span>./driver:
</span></span><span style=display:flex><span>total <span style=color:#ae81ff>28</span>
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root <span style=color:#ae81ff>17217</span> 2008-12-31 16:00 00000000-0000-0000-0000-00535453540b
</span></span><span style=display:flex><span>-rw-r--r-- <span style=color:#ae81ff>1</span> root root  <span style=color:#ae81ff>6425</span> 2008-12-31 16:00 18d9f073-18a5-4ade-9def-875e07f7f293_
</span></span></code></pre></div><p>Files named using an UUID sheme embed a genuine ELF ARM32 binary:</p><pre style=background-color:#272822;white-space:pre-wrap;word-wrap:break-word>
$ hexdump -C 00000000-0000-0000-0000-534543535452
00000000  53 45 43 32 00 02 75 10  <font color=#a6e22e><b>7f 45 4c 46 01 01 01 00</b></font>  |SEC2..u.<font color=#a6e22e><b>.ELF....|</b></font>
<font color=#a6e22e><b>00000010  00 00 00 00 00 00 00 00  02 00 28 00 01 00 00 00  |..........(.....|
00000020  74 17 01 00 34 00 00 00  f0 71 02 00 02 02 00 05  |t...4....q......|
... ELF ARM32 ...</b></font>
...       17 73 61 6d 73 75 6e 67  5f 64 72 76 3a 73 61 6d  |.samsung_drv:sam|
...       73 75 6e 67 5f 64 72 76  01 00 3e bb aa 17 58 1d  |sung_drv..>...X.|
...
...       30 1e 06 03 55 04 03 14  17 73 61 6d 73 75 6e 67  |0...U....samsung|
...       5f 64 72 76 3a 73 61 6d  73 75 6e 67 5f 64 72 76  |_drv:samsung_drv|
...       30 82 01 22 30 0d 06 09  2a 86 48 86 f7 0d 01 01  |0.."0...*.H.....|</font>
</pre><p>Embedded ARM32 ELF files can be carved out of their containers, and loaded with IDA. The additional data, which isn&rsquo;t part of the ELF, most likely contains a signature, to ensure integrity in case of normal world corruption.</p><p><code>/system/tee/startup.tzar</code> contains a part of Secure World userspace files. The name looks like a tar archive, indeed it is an <a href=#tzar>archive format</a>, documented by <a href=#tarasikov>Alexander tarasikov</a>.</p><p>The archive decompresses to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ tree startup_tzar
</span></span><span style=display:flex><span>├── startup_tzar
</span></span><span style=display:flex><span>│   └── bin
</span></span><span style=display:flex><span>│       ├── 00000004-0004-0004-0404-040404040404
</span></span><span style=display:flex><span>│       ├── 00000005-0005-0005-0505-050505050505
</span></span><span style=display:flex><span>│       ├── 00000006-0006-0006-0606-000000000001
</span></span><span style=display:flex><span>│       ├── 00000006-0006-0006-0606-000000000002
</span></span><span style=display:flex><span>│       ├── arm
</span></span><span style=display:flex><span>│       │   ├── libc++.so
</span></span><span style=display:flex><span>│       │   ├── libdlmsl.so
</span></span><span style=display:flex><span>│       │   ├── libmath.so
</span></span><span style=display:flex><span>│       │   ├── libpthread.so
</span></span><span style=display:flex><span>│       │   ├── libringbuf.so
</span></span><span style=display:flex><span>│       │   ├── libtee_debugsl.so
</span></span><span style=display:flex><span>│       │   ├── libteesl.so
</span></span><span style=display:flex><span>│       │   ├── libteesock.so
</span></span><span style=display:flex><span>│       │   └── libtzsl.so
</span></span><span style=display:flex><span>│       └── libtzld.so
</span></span></code></pre></div><p>Overall, the archive contains:</p><ul><li>userspace libraries, in <code>bin/arm</code>, like <code>libtzsl.so</code>, and <code>libteesl.so</code>. Symbols point to the TEE GlobalPlatform API, which is documented online. Those libraries are true ARM32 ELF files, without the header and footer we have observed above for trusted applets and drivers;</li><li>the dynamic linker, <code>libtzld.so</code>, again, a plain ARM32 ELF file.</li></ul><p>All in all we have found trusted applets, trusted drivers and trusted libraries. Let&rsquo;s analyze them.</p><h3 id=typing-globalplatform-tee-api>Typing GlobalPlatform TEE API</h3><p>First we take a look at <code>libteesl.so</code>. It provides the implementation of tons of functions matching the pattern <code>TEE_*</code>. The curious reader might consult TEE GlobalPlatform documents for more information: they define a set of APIs, offered by TEE for trusted applets to execute. For applets to run on a TEE, they need to export a few functions. The set of APIs offered to applets is extensive, including using TCP/IP sockets via a normal userspace daemon. Back to <code>libteesl.so</code>, this is the implementation following the API. In order to help the reverse engineering of trusted components, we have developed an IDA type library:</p><ul><li><em>adapted</em> TEE GlobalPlatform headers are compiled using Hexrays&rsquo;s <code>tilib</code> to build <code>tee_arm.til</code>, to be copied into <code>${IDA_HOME}/til/arm</code>;</li><li>The same headers are processed using <code>pycparser</code> to generate function signatures, and statically map a function name to a type info. The output is a Python script <code>tee_arm.py</code>, that can be launched on a loaded binary to type functions.</li></ul><p>IDA is now capable of understanding the TEE API facet of trusted applets and drivers:</p><img src=/posts/img/pivoting-to-the-secure-world/ida-Typed_functions.png alt="Typed functions"><p>We now have a nice environment to perform static analysis of the keymaster trusted applet. It is named <code>00000000-0000-0000-0000-4b45594d5354</code> in tzar archive. Note that <code>hexlify(b'KEYMST') == b'4b45594d5354'</code></p><h2 id=gaining-control-of-keymst-trustlet>Gaining control of KEYMST trustlet</h2><h3 id=identifying-entry-points-of-a-trusted-applet>Identifying entry points of a trusted applet</h3><p>GlobalPlatform TEE API defines five callbacks to interact with a trusted applet:</p><ul><li><code>TA_CreateEntryPoint</code> and <code>TA_DestroyEntryPoint</code> are called when the trusted applet is created and destroyed</li><li><code>TA_OpenSessionEntryPoint</code> and <code>TA_CloseSessionEntryPoint</code> are called when a normal world application opens and closes a session with it</li><li><code>TA_InvokeCommandEntryPoint</code> is called when a normal world application sends a request to it: this function will hold a dispatch logic based on the request code. Once a normal world has created a session with the trusted applet, it can perform several commands, and then close the session</li></ul><p>Note that the <code>main</code> function is not located in a trusted applet binary, but is in <code>libteesl.so</code>. It performs initialization of the trusted applet then loops to process messages received over POSIX message queues. The exported functions are then called by the teesl library upon reception of suitable messages.</p><h3 id=the-vulnerability-vanilla-stack-overflow>The vulnerability: vanilla stack overflow</h3><p>Having the binary at hand for static analysis, let us first look at security hardening:</p><pre style=background-color:#272822;white-space:pre-wrap;word-wrap:break-word>
$ <font color=#66d9ef>pwn</font> checksec KEYMST
[*] 'KEYMST'
    Arch:     arm-32-little
    RELRO:    <font color=#f92672>No RELRO</font>
    Stack:    <font color=#f92672>No canary found</font>
    NX:       <font color=#a6e22e>NX enabled</font>
    PIE:      <font color=#f92672>No PIE (0x10000)</font>
</pre><p>Starting with <code>TA_InvokeCommandEntryPoiny</code>, we quickly jump to <code>tz_process_command</code>, and after a while end up in a small function doing a weird <code>memcpy</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>__int64</span> <span style=color:#a6e22e>hal_rsa_key_get_pub_exp</span>(hal_rsa_key <span style=color:#f92672>*</span>a1)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>size_t</span> pub_exp_size; <span style=color:#75715e>// r2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>v2; <span style=color:#75715e>// r1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>__int64</span> v4; <span style=color:#75715e>// [sp+0h] [bp-18h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  pub_exp_size <span style=color:#f92672>=</span> a1<span style=color:#f92672>-&gt;</span>pub_exp_size;
</span></span><span style=display:flex><span>  v2 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>a1<span style=color:#f92672>-&gt;</span>content <span style=color:#f92672>+</span> a1<span style=color:#f92672>-&gt;</span>pub_exp_offset;
</span></span><span style=display:flex><span>  v4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0LL</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>memcpy</span>(<span style=color:#f92672>&amp;</span>v4, v2, pub_exp_size); <span style=color:#75715e>/* pub_exp_size is controlled by normal world app */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> v4;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function is called when importing a PKCS8 formatted RSA private key. The public exponent of the RSA key, which is an attacker controlled value, is copied onto the stack. While legitimate public exponents are generally small, the key format brings no guarantee that its value fits in a 64 bits integer. The format of the private key by itself does not have any restrictions, but the implementation does verify some assumptions about the key, among which the size of the public exponent, that should be less than 512 bytes. All in all, we can <strong>overwrite up to <code>0x200-8=0x1f8</code> bytes on the stack</strong>.</p><p>To reach this vulnerability, we still have to pass through a number of function calls, and each function processes parts of the parameter. This means we need to craft the input buffer to go through:</p><ul><li><code>TA_InvokeCommandEntryPoint</code>: TEE API entry point. Input buffer embeds a type, which is <strong>verified</strong></li><li><code>tz_process_command</code>, <code>km_import_key</code>: those functions parse and assert parameters of the public key. We will not detail the verifications done, as they are not complex to get around</li><li><code>km_rsa_key_get_pub_exp</code>: jumper to <code>hal_rsa_key_get_pub_exp</code>, which <strong>overflows the stack</strong></li></ul><p>As we do not have any working input buffer, we have to build a correct one from scratch. However, there is no way to debug the secure world on a production device, so as to identify the code paths taken when processing a request.</p><h3 id=building-a-teegris-emulator-on-top-of-qiling>Building a TEEGris emulator on top of <code>qiling</code></h3><p>To enhance our dynamic analysis capabilities, we have implemented a TEEGris emulator based on <code>qiling</code>. The device will only be used to test our cooked payloads, and verify meaningful effects. We have not opted to follow Alexander Tarasikov&rsquo;s track, since we want to be able to add dynamic analysis fragments of code, and not recompile qemu each time.</p><p>We have chosen <code>qiling</code> for the following reasons:</p><ul><li><code>qiling</code> is written in Python, and allows for easy hooking of instructions and memory. As we emulate, we can build advanced analysis that we would be unable to get on real hardware using a debug interface, like looking for uninitialized stack variables</li><li><code>qiling</code> already has POSIX syscall emulation, though the mecanism will need to be adapted to TEEGris syscalls flavour</li><li><code>qiling</code> supports snapshot and restore, so we can bootstrap a trusted applet, snapshot it, and quickly restore it later to further explore from the restored state</li></ul><p>To know more about the TEEGris system calls, we analyze <code>libtzsl.so</code>:</p><ul><li><p>To find the system call convention: by peeking at a few wrappers, here we show <code>syslog</code> wrapper, we can make the assumption that <code>r7</code> holds the system call number, and arguments are passed through <code>r0</code> to <code>r6</code>:<pre style=background-color:#272822;white-space:pre-wrap;word-wrap:break-word>
.text:0000BDC8 syslog                                  ; CODE XREF: j_syslog+8↑j
.text:0000BDC8                                         ; DATA XREF: LOAD:00001338↑o ...
.text:0000BDC8                 PUSH            {R4,R7,R11,LR}
.text:0000BDCC                 MOV             R7, #0x12
.text:0000BDD0                 ADD             R11, SP, #0xC
.text:0000BDD4                 SVC             0
.text:0000BDD8                 CMN             R0, #0x1000
.text:0000BDDC                 MOV             R4, R0
.text:0000BDE0                 BLS             loc_BDF4
.text:0000BDE4                 RSB             R4, R4, #0
.text:0000BDE8                 BL              j_get_errno_addr
.text:0000BDEC                 STR             R4, [R0]
.text:0000BDF0                 MOV             R4, #0xFFFFFFFF
.text:0000BDF4
.text:0000BDF4 loc_BDF4                                ; CODE XREF: syslog+18↑j
.text:0000BDF4                 MOV             R0, R4
.text:0000BDF8                 POP             {R4,R7,R11,PC}
.text:0000BDF8 ; End of function syslog
</pre></p></li><li><p>To find the system call numbers: we have written a Python script that automates the job of spotting <code>r7</code> initialization followed by supervisor call, by looking back a few instructions once <code>svc #0</code> has been found. Once a system call pattern has been detected, we lookup the last exported function preceding it. A few corner cases have to be hand resolved, as the logic is a bit too simplistic.</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#f92672>./</span>extract<span style=color:#f92672>-</span>syscalls<span style=color:#f92672>.</span>py startup_tzar<span style=color:#f92672>/</span>bin<span style=color:#f92672>/</span>arm<span style=color:#f92672>/</span>libtzsl<span style=color:#f92672>.</span>so
</span></span><span style=display:flex><span>syscalls <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e># sysno: (name, start of function, address of svc #0)</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span>: (<span style=color:#e6db74>&#39;thread_create&#39;</span>, <span style=color:#ae81ff>0xbe70</span>, <span style=color:#ae81ff>0xbed4</span>),
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2</span>: (<span style=color:#e6db74>&#39;thread_wait&#39;</span>, <span style=color:#ae81ff>0xbf5c</span>, <span style=color:#ae81ff>0xbf68</span>),
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>3</span>: (<span style=color:#e6db74>&#39;mmap&#39;</span>, <span style=color:#ae81ff>0x52fc</span>, <span style=color:#ae81ff>0x5380</span>),
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>4</span>: (<span style=color:#e6db74>&#39;munmap&#39;</span>, <span style=color:#ae81ff>0x5bbc</span>, <span style=color:#ae81ff>0x5bc8</span>),
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>5</span>: (<span style=color:#e6db74>&#39;epoll_ctl&#39;</span>, <span style=color:#ae81ff>0x33b0</span>, <span style=color:#ae81ff>0x33bc</span>),
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>6</span>: (<span style=color:#e6db74>&#39;close&#39;</span>, <span style=color:#ae81ff>0x2c78</span>, <span style=color:#ae81ff>0x2c84</span>),
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>7</span>: (<span style=color:#e6db74>&#39;open&#39;</span>, <span style=color:#ae81ff>0x5bf0</span>, <span style=color:#ae81ff>0x5c10</span>),
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>8</span>: (<span style=color:#e6db74>&#39;read&#39;</span>, <span style=color:#ae81ff>0x6bd0</span>, <span style=color:#ae81ff>0x6bdc</span>),
</span></span><span style=display:flex><span><span style=color:#f92672>...</span>
</span></span></code></pre></div><p>Back to qiling, we had to modify <code>os</code> and <code>linker</code> layers:</p><ol><li><strong>os</strong> : analyzing <code>libtzsl.so</code> has yielded system call numbers and names. We made sure to emulate <code>open</code> and <code>mmap</code> properly at first, then implemented additional system calls when needed</li><li><strong>linker</strong>: OS passes information about the started binary through an auxiliary vector. This information is processed in the early life of the dynamic linker. The linker expects a hardwired order of the values in the auxiliary vector</li><li><strong>os</strong>: even though secure kernel looks POSIX, it uses weird semantics: <code>ioctl(fd, 0, 0)</code> on a file backed descriptor returns the size of the file, just like <code>fstat(fd, &amp;stat); return stat.st_size;</code> would</li></ol><h4 id=glue-teegris-system-calls-to-already-emulated-qiling-system-calls>Glue TEEGris system calls to already emulated qiling system calls</h4><p>To add new system calls, we use <code>Qiling.set_syscall</code>. Rather than rewrite every system call, we prefer to wire each given system call number to a Linux syscall that is already emulated in <code>qiling</code>: we use <code>Qiling.set_syscall</code> and we lookup the original implementation with:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>self<span style=color:#f92672>.</span>original_handlers <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>map_syscall <span style=color:#f92672>=</span> utils<span style=color:#f92672>.</span>ql_syscall_mapping_function(self<span style=color:#f92672>.</span>ostype)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> x <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>400</span>):
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> map_syscall(self, x)
</span></span><span style=display:flex><span>    <span style=color:#75715e># syscall is not already handled by qiling</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> y <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>: <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># resolve handler</span>
</span></span><span style=display:flex><span>    handler <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> y <span style=color:#f92672>in</span> dir(posix_syscall):
</span></span><span style=display:flex><span>        handler <span style=color:#f92672>=</span> getattr(posix_syscall, y)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> y <span style=color:#f92672>in</span> dir(linux_syscall):
</span></span><span style=display:flex><span>        handler <span style=color:#f92672>=</span> getattr(linux_syscall, y)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>assert</span>(y<span style=color:#f92672>.</span>startswith(<span style=color:#e6db74>&#39;ql_syscall_&#39;</span>))
</span></span><span style=display:flex><span>    name <span style=color:#f92672>=</span> y[<span style=color:#ae81ff>11</span>:]
</span></span></code></pre></div><p>The new handler can rely on the original <code>qiling</code> implementation, either to simply call it, or to adapt the system call arguments to TEEGris expectations.</p><h4 id=map-filesystem-names-to-custom-handlers>Map filesystem names to custom handlers</h4><p>While implementing <code>open</code>, we have observed TEEgris uses URIs as filenames. Those filesystem names will not be handled correctly during <code>qiling</code> emulation, as they cannot be mapped to the Linux host filesystem. Fortunately, <code>qiling</code> anticipates that need, and users can add custom I/O easily, through <code>QlFsMappedObject</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span>self<span style=color:#f92672>.</span>add_fs_mapper(<span style=color:#e6db74>&#39;sys://proc&#39;</span>, Fake_sys_proc())
</span></span></code></pre></div><p>A toy implementation is as simple as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Fake_sys_proc</span>(QlFsMappedObject):
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>read</span>(self, size):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\x01</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fstat</span>(self):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>close</span>(self):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>
</span></span></code></pre></div><p>This template is easily extensible as a stateful behavior, and is needed for some reasons. While <code>QlFsMappedObject</code> defines an ioctl method, we have opted to implement it in the system call handler. We need to write to the address given in the third parameter of the ioctl system call, which is not directly feasible using the <code>QlFsMappedObject</code> interface.</p><h3 id=triggering-the-vulnerability>Triggering the vulnerability</h3><p>Thanks to our emulator, <code>KEYMST</code> can be loaded. However, we do not have a request example capable of reaching the vulnerability location. To help us find a correct message, we have created a feedback loop: once in main processing loop, we map our input parameter and call to <code>TA_InvokeCommandEntryPoint</code>. <code>qiling</code> then generates a <code>drcov</code> coverage of the execution, with which we feed the IDA and lighthouse plugin. Rinse and repeat, and we have successfully crafted an input complying with the checks made and allowing us to control most of the input shared buffer. The input buffer shown below is 87856 bytes long, and the yellow bars indicate memory areas read while processing the normal world request:</p><img src=/posts/img/pivoting-to-the-secure-world/shared-mem-with-zoom.png alt="Input buffer constraints" style=background-color:#fff><p>The input buffer is largely unaccessed: we can freely use it to embed controlled information we will use later, during exploitation. The yellow zones, accessed and mostly checked are the PKCS8 RSA private key and a &ldquo;tags table&rdquo;.</p><h3 id=building-a-ropchain-to-pivot-to-a-subsequent-ropchain>Building a ropchain to pivot to a subsequent ropchain</h3><p>The stack overflow is nice, and the initial stack space we can overwrite is small. As we gain code execution in the secure world, we would also want to observe it from the inside, from the point of view of a trusted applet. It is important to test system calls behaviors, and verify assumptions we have made regarding non POSIX system calls.
As we fully control a large part of the input buffer, we build a first ropchain which will copy a second, larger, embedded ropchain, and pivot to it:</p><ol><li><strong>First</strong>, a bootstrap ropchain, which fits in <code>0x1f8</code> bytes:<ol><li>Save register content before losing their initial values. There is a suitable space in <code>KEYMST</code> <code>.bss</code></li><li>Allocate a new stack at a fixed address. Make the trusted applet do <code>mmap(0xdead000, 0x8000, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_ANONYMOUS)</code>. The chosen address is arbitrary but for robustness sake, we could have used the TEEGris specific system call that verifies memory range existence and permissions</li><li>Copy a large part of input shared memory to the newly allocated stack</li></ol></li><li><strong>Second</strong>, an embedded ropchain. We have arbitrarily chosen to split the buffer into <code>0x5e00</code> bytes of stack and <code>0x2000</code> bytes of data. As the trusted applet is <code>aarch32</code>, instruction set includes <code>load multiple</code> aka <code>ldm</code> instructions. We have selected <code>[KEYMST:thumb] 0x1975c: ldm.w r4, {r0, r1, r2, r3, r4, r5, r6, r7, r8, sb, fp, sp, lr, pc}</code>. This instruction is a T32 instruction that spreads over 4 bytes. We have observed <code>ROPgadget</code>, <code>ropper</code> and <code>xrop</code> do not output this gadget, even though it is legitimately classified as a Jump Oriented Programming gadget. The curious reader can read the details in Annex <a href=#t32-isa>T32 ISA</a>
The embedded payload is composed of three parts, again we have arbitrarily chosen the limit between data and stack zones:<ul><li><code>[0x100-0x200]</code>: new register values</li><li><code>[0x200-0x6000]</code>: <code>sp</code> is set to <code>0xdead000+0x200</code>, which will be top of the stack just after <code>ldm.w</code> executes</li><li><code>[0x6000-0x8000]</code>: data used by embedded payload
As we have mapped our input buffer to a fixed address, we can compute the address of our copied data in the target program, and easily reference input or output parameters we want to supply as reference to system calls.</li></ul></li><li><strong>Finally</strong>, as we have backed up the initial register values in step 1, we could restore processor context to a deeper call frame, to return in the <code>main</code> loop of <code>libteesl.so</code>, safely waiting for new messages to process.</li></ol><h3 id=interact-with-the-secure-kernel>Interact with the secure kernel</h3><p>We now have the ability to ROP into a trusted applet. This means we can perform secure system calls on behalf of it. We have explored the secure userspace environment, looking for ways to gain arbitrary code execution:</p><ul><li><strong>open a file for writing, save arbitrary code, open it for reading, map it as RX</strong>: it does not work, because files cannot be opened with write access mode. It is possible to map existing files as RX though, even at a fixed address. We can enrich our accessible gadgets set that way, for example by loading <code>libteesock.so</code> which contains indirect branches of all kinds</li><li><strong>map anonymous memory as RW, remap it as RX</strong>: there is no system call to perform the equivalent of <code>mprotect</code>. We have tried to use <code>mmap</code> to do the same, but none of our attempts worked</li><li><strong>create a socketpair, and map the content as RX</strong>: we have identified the only supported socket type, domain, and family. Reversing the secure kernel shows that this type of file descriptor supports <code>mmap</code> system call. But the mapping failed while asking for <code>PROT_EXEC</code></li><li><strong>use <code>TEES_ExecuteCustomHandler</code> and <code>TEES_RegisterCustomHandler</code> system calls</strong>: though their names look interesting, executing them in the context of <code>KEYMST</code> fails, and the system call returns <code>-1</code>, <code>EPERM</code>
The trusted drivers we have seen in <code>startup.tzar</code> are not directly reachable from normal world. Thanks to this vulnerability, we can make <code>KEYMST</code> communicate to the trusted drivers, and explore the drivers features.</li></ul><h3 id=impacted-versions>Impacted versions</h3><p>Samsung has confirmed the vulnerability affects <code>KEYMST</code>, that only exists in Android P firmwares. More recent versions are not affected by this vulnerability.</p><h2 id=expanding-control-over-trusted-driver>Expanding control over trusted driver</h2><h3 id=motivation-gain-code-execution-in-secure-kernel>Motivation: gain code execution in secure kernel</h3><p>Intuitively, we expect a trusted driver to have more privileges than a trusted applet. Let&rsquo;s start with analyzing the driver contained in the startup archive.
The static analysis of <code>driver/00000000-0000-0000-0000-00535453540b</code> in <code>startup.tzar</code> reveals it calls an awkward system call <code>TEES_ExecuteCustomHandler</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>timautil_sram_recovery_read</span>(<span style=color:#66d9ef>int</span> a1)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> result; <span style=color:#75715e>// r0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> v2; <span style=color:#75715e>// r2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> v4[<span style=color:#ae81ff>3</span>]; <span style=color:#75715e>// [sp+8h] [bp-24h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> v5[<span style=color:#ae81ff>4</span>]; <span style=color:#75715e>// [sp+14h] [bp-18h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> v6; <span style=color:#75715e>// [sp+24h] [bp-8h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  v6 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>TEE_MemFill</span>(v4, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>28</span>);
</span></span><span style=display:flex><span>  v4[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>130</span>;
</span></span><span style=display:flex><span>  v4[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>  v4[<span style=color:#ae81ff>2</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;@echeck: result: %d, cmd_ret0: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, v6, v5[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>  v6 <span style=color:#f92672>=</span> <span style=color:#a6e22e>TEES_ExecuteCustomHandler</span>(<span style=color:#ae81ff>0xB2000202</span>, v4);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;##echeck: result: %d, cmd_ret0: %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, v6, v5[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>  result <span style=color:#f92672>=</span> <span style=color:#a6e22e>TEE_MemMove</span>(<span style=color:#f92672>*</span>(_DWORD <span style=color:#f92672>*</span>)(a1 <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span>), v5, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( v6 )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Execute Custom handler failed to get mode : retval %d (%08x)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, v6, v2);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The name looks promising, there even exists a system call named <code>TEES_RegisterCustomHandler</code> which we could leverage to perform some sort of install of a new handler. But first, let&rsquo;s analyze the booting image <code>sboot.img</code>. It contains the image of the secure OS, TEEGris, which will be loaded and run at boot. Annex <a href=#sboot-img>Secure reconnaissance</a> describes how to extract OS from it and perform static analysis of system call implementation.
We see that a verification is carried out on the caller process:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>__int64</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>sel1_syscall_TEES_ExecuteCustomHandler</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> a1, <span style=color:#66d9ef>__int64</span> a2)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  _BYTE v5[<span style=color:#ae81ff>56</span>]; <span style=color:#75715e>// [xsp+28h] [xbp+28h] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span><span style=color:#a6e22e>sub_FFFFFFFFF01059C4</span>(<span style=color:#ae81ff>0x12u</span>, <span style=color:#ae81ff>1</span>i64) ) <span style=color:#75715e>// looks like a verification
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>i64;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>)<span style=color:#a6e22e>j_sel1_do_copy_from_userspace</span>((<span style=color:#66d9ef>__int64</span>)v5, a2, <span style=color:#ae81ff>56</span>i64) )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>14</span>i64;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>sel1_perform_smc</span>(a1, v5, <span style=color:#ae81ff>0x40000000</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>)<span style=color:#a6e22e>j_sel1_do_copy_to_userspace</span>(a2, (<span style=color:#66d9ef>__int64</span>)v5, <span style=color:#ae81ff>56</span>i64) )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>14</span>i64;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This verification is the same as the verification performed when calling <code>TEES_RegisterCustomHandler</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>__int64</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>sel1_syscall_TEES_RegisterCustomHandler</span>(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int16</span> a1, <span style=color:#66d9ef>__int64</span> a2, <span style=color:#66d9ef>__int64</span> a3, <span style=color:#66d9ef>int</span> a4)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  BOOL v8; <span style=color:#75715e>// w0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>__int64</span> v9; <span style=color:#75715e>// x1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> v11; <span style=color:#75715e>// w24
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>__int64</span> v12; <span style=color:#75715e>// x0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span> v13; <span style=color:#75715e>// x23
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>__int64</span> v14; <span style=color:#75715e>// x0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  _QWORD <span style=color:#f92672>*</span>v15; <span style=color:#75715e>// x25
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> v16; <span style=color:#75715e>// w19
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> v18; <span style=color:#75715e>// [xsp+5Ch] [xbp+5Ch] BYREF
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  v8 <span style=color:#f92672>=</span> <span style=color:#a6e22e>sub_FFFFFFFFF01059C4</span>(<span style=color:#ae81ff>0x12u</span>, <span style=color:#ae81ff>1</span>i64); <span style=color:#75715e>// the very same verification
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  v9 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>i64;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( v8 )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    v9 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>22</span>i64;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span>)(a3 <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0x3FFFF</span> <span style=color:#f92672>&amp;&amp;</span> a2 <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      v11 <span style=color:#f92672>=</span> <span style=color:#a6e22e>sub_FFFFFFFFF012413C</span>(
</span></span><span style=display:flex><span>              <span style=color:#f92672>*</span>(_QWORD <span style=color:#f92672>*</span>)(((<span style=color:#a6e22e>_ReadStatusReg</span>(<span style=color:#a6e22e>ARM64_SYSREG</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>4</span>)) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFFFFFFFFFFE000u</span>i64) <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x68</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>468</span>i64,
</span></span><span style=display:flex><span>              <span style=color:#ae81ff>16</span>i64);
</span></span><span style=display:flex><span>      v18 <span style=color:#f92672>=</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span>)(a3 <span style=color:#f92672>+</span> <span style=color:#ae81ff>4095</span>) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>12</span>; <span style=color:#75715e>// round to page size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      v12 <span style=color:#f92672>=</span> <span style=color:#a6e22e>sub_FFFFFFFFF010EC00</span>(<span style=color:#f92672>&amp;</span>v18, <span style=color:#ae81ff>0</span>i64, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>      v13 <span style=color:#f92672>=</span> v12;
</span></span><span style=display:flex><span>      v9 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>12</span>i64;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> ( v12 )
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        v14 <span style=color:#f92672>=</span> <span style=color:#a6e22e>sub_FFFFFFFFF010EA34</span>(v12);
</span></span><span style=display:flex><span>        v15 <span style=color:#f92672>=</span> (_QWORD <span style=color:#f92672>*</span>)v14;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>v14 <span style=color:#f92672>||</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span>)<span style=color:#a6e22e>j_sel1_do_copy_from_userspace</span>(v14, a2, a3) ) <span style=color:#75715e>// copy from userspace
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        {
</span></span><span style=display:flex><span>          v16 <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>14</span>;
</span></span><span style=display:flex><span>LABEL_11:
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>sub_FFFFFFFFF010ED0C</span>(v13, v18);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>return</span> v16;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        v16 <span style=color:#f92672>=</span> <span style=color:#a6e22e>sub_FFFFFFFFF01194D4</span>(a1, v11, v15, v18, a4);
</span></span><span style=display:flex><span>        v9 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>i64;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ( v16 )
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>goto</span> LABEL_11;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> v9;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It means that if a process is allowed to call <code>TEES_ExecuteCustomHandler</code>, it may also be authorized to call <code>TEES_RegisterCustomHandler</code>. The function which performs verification is <code>sub_FFFFFFFFF01059C4</code>. The target only has one active driver. This driver looks promising, at it uses a system call that requires the same privilege level as the system call which registers a handler inside the secure kernel. We will call the driver <code>STST</code> for the rest of the article, based on the UUID naming scheme shown earlier. The driver binary has the same type as <code>KEYMST</code> binary. In particular, it is also a trusted applet, with exported TEE functions.</p><h3 id=examining-driver-entry-points>Examining driver entry points</h3><p>Driver shares the hardening features of <code>STST</code>:</p><pre style=background-color:#272822;white-space:pre-wrap;word-wrap:break-word>
$ <font color=#66d9ef>pwn</font> checksec STST
[*] 'STST'
    Arch:     arm-32-little
    RELRO:    <font color=#f92672>No RELRO</font>
    Stack:    <font color=#f92672>No canary found</font>
    NX:       <font color=#a6e22e>NX enabled</font>
    PIE:      <font color=#f92672>No PIE (0x10000)</font>
</pre><p>The driver registers itself with <code>TEES_RegisterDriver</code>, called when the driver is loaded:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> driver {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>open_f)();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> (<span style=color:#f92672>*</span>ioctl_f)();
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> driver drv;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>TA_CreateEntryPoint</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> v2; <span style=color:#75715e>// [sp+4h] [bp-8h]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  drv.open_f <span style=color:#f92672>=</span> drv_open;
</span></span><span style=display:flex><span>  drv.ioctl_f <span style=color:#f92672>=</span> drv_ioctl;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>  v2 <span style=color:#f92672>=</span> <span style=color:#a6e22e>TEES_RegisterDriver</span>(<span style=color:#f92672>&amp;</span>drv);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( v2 )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;register_driver failed, ret = %d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, v2);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>65536</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;TIMA Driver registered</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The driver registers an <code>ioctl</code> callback, which may be called from the vulnerable <code>KEYMST</code> applet. A few ioctl commands can be performed on this driver, among which two eventually call <code>log_msg</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>log_msg</span>(<span style=color:#66d9ef>int</span> a1, <span style=color:#66d9ef>int</span> a2, <span style=color:#66d9ef>int</span> a3, <span style=color:#66d9ef>int</span> a4, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>format)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>TEE_MemFill</span>(<span style=color:#f92672>&amp;</span>g_entry_ptr, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0x80u</span>);
</span></span><span style=display:flex><span>  byte_23118 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  byte_23119 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  byte_2311A <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  byte_2311B <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  g_entry_ptr <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>;
</span></span><span style=display:flex><span>  byte_23115 <span style=color:#f92672>=</span> <span style=color:#ae81ff>39</span>;
</span></span><span style=display:flex><span>  byte_23116 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  byte_23117 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>snprintf</span>(s, <span style=color:#ae81ff>0x77u</span>, <span style=color:#e6db74>&#34;%s&#34;</span>, format);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>log_add_entry</span>(a1, a2, a3, a4, <span style=color:#f92672>&amp;</span>g_entry_ptr);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>printf</span>(format); <span style=color:#75715e>/* format string controlled by compromised trusted applet */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The format argument comes from the <code>ioctl</code> argument, but is not located on the stack, meaning that we cannot directly control <code>printf</code> arguments with our input buffer. In the next part, we devise a strategy to gain arbitrary read and write.</p><h3 id=gaining-arbitrary-read-and-write>Gaining arbitrary read and write</h3><p>The vulnerability can be used several times in a row, as the driver process does not exit between calls. We have chosen to alter the stack in a part deep enough to not be reused in between two <code>ioctl</code> calls.
We have identified a chain of three stack words that point to each other:</p><img src=/posts/img/pivoting-to-the-secure-world/stack-stack-layout.svg alt="Chain of three stack words"><p>In the diagram above, the value <code>K</code> will not be altered by the program between multiple ioctl calls, giving us the ability to fully control its value.
To put an arbitrary address <code>a</code> instead of <code>K</code> above, we write it byte by byte, overwriting the low byte of <code>J</code> each time with an incrementing value:</p><img src=/posts/img/pivoting-to-the-secure-world/stack-overwrite-J-cell.svg alt="Overwrite LSB of J"><p>Once we are able to put an arbitrary address on the stack, we can simply turn <code>printf</code> to our advantage using <code>%pU</code> or <code>%n</code> variants.</p><img src=/posts/img/pivoting-to-the-secure-world/stack-control-K-value.svg alt="Control over K value"><p>Since the driver is not <code>PIE</code>, the <code>.got</code> section is at a fixed location in memory. Leaking two words of <code>.got</code>, we leak the randomized addresses of <code>libteesl.so</code> and <code>libtzsl.so</code>. A question remains: how to turn a sequence of well-balanced writes to code execution?</p><h3 id=gaining-arbitrary-code-execution>Gaining arbitrary code execution</h3><p>Using dynamic memory hooks like <code>__malloc_hook</code> is not an option here, as <code>libtzsl.so</code> heap implementation does not have a hooking mechanism. Overwriting a return address in the stack is still possible, but we have chosen to leverage a specific feature called <code>custom printf format specifiers</code>, which <code>glibc</code> implements. Luckily for us <code>libtzsl.so</code> also implements this juicy feature. In essence, it gives an application a way to dynamically register new format specifiers, by mapping a custom format, like <code>%W</code> to a user-specified function that will output the argument. The following function illustrates how a new custom specifier registers a callback:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#66d9ef>__fastcall</span> <span style=color:#a6e22e>register_printf_format</span>(<span style=color:#66d9ef>char</span> a1, <span style=color:#66d9ef>int</span> a2)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> i; <span style=color:#75715e>// r2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>v3; <span style=color:#75715e>// lr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>int</span> result; <span style=color:#75715e>// r0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>for</span> ( i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>!=</span> <span style=color:#ae81ff>10</span>; <span style=color:#f92672>++</span>i )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    v3 <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>custom_formats_tab[<span style=color:#ae81ff>8</span> <span style=color:#f92672>*</span> i];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!*</span>((_DWORD <span style=color:#f92672>*</span>)v3 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) )
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      custom_formats_tab[<span style=color:#ae81ff>8</span> <span style=color:#f92672>*</span> i] <span style=color:#f92672>=</span> a1;
</span></span><span style=display:flex><span>      result <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#f92672>*</span>((_DWORD <span style=color:#f92672>*</span>)v3 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>=</span> a2;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This newly registered format specifier may then be used with <code>printf</code>. Backend <code>printf</code> implementation is complex and large, but the interesting part is the following fragment, that loops through custom format specifiers:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>...
</span></span><span style=display:flex><span>LABEL_138:
</span></span><span style=display:flex><span>  v44 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> ( (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int8</span>)custom_formats_tab[<span style=color:#ae81ff>8</span> <span style=color:#f92672>*</span> v44] <span style=color:#f92672>!=</span> current_fmtspec )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>++</span>v44 <span style=color:#f92672>==</span> <span style=color:#ae81ff>10</span> )
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>goto</span> LABEL_141;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  result <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>(<span style=color:#66d9ef>int</span> (<span style=color:#66d9ef>__fastcall</span> <span style=color:#f92672>**</span>)(<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>))<span style=color:#f92672>&amp;</span>custom_formats_tab[<span style=color:#ae81ff>8</span> <span style=color:#f92672>*</span> v44 <span style=color:#f92672>+</span> <span style=color:#ae81ff>4</span>])(<span style=color:#f92672>&amp;</span>current_pos);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( result <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> )
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>LABEL_141:
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>output_char</span>((<span style=color:#66d9ef>int</span>)<span style=color:#f92672>&amp;</span>current_pos);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>*</span>cur_fmt )
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>goto</span> LABEL_146;
</span></span><span style=display:flex><span>    <span style=color:#f92672>--</span>cur_fmt;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>goto</span> LABEL_174;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ( result <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span> )
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>goto</span> LABEL_174;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Upon custom function call, <code>r12</code> points to the <code>vasprintf</code> pointer in <code>libtzsl.so</code> <code>.got</code>:</p><pre style=background-color:#272822;white-space:pre-wrap;word-wrap:break-word>
.got:0001F85C vsscanf_s_ptr   DCD vsscanf_s           ; DATA XREF: j_vsscanf_s+8↑r
.got:0001F860 vasprintf_ptr   DCD vasprintf           ; DATA XREF: j_vasprintf+8↑r
.got:0001F864 recvmsg_ptr     DCD recvmsg             ; DATA XREF: j_recvmsg+8↑r
.got:0001F868 mq_open_ptr     DCD mq_open             ; DATA XREF: j_mq_open+8↑r
.got:0001F86C __iwshmem_mmap_ptr DCD __iwshmem_mmap   ; DATA XREF: j___iwshmem_mmap+8↑r
.got:0001F870 close_ptr       DCD close               ; DATA XREF: j_close+8↑r
.got:0001F874 raise_ptr       DCD raise               ; DATA XREF: j_raise+8↑r
.got:0001F878 free_ptr        DCD free                ; DATA XREF: j_free+8↑r
.got:0001F87C dword_1F87C     DCD 0                   ; DATA XREF: get_errno_addr↑o
.got:0001F87C                                         ; get_errno_addr+C↑o ...
.got:0001F87C                                         ; TLS-reference
.got:0001F880                 DCD 0
.got:0001F884 abort_handler_s_ptr DCD abort_handler_s ; DATA XREF: set_constraint_handler_s+24↑o
.got:0001F884                                         ; set_constraint_handler_s+28↑r ...
.got:0001F888 extra_mmap_flags_ptr DCD extra_mmap_flags
.got:0001F888                                         ; DATA XREF: sub_3BBC+8↑o
.got:0001F888                                         ; sub_3BBC+24↑r ...
.got:0001F888 ; .got          ends
.got:0001F888
.data:0001F88C ; ===========================================================================
.data:0001F88C
.data:0001F88C ; Segment type: Pure data
.data:0001F88C                 AREA .data, DATA
.data:0001F88C                 ; ORG 0x1F88C
.data:0001F88C off_1F88C       DCD abort_handler_s     ; DATA XREF: set_constraint_handler_s↑o
.data:0001F88C                                         ; set_constraint_handler_s+10↑o ...
.data:0001F890 aUnknown        DCB "UNKNOWN",0         ; DATA XREF: set_log_component+8↑o
.data:0001F890                                         ; set_log_component+14↑o ...
.data:0001F898                 DCB    0
</pre><p>One may ask where does this value comes from. The reason is:</p><ol><li><code>printf</code> internally uses <code>vasprintf;</code></li><li>Both functions are in <code>libtzsl.so</code>, hence have no reason to perform the branch via <code>.plt</code>;</li><li>But for a few reasons, we must branch through <code>.plt</code>. Those reasons include the fact that the branch would not be a valid ARM instruction;</li><li>The veener can be found in <code>.plt</code>, and it uses <code>ip</code>, aka <code>r12</code>, to perform the branch;</li><li>This value is left untouched in <code>ip</code>, as it is only used to branch some internal functions.
Since the <code>.got</code> section is overwritable we conclude driver exploitation with a call to <code>[libteesl.so:thumb] 0x48f9a: ldm.w ip, {r0, r1, r3, r4, r5, r6, r8, sb, fp, ip, sp, pc}</code>. This instruction allows us to perform a stack pivot and jump into a ropchain. Due to the constraints we have on <code>.got</code>, we cannot directly control juicy registers at first shot. For example, changing <code>recvmsg</code> will make the driver malfunction, as this function is used to receive ioctl calls. But we can take control of <code>sp</code> and <code>pc</code>, without causing a crash:<pre style=background-color:#272822;white-space:pre-wrap;word-wrap:break-word>
.got:0001F85C vsscanf_s_ptr   DCD vsscanf_s           ; DATA XREF: j_vsscanf_s+8↑r
.got:0001F860 vasprintf_ptr   DCD vasprintf           ; DATA XREF: j_vasprintf+8↑r <font color=#66d9ef><b><= ip</b></font>
<font color=#f92672>.got:0001F864 recvmsg_ptr     DCD recvmsg             ; <b>DO NOT TOUCH THIS</b></font>
<font color=#f92672>.got:0001F868 mq_open_ptr     DCD mq_open             ; DATA XREF: j_mq_open+8↑r</font>
<font color=#f92672>.got:0001F86C __iwshmem_mmap_ptr DCD __iwshmem_mmap   ; DATA XREF: j___iwshmem_mmap+8↑r</font>
<font color=#f92672>.got:0001F870 close_ptr       DCD close               ; DATA XREF: j_close+8↑r</font>
<font color=#f92672>.got:0001F874 raise_ptr       DCD raise               ; DATA XREF: j_raise+8↑r</font>
<font color=#f92672>.got:0001F878 free_ptr        DCD free                ; DATA XREF: j_free+8↑r</font>
<font color=#f92672>.got:0001F87C dword_1F87C     DCD 0                   ; DATA XREF: get_errno_addr↑o</font>
<font color=#f92672>.got:0001F87C                                         ; get_errno_addr+C↑o ...</font>
<font color=#f92672>.got:0001F880                 DCD 0</font>
<font color=#f92672>.got:0001F884 abort_handler_s_ptr DCD abort_handler_s ; DATA XREF: set_constraint_handler_s+24↑o
.got:0001F884                                         ; set_constraint_handler_s+28↑r ...</font>
<font color=#66d9ef>.got:0001F888         controlled sp                   ; <b>SAFE TO CHANGE</b></font>
<font color=#66d9ef>.data:0001F88C        controlled pc                   ; <b>SAFE TO CHANGE</b></font>
.data:0001F88C                                        ; set_constraint_handler_s+10↑o ...
.data:0001F890 aUnknown        DCB "UNKNOWN",0        ; DATA XREF: set_log_component+8↑o
.data:0001F890                                        ; set_log_component+14↑o ...
.data:0001F898                 DCB    0
</pre></li></ol><p>Luckily for us, <code>libteesl.so</code> and <code>libtzsl.so</code> have lots of gadgets we can use, and we have already leaked their base addresses.</p><h3 id=impacted-versions-1>Impacted versions</h3><p>Samsung has confirmed the vulnerability affects <code>STST</code>. This privileged trusted applet ships with Android versions spanning from Android P to Android R. Please note that Android S and more recent are not affected by this vulnerability.</p><h2 id=conclusion>Conclusion</h2><p>We hope you have enjoyed this trip to one of the Samsung variant of ARM secure world. Software is an inextinguishable source of vulnerabilities. ARM TrustZone is a nice feature, but it provides a segregation which is only as strong as the software components that run inside it. In our case, we have chained two vulnerabilities to potentially gain code execution in the context of the secure OS. Those two applets would have benefited from basic hardening measures such as stack cookie, PIE and RELRO.
We hope to see you again for one of our next trips!</p><h2 id=ressources>Ressources</h2><h3 id=articles-about-teegris>Articles about TEEgris</h3><ul><li><a name=tarasikov></a><a href=http://allsoftwaresucks.blogspot.com/2019/05/reverse-engineering-samsung-exynos-9820.html>Reverse-engineering Samsung S10 TEEGRIS TrustZone OS</a></li><li><a name=menaniri></a><a href=https://www.riscure.com/blog/samsung-investigation-part1>Breaking TEE Security Part 1: TEEs, TrustZone and TEEGRIS</a>, <a href=https://www.riscure.com/blog/samsung-investigation-part2>Breaking TEE Security Part 2: Exploiting Trusted Applications (TAs)</a>, and <a href=https://www.riscure.com/blog/samsung-investigation-part3>Breaking TEE Security Part 3: Escalating Privileges</a></li><li><a name=tzar></a><a href=https://gist.github.com/astarasikov/f47cb7f46b5193872f376fa0ea842e4b#file-unpack_startup_tzar.py>tzar unpack script</a></li></ul><h3 id=arm-system-architecture>ARM system architecture</h3><ul><li><a name=baremetal></a><a href=https://developer.arm.com/documentation/dai0527/a>Bare-metal Boot Code for ARMv8-A Processors</a></li></ul><h2 id=t32-isa>T32 ISA</h2><a name=t32-isa></a><p>Modern ARM processors support several instruction sets. Sticking to the most meaningful for us:</p><ul><li>ARM instructions which are 4-bytes instructions;</li><li>Thumb instructions which are 2-bytes instructions, and thus provide higher code density. However, the ISA is not as rich than the ARM one.
Starting with ARMv7, ARM decided to extend Thumb ISA with Thumb2 instructions, which are 4-bytes instructions, to benefit from more compact machine code. Those instructions might look like legal ARM instructions, but they start at an address which is not a multiple of 4. Not all ARM instructions are supported, only a few selected ones are supported when in Thumb mode. Multiple load, or <code>ldm</code>, is one of those.
While Thumb does have <code>ldm</code> instructions, they do not allow to set <code>pc</code>, as the operand scope is too limited. Thumb2 holds powerful ARM variants, including the ability to set <code>pc</code>. Do note that in the latest version of the ARMv8 ISA, using <code>ldm</code> to set <code>sp</code> causes an unpredictable behaviour. Yet, we did try on our target device, and it just worked: the stack pivoted correctly.
So when looking for gadgets in ARM code sections, it is useful to search for Thumb2 instruction. The following sample may help to spot the origin of the problem:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm><span style=display:flex><span><span style=color:#a6e22e>.section</span> <span style=color:#66d9ef>.text</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.global</span> <span style=color:#66d9ef>_start</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.arm</span>
</span></span><span style=display:flex><span>_start:
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>mov</span> <span style=color:#66d9ef>r0</span>, <span style=color:#66d9ef>r0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>adr</span> <span style=color:#66d9ef>r0</span>, <span style=color:#66d9ef>gadget</span><span style=color:#960050;background-color:#1e0010>+</span><span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bx</span> <span style=color:#66d9ef>r0</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>.byte</span> <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.thumb</span>
</span></span><span style=display:flex><span>gadget:
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>.byte</span> <span style=color:#ae81ff>0xe8</span>, <span style=color:#ae81ff>0x94</span>, <span style=color:#ae81ff>0xeb</span>, <span style=color:#ae81ff>0xff</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>.byte</span> <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0xeb</span>, <span style=color:#ae81ff>0x94</span>, <span style=color:#ae81ff>0xe8</span>
</span></span></code></pre></div><p>Existing ROP tools - we have tested with <code>ROPgadget</code>, <code>xrop </code>and <code>ropper</code> - might miss it. This is mainly due to the way those tools work: they spot an interesting ending instruction, and then perform disassembly at a few backward places, trying to find a non-branching flow ending there. Looking at the tools one by one:</p><ul><li><code>ROPgadget</code> detects multiple load as a possible ending. But it is only detected when it starts with an address multiple of 4. As we have seen, Thumb2 allows such a gadget on an address multiple of 2, but not 4. If we specify <code>--align 2</code> option, then the gadget will be falsely detected as ARM - recall that Thumb2 is mainly ARM instructions. The instruction flow in which the instruction lives is Thumb however.</li><li><code>ropper</code> does not detect multiple load as possible ending;</li><li><code>xrop</code> detects multiple load as a possible ending. The disassembly engine, based on bfd libopcodes, supports Thumb and Thumb2 decoding. However, it fails to detect the gadget in our test binary.
When applied to the sample above, the tools yield:<pre style=white-space:pre-wrap;word-wrap:break-word>
 &gt; <font color=#cc0000><b># The gadget will not be detected</b></font>
 &gt; ./ROPgadget.py --binary ../samples/ldm
Gadgets information
============================================================
0x00010058 : add r0, pc, #3 ; bx r0
0x00010044 : andeq r0, r0, ip, rrx ; andeq r0, r0, ip, rrx ; andeq r0, r0, r5 ; ...
0x00010048 : andeq r0, r0, ip, rrx ; andeq r0, r0, r5 ; andeq r0, r1, r0 ; ...
0x00010038 : andeq r0, r0, r0 ; andeq r0, r1, r0 ; andeq r0, r1, r0 ; ...
0x0001004c : andeq r0, r0, r5 ; andeq r0, r1, r0 ; mov r0, r0 ; add r0, pc, #3 ; bx r0
0x00010040 : andeq r0, r1, r0 ; andeq r0, r0, ip, rrx ; andeq r0, r0, ip, rrx ; ...
0x0001003c : andeq r0, r1, r0 ; andeq r0, r1, r0 ; andeq r0, r0, ip, rrx ; ...
0x00010050 : andeq r0, r1, r0 ; mov r0, r0 ; add r0, pc, #3 ; bx r0
0x0001005c : bx r0
0x00010054 : mov r0, r0 ; add r0, pc, #3 ; bx r0
Unique gadgets found: 10
 &gt; <font color=#4E9A06><b># The gadget will be detected as we force the alignment to Thumb alignment</b></font>
 &gt; ./ROPgadget.py --binary ../samples/ldm --align 2
Gadgets information
============================================================
0x00010058 : add r0, pc, #3 ; bx r0
0x0001004c : andeq r0, r0, r5 ; andeq r0, r1, r0 ; mov r0, r0 ; add r0, pc, #3 ; bx r0
0x00010050 : andeq r0, r1, r0 ; mov r0, r0 ; add r0, pc, #3 ; bx r0
0x0001005c : bx r0
0x00010066 : ldm r4, {r0, r1, r2, r3, r4, r5, r6, r7, r8, sb, fp, sp, lr, pc}
0x00010054 : mov r0, r0 ; add r0, pc, #3 ; bx r0
Unique gadgets found: 6
 &gt; <font color=#cc0000><b># The gadget will not be detected</b></font>
 &gt; Ropper.py -a ARMTHUMB -f ./ldm
<font color=#4E9A06>[INFO]</font> Load gadgets from cache
<font color=#4E9A06>[LOAD]</font> loading... <font color=#D3D7CF>100%</font>
Gadgets
=======
0 gadgets found
 &gt; <font color=#cc0000><b># The gadget will not be detected</b></font>
 &gt; Ropper.py -a ARM -f ./ldm
<font color=#4E9A06>[INFO]</font> Load gadgets from cache
<font color=#4E9A06>[LOAD]</font> loading... <font color=#D3D7CF>100%</font>
<font color=#4E9A06>[LOAD]</font> removing double gadgets... <font color=#D3D7CF>100%</font>
Gadgets
=======
<font color=#CC0000>0x00010058</font>: <font color=#FCE94F><b>add</b></font> <font color=#D3D7CF>r0, pc, #3</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>bx</b></font> <font color=#D3D7CF>r0</font><font color=#729FCF><b>; </b></font>
<font color=#CC0000>0x00010048</font>: <font color=#FCE94F><b>andeq</b></font> <font color=#D3D7CF>r0, r0, ip, rrx</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>andeq</b></font> <font color=#D3D7CF>r0, r0, r5</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>andeq</b></font> <font color=#D3D7CF>r0, r1, r0</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>mov</b></font> <font color=#D3D7CF>r0, r0</font><font color=#729FCF><b>;</b></font> ...
<font color=#CC0000>0x0001004c</font>: <font color=#FCE94F><b>andeq</b></font> <font color=#D3D7CF>r0, r0, r5</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>andeq</b></font> <font color=#D3D7CF>r0, r1, r0</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>mov</b></font> <font color=#D3D7CF>r0, r0</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>add</b></font> <font color=#D3D7CF>r0, pc, #3</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>bx</b></font> <font color=#D3D7CF>r0</font><font color=#729FCF><b>; </b></font>
<font color=#CC0000>0x00010050</font>: <font color=#FCE94F><b>andeq</b></font> <font color=#D3D7CF>r0, r1, r0</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>mov</b></font> <font color=#D3D7CF>r0, r0</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>add</b></font> <font color=#D3D7CF>r0, pc, #3</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>bx</b></font> <font color=#D3D7CF>r0</font><font color=#729FCF><b>; </b></font>
<font color=#CC0000>0x0001005c</font>: <font color=#FCE94F><b>bx</b></font> <font color=#D3D7CF>r0</font><font color=#729FCF><b>; </b></font>
<font color=#CC0000>0x00010054</font>: <font color=#FCE94F><b>mov</b></font> <font color=#D3D7CF>r0, r0</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>add</b></font> <font color=#D3D7CF>r0, pc, #3</font><font color=#729FCF><b>; </b></font><font color=#FCE94F><b>bx</b></font> <font color=#D3D7CF>r0</font><font color=#729FCF><b>; </b></font>
6 gadgets found
 &gt; <font color=#cc0000><b># The gadget will not be detected</b></font>
 &gt; xrop -b 16 -r arm ./ldm
<font color=#729FCF><b>&gt; 0x50                </b></font><font color=#576364>0000                      movs	r0, r0</font>
<font color=#3465A4>0x54                  </font><font color=#576364>0000                      movs	r0, r0</font>
<font color=#3465A4>0x58                  </font><font color=#576364>0003                      movs	r3, r0</font>
<font color=#3465A4>0x5c                  </font><font color=#576364>E12FFF10                  </font><font color=#CC0000>vrhadd.u16</font>	<font color=#CC0000>d14, d0, d31</font>
_______________________________________________________________
 &gt; <font color=#cc0000><b># The gadget will not be detected</b></font>
 &gt; xrop -b 32 -r arm ./ldm
<font color=#729FCF><b>&gt; 0x50                </b></font><font color=#576364>00010000                  andeq	r0, r1, r0</font>
<font color=#3465A4>0x54                  </font><font color=#576364>E1A00000                  nop			; (mov r0, r0)</font>
<font color=#3465A4>0x58                  </font><font color=#576364>E28F0003                  add	r0, pc, #3</font>
<font color=#3465A4>0x5c                  </font><font color=#576364>E12FFF10                  </font><font color=#CC0000>bx</font>	<font color=#CC0000>r0</font>
_______________________________________________________________
</pre></li></ul><h2 id=secure-reconnaissance>Secure reconnaissance</h2><a name=sboot-img></a><img src=/posts/img/pivoting-to-the-secure-world/teegris-Secure-boot.svg alt="Samsung Secure boot"><p>The firmware zip file contains multiple tar archives, among which the <code>BL_</code> prefixed one contains <code>sboot.bin</code> which is the file used by <code>BootROM</code> to start the Secure World: it will contain TEEgris secure kernel. It can be encrypted, but it was not for our particular target.
<code>sboot.bin</code> is a flat file, and a few aarch64 system architecture facts help to analyze it:</p><ul><li>ARM <a href=#baremetal>bare metal boot</a>: the use of ARM64 system registers to set up a system with multiple exception levels;</li><li>the structure of the ARM64 exception vector table is singular and allows to be identified in a flat binary: aligned with <code>0x800</code>, each vector is <code>0x80</code> bytes long. <code>NOP</code> padding is used to fulfill the alignment constraint. Some entries are infinite loops that jump to self;</li><li>a well-identified exception vector serves supervisor calls made by inferior exception levels. This vector shall reach the dispatch logic that will call a specific function associated with the supervisor call identifier. The two possible interrupt vectors are <code>synchronous lower el using aarch64</code>, at <code>+0x400</code> and <code>synchronous lower el using aarch32</code> at <code>+0x600</code>.
The secure kernel can be extracted from the firmware, and the system calls implementation analyzed.</li></ul></div><footer class=post-footer><div class=post-footer-data><div class=tags><div class=tag><a href=/tags/android>#Android</a></div><div class=tag><a href=/tags/exploit>#Exploit</a></div><div class=tag><a href=/tags/vulnerability-research>#Vulnerability Research</a></div></div><span class=date>2023-03-24
<span class=author>by
<a href=https://twitter.com/thalium_team>Anonymous</a></span></span></div></footer></article><footer><div class=social-links-footer><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>GitHub</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div><div class=copyright>Copyright (c) 2020, all rights reserved.</div><div class=poweredby>Powered by <a href=https://gohugo.io/>Hugo</a>.</div></footer></div></body></html>