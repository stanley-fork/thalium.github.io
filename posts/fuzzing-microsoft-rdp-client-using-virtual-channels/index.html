<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=author content="Thalium Team"><meta name=description content="Thalium blog."><meta name=keywords content="blog,tech"><meta name=viewport content="width=device-width,minimum-scale=1,initial-scale=1"><meta name=generator content="Hugo 0.120.4"><link rel=canonical href=/posts/fuzzing-microsoft-rdp-client-using-virtual-channels/><meta property="og:title" content="Fuzzing Microsoft's RDP Client using Virtual Channels: Overview & Methodology"><meta property="og:description" content="This article begins my three-part series on fuzzing Microsoft&rsquo;s RDP client. In this first installment, I set up a methodology for fuzzing Virtual Channels using WinAFL and share some of my findings."><meta property="og:type" content="article"><meta property="og:url" content="/posts/fuzzing-microsoft-rdp-client-using-virtual-channels/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-10T12:00:00+00:00"><meta property="article:modified_time" content="2021-11-10T12:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Fuzzing Microsoft's RDP Client using Virtual Channels: Overview & Methodology"><meta name=twitter:description content="This article begins my three-part series on fuzzing Microsoft&rsquo;s RDP client. In this first installment, I set up a methodology for fuzzing Virtual Channels using WinAFL and share some of my findings."><meta itemprop=name content="Fuzzing Microsoft's RDP Client using Virtual Channels: Overview & Methodology"><meta itemprop=description content="This article begins my three-part series on fuzzing Microsoft&rsquo;s RDP client. In this first installment, I set up a methodology for fuzzing Virtual Channels using WinAFL and share some of my findings."><meta itemprop=datePublished content="2021-11-10T12:00:00+00:00"><meta itemprop=dateModified content="2021-11-10T12:00:00+00:00"><meta itemprop=wordCount content="8535"><meta itemprop=keywords content="RDP,Fuzzing,WinAFL,Vulnerability Research,CVE,"><link rel=stylesheet href=/css/layout.css><link rel=stylesheet href=/css/default-dark.css><link rel=icon href=/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-141692648-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><title>Fuzzing Microsoft's RDP Client using Virtual Channels: Overview & Methodology
</title><script>MathJax={tex:{inlineMath:[["∳","∳"]],displayMath:[["∳∳","∳∳"]],processEscapes:!0},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script></head><body><style>@font-face{font-family:days_one;src:url(/days_one.ttf)format('truetype')}.siteTitle{margin-top:24px}.siteTitle img{display:inline-block;vertical-align:middle;margin-top:-24px;margin-right:-10px}.siteTitle span{font-family:days_one,Fallback,sans-serif;color:#fff;font-size:160%}</style><div class=main><header><div class=header-bar><nav><div class=siteTitle><a href=/><img src=/shard_only_no_background.png width=12%></img>
<span>THALIUM</span></a></div><a class=nav-item href=/posts/><div class=nav-item-title>Posts</div></a><a class=nav-item href=/joinus/><div class=nav-item-title>Join Us</div></a><a class=nav-item href=/about/><div class=nav-item-title>About</div></a></nav><div class=social-links-header><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>Github</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div></div></header><article class=post><h1 class=title>Fuzzing Microsoft's RDP Client using Virtual Channels: Overview & Methodology</h1><div class=content><p>This article begins my three-part series on fuzzing Microsoft&rsquo;s RDP client. In this <strong>first installment</strong>, I set up a methodology for <strong>fuzzing Virtual Channels</strong> using WinAFL and share some of my findings.</p><p>Other articles in this series:</p><ul><li><a href=/posts/fuzzing-microsoft-rdp-client-using-virtual-channels/>Fuzzing Microsoft&rsquo;s RDP Client using Virtual Channels: Overview & Methodology</a></li><li><a href=/posts/leaking-aslr-through-rdp-printer-cache-registry/>Remote ASLR Leak in Microsoft&rsquo;s RDP Client through Printer Cache Registry (CVE-2021-38665)</a></li><li><a href=/posts/deserialization-bug-through-rdp-smart-card-extension/>Remote Deserialization Bug in Microsoft&rsquo;s RDP Client through Smart Card Extension (CVE-2021-38666)</a></li></ul><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#introduction>Introduction</a><ul><li><a href=#recent-related-works>Recent related works</a></li><li><a href=#why-search-for-vulnerabilities-in-the-rdp-client>Why search for vulnerabilities in the RDP <em>client</em>?</a></li></ul></li><li><a href=#the-remote-desktop-protocol>The Remote Desktop Protocol</a><ul><li><a href=#virtual-channels>Virtual Channels</a></li><li><a href=#static-virtual-channels>Static Virtual Channels</a></li><li><a href=#dynamic-virtual-channels>Dynamic Virtual Channels</a></li></ul></li><li><a href=#fuzzing-the-rdp-client-with-winafl-setup-and-architecture>Fuzzing the RDP client with WinAFL: setup and architecture</a><ul><li><a href=#winafl-a-brief-presentation-and-choices>WinAFL: a brief presentation and choices</a></li><li><a href=#thread-coverage-within-dynamorio>Thread coverage within DynamoRIO</a></li><li><a href=#setting-up-winafl-for-network-fuzzing>Setting up WinAFL for network fuzzing</a></li><li><a href=#other-fuzzing-preparations>Other fuzzing preparations</a></li></ul></li><li><a href=#fuzzing-methodology>Fuzzing methodology</a><ul><li><a href=#attacking-a-channel>Attacking a channel</a></li><li><a href=#fuzzing-strategies>Fuzzing strategies</a><ul><li><a href=#mixed-message-type-fuzzing>Mixed message type fuzzing</a></li><li><a href=#fixed-message-type-fuzzing>Fixed message type fuzzing</a></li></ul></li><li><a href=#leveraging-the-harness>Leveraging the harness</a></li><li><a href=#analyzing-crashes>Analyzing crashes</a></li><li><a href=#assessing-fuzzing-quality>Assessing fuzzing quality</a></li></ul></li><li><a href=#results>Results</a><ul><li><a href=#rdpsnd>RDPSND</a><ul><li><a href=#out-of-bounds-read-in-rdpsnd>Out-of-Bounds Read in RDPSND</a></li></ul></li><li><a href=#cliprdr>CLIPRDR</a><ul><li><a href=#arbitrary-malloc-dos-in-cliprdr>Arbitrary Malloc DoS in CLIPRDR</a></li></ul></li><li><a href=#drdynvc>DRDYNVC</a></li><li><a href=#rdpdr>RDPDR</a><ul><li><a href=#arbitrary-malloc-dos-in-rdpdr>Arbitrary Malloc DoS in RDPDR</a></li><li><a href=#remote-heap-leak--aslr-leak-in-rdpdr>Remote Heap Leak / ASLR Leak in RDPDR</a></li><li><a href=#deserialization-bug--heap-corruption-in-rdpdr>Deserialization Bug / Heap Corruption in RDPDR</a></li></ul></li></ul></li><li><a href=#conclusion>Conclusion</a><ul><li><a href=#timeline>Timeline</a></li></ul></li></ul><h1 id=introduction>Introduction</h1><p>The <strong>Remote Desktop Protocol (RDP)</strong> is a proprietary protocol designed by Microsoft which allows the user of an <em>RDP Client software</em> to connect to a remote computer over the network with a graphical interface. Its use around the world is very widespread; some people, for instance, use it often for remote work and administration.</p><p>During my internship at Thalium, I spent time studying and reverse engineering Microsoft RDP, learning about fuzzing, and looking for vulnerabilities.</p><p>The initial idea was to follow up on a <a href=https://www.unexploitable.systems/papers/park:rdpfuzzing-slides.pdf>conference talk from Blackhat Europe 2019</a>. A team of researchers (Chun Sung Park, Yeongjin Jang, Seungjoo Kim and Ki Taek Lee) found an RCE in Microsoft&rsquo;s RDP client. In particular, they found a bug by fuzzing the <strong>Virtual Channels</strong> of RDP using <strong>WinAFL</strong>.</p><p>We thought they achieved encouraging results that deserved to be prolonged and improved. The objective was to go even further, by coming up with a <strong>general methodology</strong> for <strong>attacking Virtual Channels in RDP</strong>, and fuzz more of Microsoft&rsquo;s RDP client with WinAFL.</p><p>This article aims at retracing my journey and giving out many details, hence why it is quite lengthy.</p><p>I will first explain the basics of the <em>Remote Desktop Protocol</em>. Then, I will talk about my setup with WinAFL and fuzzing methodology. Finally, I will present some results I achieved, including bugs and vulnerabilities.</p><h2 id=recent-related-works>Recent related works</h2><p>While I was working on this subject, other security researchers have also been looking for vulnerabilities in the RDP client. Some CVEs that came out during this period are CVE-2021-34535, CVE-2021-38631 and CVE-2021-41371.</p><p>In parallel, in August 2021, researchers from CyberArk have published some work they have conducted on fuzzing RDP (<a href=https://www.cyberark.com/resources/threat-research-blog/fuzzing-rdp-holding-the-stick-at-both-ends>Fuzzing RDP: Holding the Stick at Both Ends</a>). Even though they also used WinAFL and faced similar challenges, their fuzzing approach is interesting and somewhat differs from the one I will present in this article. They found a few small bugs, including one I found as well (detailled in the <a href=#rdpsnd>RDPSND section</a>).</p><h2 id=why-search-for-vulnerabilities-in-the-rdp-client>Why search for vulnerabilities in the RDP <em>client</em>?</h2><p>In the Blackhat talk, the research was driven by the fact that North Korean hackers would alledgely carry out attacks through RDP servers acting as proxies. By setting up a malicious RDP server to which they would connect, you could hack them back, assuming you found a vulnerability in the RDP client.</p><p>Aside from this engaging motive, most of vulnerability research seems to be focused on Microsoft&rsquo;s RDP <em>server</em> implementation. This is understandable: for instance, a denial of service constitutes a much higher risk for a server than for a client. Therefore, CVEs in the RDP client are more scarce, even though the attack surface is as large as the server&rsquo;s.</p><p>So let&rsquo;s dive into how RDP works and see for ourselves!</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/rdp-logo.png target=_blank><img src=/posts/img/rdp/rdp-logo.png alt="RDP logo"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Yes, RDP has a logo.</figcaption></figure></p><h1 id=the-remote-desktop-protocol>The Remote Desktop Protocol</h1><p>This article will not explain the Remote Desktop Protocol in depth. If you are interested in that, there are other resources out there that will explain it well, such as articles, or even the official Microsoft specification itself. This article will primarily concentrate on what we need to know in order to fuzz <em>Virtual Channels</em>.</p><p>Microsoft has its own implementation of RDP (client and server) built in Windows. There also exist alternate implementations of RDP, like the open-source <a href=https://github.com/FreeRDP/FreeRDP>FreeRDP</a>.</p><p>By default, the RDP server listens on TCP port 3389. UDP is also supported to improve performance for certain tasks such as bitmap or audio delivery.</p><p>In Windows 10, there are two main files of interest for the RDP client: <strong><code>C:\Windows\System32\mstsc.exe</code></strong> and <strong><code>C:\Windows\System32\mstscax.dll</code></strong>. Reverse engineering will focus on the latter, as it holds most of the RDP logic.</p><p>Basic, core functionalities of an RDP client include:</p><ul><li>receiving desktop bitmaps from the server;</li><li>sending keyboard and mouse inputs to the server.</li></ul><p>However, a lot of other information can be exchanged between an RDP client and an RDP server: sound, clipboard, support for special types of hardware, etc. This information goes through what Microsoft call <em><strong>Virtual Channels</strong></em>.</p><h2 id=virtual-channels>Virtual Channels</h2><p><em>Virtual Channels</em> (or just &ldquo;channels&rdquo;) are an abstraction layer in the Remote Desktop Protocol used to generically transport data. They can add <strong>functional enhancements</strong> to an RDP session. The Remote Desktop Protocol provides <strong>multiplexed management</strong> of multiple <em>virtual channels</em>.</p><p>Each individual <em>Virtual Channel</em> behaves according to its <strong>own separate logic</strong>, <strong>specification</strong> and <strong>protocol</strong>.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/virtual_channels.png target=_blank><img src=/posts/img/rdp/virtual_channels.png alt="<em>Channels</em> between an RDP client and server"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Diagram: Guillaume Quéré</figcaption></figure></p><p>Official, documented <em>Virtual Channels</em> by Microsoft come by <a href=https://github.com/FreeRDP/FreeRDP/wiki/Reference-Documentation>dozens</a>:</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/microsoft-channels-docs.png target=_blank><img src=/posts/img/rdp/microsoft-channels-docs.png alt="Non-exhaustive list of <em>Virtual Channels</em> documented by Microsoft"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Non-exhaustive list of <em>Virtual Channels</em> documented by Microsoft, found in the FreeRDP wiki</figcaption></figure></p><p>These documentations are an invaluable resource; each channel has its own open specification, and some can span more than a hundred pages.</p><p>The Remote Desktop Protocol stack itself is a bit complex and has several layers (with sometimes multiple layers of encryption). <em>Virtual Channels</em> operate on the <strong>MCS</strong> layer.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/rdp-stack.png target=_blank><img src=/posts/img/rdp/rdp-stack.png alt="RDP stack"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>RDP protocol stack from « Explain Like I&rsquo;m 5: Remote Desktop Protocol (RDP) »</figcaption></figure></p><p>Thanksfully, Windows provides an API called the <a href=https://docs.microsoft.com/en-us/windows/win32/api/wtsapi32/><strong>WTS API</strong></a> to interact with this layer, which allows us to easily open, read from and write to a channel. This will greatly help us develop a <strong>fuzzing harness</strong>.</p><p>Finally, there are two kinds of <em>Virtual Channels</em> : <strong>static</strong> ones and <strong>dynamic</strong> ones.</p><h2 id=static-virtual-channels>Static Virtual Channels</h2><p><em>Static Virtual Channels</em> (or <strong>SVC</strong>) are negotiated during the connection phase of RDP. They are opened once for the session and are identified by a name that fits in 8 bytes.</p><p>At initialization and <strong>by default</strong>, the RDP client asks to open the four following SVCs:</p><ul><li><strong><code>RDPSND</code></strong>: audio redirection from the server to the client</li><li><strong><code>CLIPRDR</code></strong>: two-way clipboard redirection/synchronization</li><li><strong><code>RDPDR</code></strong>: filesystem redirection (and more&mldr; ;))</li><li><strong><code>DRDYNVC</code></strong>: support for dynamic channels</li></ul><h2 id=dynamic-virtual-channels>Dynamic Virtual Channels</h2><p><em>Dynamic Virtual Channels</em> (or <strong>DVC</strong>) are built on top of the <code>DRDYNVC</code> <em>Static Virtual Channel</em>, which manages them. In particular, DVCs can be opened and closed on the fly during an RDP session by the server. They are especially used by developers to create extensions, but also by red teamers to exfiltrate data, bypass firewalls, etc.</p><p>There are many DVCs. Here are some that are provided by Microsoft:</p><ul><li><strong><code>Microsoft::Windows::RDS::Input</code></strong> (multitouch and pen input)</li><li><strong><code>Microsoft::Windows::RDS::Geometry</code></strong> (geometric rendering)</li><li><strong><code>Microsoft::Windows::RDS::DisplayControl</code></strong> (display configuration, monitors)</li><li><strong><code>Microsoft::Windows::RDS::Telemetry</code></strong> (performance metrics)</li><li><strong><code>AUDIO_INPUT</code></strong> (microphones&mldr;)</li><li><strong><code>RDCamera_Device_Enumerator</code></strong> (webcams&mldr;)</li><li><strong><code>PNPDR</code>, <code>FileRedirectorChannel</code></strong> (PnP redirection)</li><li>&mldr;</li></ul><p>In conclusion, both types of <em>Virtual Channels</em> are <strong>great targets for fuzzing</strong>. Each channel behaves independently, has a different protocol parser, different logic, lots of different structures, and can hide many bugs!</p><p>What is more, the four aforementioned SVCs (as well as a few DVCs) being opened by default makes them an even more interesting target risk-wise. Indeed, any vulnerability found in these will directly impact most RDP clients.</p><h1 id=fuzzing-the-rdp-client-with-winafl-setup-and-architecture>Fuzzing the RDP client with WinAFL: setup and architecture</h1><p>As mentioned, we will fuzz our target using <strong>WinAFL</strong> on Windows. However, WinAFL is not going to work with our target &ldquo;out of the box&rdquo;. It needs to be adapted to our case, which is fuzzing a client in a network context.</p><h2 id=winafl-a-brief-presentation-and-choices>WinAFL: a brief presentation and choices</h2><p><a href=https://github.com/googleprojectzero/winafl>WinAFL</a> is a Windows fork of the popular mutational fuzzing tool <strong>AFL</strong>.</p><p>AFL/WinAFL work by continously sending and <strong>mutating inputs</strong> to the target program, to make it behave unexpectedly (and hopefully crash).</p><p>Mutations are repeatedly performed on samples which must initially come from what we call a <em>corpus</em>. A corpus is a set of input files, or <strong>seeds</strong>, that we need to construct and feed to WinAFL to start. Examples of mutations include bit flipping, performing arithmetic operations and inserting known interesting integers.</p><p>In order to achieve <strong>coverage-guided fuzzing</strong>, WinAFL provides several modes to instrument the target binary:</p><ul><li>Dynamic instrumentation using DynamoRIO</li><li>Hardware tracing using Intel PT</li><li>Static instrumentation with Syzygy</li></ul><p>Intel PT has limitations within virtualized environments, and there are too many constraints for us to use Syzygy (compilation restrictions&mldr;).</p><p>Therefore, we will use <a href=https://dynamorio.org/><strong>DynamoRIO</strong></a>, a well-known dynamic binary instrumentation framework.</p><p>DynamoRIO provides an API to deal with black-box targets, which WinAFL can use to instrument our target binary (in particular, monitor code coverage at run time).
As a drawback, DynamoRIO will add some overhead, but execution speed will still be decent.</p><p>The following diagram attempts to summarize the fuzzing process in a very much simplified manner, and using WinAFL&rsquo;s <em>no-loop mode</em>.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/winafl-no-loop-mode.png target=_blank><img src=/posts/img/rdp/winafl-no-loop-mode.png alt="WinAFL no-loop mode"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Fuzzing process with WinAFL in no-loop mode</figcaption></figure></p><p>We needed to choose a <strong>persistence mode</strong>: something that dictates how the fuzzer should exactly <em>loop</em> on our target function. Indeed, when fuzzing, you don&rsquo;t want to kill and start your target again every execution. It would be painfully slow, especially with the RDP client, which can sometimes take 10 or 20 seconds to connect.</p><p>When using WinAFL with DynamoRIO, there are several persistence modes available for us to choose from:</p><ul><li><em>Native</em> persistence &ndash; measure coverage of the target function, and on <code>return</code>, reload context and artificially redirect execution back to the start of the target function;</li><li><em>In-app</em> persistence &ndash; let the program loop naturally, and coverage will reset each time in the <code>pre_loop_start_handler</code>, inserted right before the target function.</li></ul><p>In-app persistence seems the most adapted to our case. More generally, it seems adapted to cases like fuzzing an interpreter or a network listener, which already loop on reading input or receiving packets. However, it is not ideal because code coverage measurement will not stop at <code>return</code>.</p><p>So what is this <strong>no-loop mode</strong>, you ask me? Well, I&rsquo;m not sure myself &ndash; it is not <a href=https://github.com/googleprojectzero/winafl/blob/master/readme_dr.md>documented</a> (at least at the time I am writing this article). I just happened to stumble upon it while reading WinAFL&rsquo;s codebase, and it proves to be totally fit for our network context!</p><p>The no-loop mode lets the program loop by its own, just like in-app persistence. But it has the advantage of stopping coverage measurement at <code>return</code>. Funnily enough, the source code of WinAFL itself hints that it is the preferred mode for network fuzzing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* We don&#39;t need to reload context in case of network-based fuzzing. */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (options.no_loop)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>;
</span></span></code></pre></div><hr><p>Last but not least about execution of the RDP client while fuzzing. I did mention the function we target should be fuzzed in a loop without restarting the process. However, it will still restart from time to time: for instance, when reaching the max number of fuzzing iterations (<code>-fuzz_iterations</code> parameter), or simply because of crashes (if we find some).</p><p>Since fuzzing campaigns usually last many hours, we can&rsquo;t be there every time the fuzzer restarts the client to click &ldquo;Connect&rdquo; and select a user account. Fuzzing should entirely happen without human intervention.</p><p>Therefore, we need the RDP client to be able to connect autonomously to the server. This is easily done with a little trick: use <strong>cmdkey</strong> to store credentials (<code>cmdkey -generic &lt;ip> -user User -pass 123</code>) and then start the RDP client with <code>mstsc.exe /v &lt;ip></code>.</p><h2 id=thread-coverage-within-dynamorio>Thread coverage within DynamoRIO</h2><p>Before going any further, I would like to tackle an important concern.</p><p>We have just talked about how DynamoRIO monitors code coverage; it starts monitoring it when entering the target function, and stops on <code>return</code>.</p><p>There is an important metric in AFL related to coverage: the <strong>stability metric</strong>.</p><blockquote><p><em>The stability metric measures the <strong>consistency of observed traces</strong>. If a program always behaves the same for the same input data, it will earn a score of 100%. [&mldr;] If it goes into red, you may be in trouble, since <strong>AFL will have difficulty discerning between meaningful and &ldquo;phantom&rdquo; effects of tweaking the input file</strong>.</em></p></blockquote><blockquote><p><em>Most targets will just get a 100% score, but when you see lower figures, there are several things to look at. [&mldr;]</em></p><p><em><strong>Multiple threads</strong> executing at once in semi-random order: this is harmless when the &lsquo;stability&rsquo; metric stays over 90% or so, but can become an issue if not. [&mldr;]</em></p></blockquote><p>Indeed, when naively measuring <strong>code coverage</strong> (the <em>trace</em>) in a <strong>multi-threaded application</strong>, other threads may interfere with the one of interest.</p><p>For this reason, DynamoRIO has a <strong><code>-thread-coverage</code> option</strong>. This option allows to collect coverage only from the thread of interest, which is the one that executed the target function.</p><p>Forgetting this option while fuzzing the RDP client will inevitably nuke stability, and the fuzzing will likely not be coverage-guided. Instead, it will randomly mutate inputs without knowing which mutations actually yield favorable results (new paths in the correct thread).</p><p>Not using thread coverage is basically relying on luck to trigger new paths in your target function. Of course, many crashes can still happen at the first <em>depth level</em>. But in order not to waste fuzzing effort in deeper levels of path geometry while fuzzing a multi-threaded application, one had better use thread coverage within DynamoRIO.</p><p>This is a critical fact we must take into account for when we are fuzzing later!</p><h2 id=setting-up-winafl-for-network-fuzzing>Setting up WinAFL for network fuzzing</h2><p>By default, WinAFL writes mutations to a <strong>file</strong>. This file should be passed as an argument to the target binary.</p><p>Since we&rsquo;re fuzzing a network client, we want our harness to act like a server that sends mutations to the client <em>over the network</em>. Thus, the two next steps are:</p><ol><li>Developing a <strong>server-side harness</strong></li><li><strong>Adapting WinAFL</strong> to a <strong>network context</strong></li></ol><p>With this in mind, I developed what I will call during the rest of this article the <strong>VC Server</strong> (for <em>Virtual Channel Server</em>). It is our harness which runs parallel to the RDP server.</p><p>Basically, the VC Server will:</p><ol><li>Listen on a TCP port for an <strong>input mutation</strong></li><li>Optionally process the mutation</li><li><strong>Send the mutation back to the RDP client</strong> through a specified <em>Virtual Channel</em></li></ol><p>This is easily done with the <strong>WTS API</strong> I mentioned earlier, which allows to open, read from and write to a channel.</p><p>For instance, you can open a channel this way:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>WTSVirtualChannelOpenEx</span>(WTS_CURRENT_SESSION, <span style=color:#e6db74>&#34;RDPSND&#34;</span>, <span style=color:#ae81ff>0</span>);
</span></span></code></pre></div><p>And you can write to a channel this way:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>WTSVirtualChannelWrite</span>(virtual_channel, buffer, length, <span style=color:#f92672>&amp;</span>bytes_written);
</span></span></code></pre></div><p>All that remains is to <strong>modify WinAFL</strong> so that instead of writing mutations to a file, it <strong>sends them over TCP</strong> to our VC Server. This can be done by patching the function <code>write_to_testcase</code>.</p><p>Here&rsquo;s what our fuzzing « architecture » resembles now.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/fuzzing-architecture.png target=_blank><img src=/posts/img/rdp/fuzzing-architecture.png alt="Fuzzing architecture"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Fuzzing architecture</figcaption></figure></p><h2 id=other-fuzzing-preparations>Other fuzzing preparations</h2><p>In the Blackhat talk, the authors said they used two virtual machines: one for the client, and one for the server. Do we really need that? Can&rsquo;t we just connect to a local RDP server on the same machine?</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/rdp-no-loopback.png target=_blank><img src=/posts/img/rdp/rdp-no-loopback.png alt="No loopback connection for you"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Attempt at RDP loopback connection. Oops&mldr;</figcaption></figure></p><p>By design, Microsoft RDP prevents a client from connecting from the same machine, both at server level and client level.</p><p>To bypass this constraint, there exists a wonderful tool called <a href=https://github.com/stascorp/rdpwrap><strong>RDPWrap</strong></a>. RDPWrap tampers with the server in order to allow <strong>local connections</strong>, and even concurrent sessions.</p><p>As for the client application, it seems that only connections to &ldquo;localhost&rdquo; and &ldquo;127.0.0.1&rdquo; are blocked. You can easily bypass this protection by connecting to <strong>&ldquo;127.0.0.2&rdquo;</strong>, which is equivalent.</p><p>A possible setup is thus:</p><ul><li>create two users on the same virtual machine, &ldquo;User1&rdquo; and &ldquo;User2&rdquo;;</li><li>setup the RDP server with RDPWrap to allow remote connection for User1;</li><li>use the RDP client on a User2 session, by connecting to 127.0.0.2 with the credentials of User1.</li></ul><p>Finally, before we start fuzzing, we should enable a little something that will be useful: <a href=https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/gflags-and-pageheap><strong>PageHeap</strong></a> (GFlags).</p><p>By activating PageHeap on <code>mstsc.exe</code> with the <code>/full</code> option, we ask Windows to place an inaccessible page at the end of each heap allocation. As soon as something happens out-of-bounds, the client will then crash.</p><p>It can help the fuzzer identify bugs to which it would have otherwise been oblivious. For instance, sometimes small out-of-bounds reads will not trigger a crash depending on what&rsquo;s done with the read value, but can still hide a bigger looming threat.</p><h1 id=fuzzing-methodology>Fuzzing methodology</h1><p>We now have a working harness and are pretty much ready to fuzz. But what do we fuzz, and how do we get started?</p><p>We did gather earlier a little list of channels that looked like fruitful targets. Especially, the ones that are opened by default and for which there is plenty of documentation.</p><p>To illustrate this part, I will use the first channel I decided to attack: the <strong>RDPSND</strong> channel.</p><h2 id=attacking-a-channel>Attacking a channel</h2><p>Now that we&rsquo;ve chosen our target, where do we begin? Concretely, we only lack two elements to start fuzzing:</p><ul><li>A <strong>target offset</strong></li><li>An initial corpus (<strong>seeds</strong>)</li></ul><p>A good lead is to start by reading Microsoft&rsquo;s <strong>specification</strong> (e.g. <a href=https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-RDPEA/%5bMS-RDPEA%5d.pdf>here</a> for RDPSND). As we said, the specification is a goldmine. It describes the channel&rsquo;s functioning quite exhaustively, as well as:</p><ul><li>All the message types</li><li>All the data structures</li><li>Protocol diagrams</li><li>Many <strong>examples of PDU hexdumps</strong> at the end<ul><li>Great to <strong>seed the fuzzer</strong>!</li></ul></li><li>&mldr;</li></ul><p>With a good picture of the channel in mind, we can now start reversing the RDP client. We need to locate <strong>where incoming PDUs</strong> in the channel are <strong>handled</strong>.</p><p>Unfortunately, the way channels globally work in RDP is somewhat circuitous and I never got around to fully figuring it out. Besides, each channel is architectured in a different fashion; there is rarely a common code structure or even naming convention between two channels&rsquo; implementation.</p><p>Thanksfully, the PDB symbols are enough to identify most of the channel handlers. Strings or magic numbers from the specification can also help. For RDPSND, our target method&rsquo;s name is rather straightforward.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/crdpaudiocontroller.png target=_blank><img src=/posts/img/rdp/crdpaudiocontroller.png alt="RDPSND PDU handler"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>RDPSND PDU handler and dispatch logic in mstscax.dll</figcaption></figure></p><p>If « guessing » won&rsquo;t work, another possibility is to capture code coverage at the moment we send a PDU over the target <em>virtual channel</em>.</p><p>To achieve that, I used <a href=https://github.com/gaasedelen/lighthouse/tree/develop/coverage/frida><strong>frida-drcov.py</strong></a> from Lighthouse. It uses Frida to collect coverage against a running process between two points in time, and logs the output in a format readable by <a href=https://github.com/gaasedelen/lighthouse><strong>Lighthouse</strong></a>. Lighthouse is an IDA plugin to visualize code coverage.</p><p>I edited frida-drcov just slightly to make the Stalker tag each basic block that is returned with the corresponding thread id. This way, I can split the resulting coverage per thread, making it less cluttered.</p><h2 id=fuzzing-strategies>Fuzzing strategies</h2><p>We&rsquo;ve got our target offset: for RDPSND, <code>CRdpAudioController::DataArrived</code>. But should we really just start fuzzing naively with the seeds we&rsquo;ve gathered from the specification?</p><p>We technically have everything we need to start WinAFL. Here&rsquo;s what a WinAFL command line could look like:</p><pre tabindex=0><code>./afl-fuzz.exe -i input -o output -D C:/dynamorio/bin64 -t 30000 -- -target_module mstscax.dll -coverage_module mstscax.dll -target_offset 0x6ADA0 -fuzz_iterations 200000 -no_loop -thread_coverage -- C:/Windows/system32/mstsc.exe -v 127.0.0.2
</code></pre><p>However, remember we&rsquo;re fuzzing in a network context. In particular, we&rsquo;re doing <strong>stateful fuzzing</strong>: the RDP client could be modelled by a complex <strong>state machine</strong>. This state machine may be subdivided in several smaller state machines for each channel, but which would remain quite complicated to characterize. This implies a lot; we will talk about this.</p><p>I came up with basically two different strategies for fuzzing a channel that I will detail: <strong>mixed message type fuzzing</strong> and <strong>fixed message type fuzzing</strong>.</p><h3 id=mixed-message-type-fuzzing>Mixed message type fuzzing</h3><p>This strategy is what you&rsquo;d get by fuzzing the channel « naively ». This means, fuzzing with the <em>raw</em> seeds from the specification and without modifying the harness any further. In this case, the harness just sends back the mutation it receives as it is (apart from some exceptions such as overwriting a length field, which we will talk about later).</p><p>Example with RDPSND: a message comprises a header (<code>SNDPROLOG</code>) followed by a body.</p><p><a href=/posts/img/rdp/rdpsnd-header.png target=_blank><img src=/posts/img/rdp/rdpsnd-header.png alt="RDPSND Header"></a></p><p>Since the seeds include the header, the fuzzer will also mutate it, including the <strong>msgType</strong> field. Therefore, the RDP client will receive a lot of different message types, in a rather random order.</p><p>This is an interesting approach because sending a <strong>sequence of PDUs</strong> of different types in a <strong>certain order</strong> can help the client enter a <strong>state in which a bug will be triggered</strong>.</p><p>A <strong>drawback</strong> of this strategy is that <strong>crash analysis becomes more difficult</strong>. Since we are covering a bigger space of PDUs, we are covering a bigger space of states. In this case, there may be a higher chance that the crash we found originates from a &ldquo;stateful bug&rdquo;, and which statefulness can be increasingly complex.</p><p>In layman&rsquo;s terms: imagine WinAFL finds a crash and saves the corresponding mutation. There is no guarantee whatsoever you will be able to reproduce the crash with this mutation only.</p><p>If you try to reproduce the crash and it doesn&rsquo;t work, it&rsquo;s probably because it&rsquo;s actually rather a <strong>sequence of PDUs</strong> that made the client crash, and not just a single PDU. However, understanding which sequence of PDUs made the client crash is hard, not to say often a lost cause.</p><p>A solution could be to save the entire history of PDUs that were sent to the client. By replaying the whole history, you may hope the client behaves in a deterministic enough way that it reproduces the crash.</p><p>But fuzzing the RDP client, I often got speeds between 50 and 1000 execs/s. In the &ldquo;pessimistic&rdquo; case in which we&rsquo;re fuzzing at high speeds for a whole week-end and mutations are 100 bytes long on average, that&rsquo;s 24 GB of PDU history. This is already concerning space-wise, now imagine having to resend these billions of executions to the RDP client and waiting days to reach the crash&mldr;</p><h3 id=fixed-message-type-fuzzing>Fixed message type fuzzing</h3><p>This time, we want to let WinAFL fuzz only the <strong>body</strong> part of the message. In particular, the <strong>msgType</strong> field will be <strong>fixed</strong>, so we need to start a fuzzing campaign for each message type (there are 13 in RDPSND).</p><p>For example, we could say we&rsquo;re specifically targeting <em>Server Audio Formats and Version</em> PDUs in RDPSND (<code>SERVER_AUDIO_VERSION_AND_FORMATS</code>, msgType <code>0x07</code>). In this case, we are only fuzzing what&rsquo;s below <em>Header</em> in the following diagram.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/rdpsnd-0x07.png target=_blank><img src=/posts/img/rdp/rdpsnd-0x07.png alt="Server Audio Formats PDU"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>RDPSND Server Audio Formats and Version PDU structure</figcaption></figure></p><p>This strategy is still vulnerable to the presence of stateful bugs, but less than in mixed message type fuzzing, because the state space is usually smaller.</p><p>However, it requires some more preparation:</p><ul><li>« Beheading » the seeds (the fuzzer only needs to mutate on the bodies).</li><li>Writing a channel-specific wrapper in the VC Server to reconstruct and add the header before sending the PDU to the client.</li><li>Identifying handlers for each message type.<ul><li>Not vital because you can always target the &ldquo;parent&rdquo; handler, except in certain cases.</li><li>For instance, in the CLIPRDR channel, messages are asynchronously dispatched to their handlers, and we don&rsquo;t want to break thread coverage.</li></ul></li></ul><p>In conclusion, it&rsquo;s nice to try <strong>both fuzzing approaches</strong> for a channel. The first one can find interesting bugs, but which sometimes are very hard to analyze. The second one needs a bit more effort to setup, but allows to go more in depth in each message type&rsquo;s logic. Even though it finds fewer bugs, they&rsquo;re usually easier to reproduce.</p><h2 id=leveraging-the-harness>Leveraging the harness</h2><p>Our harness, the <em>VC Server</em>, can do much more than just &ldquo;echo&rdquo; mutations.</p><p>As we&rsquo;ve seen in the fixed message type fuzzing strategy, the harness can be adapted to calculate the header for a given message type and wrap the <em>headless</em> mutation with this header.</p><p>The harness is also essential to avoid <strong>edge cases</strong>.</p><p>These can happen in parsing logic: in RDPSND (and similarly in many other channels), the <em>Header</em> includes a <strong>BodySize</strong> field which <em>must</em> be equal to the length of the actual PDU body. If it&rsquo;s not, nothing happens &mdash; the message is simply ignored.</p><p><a href=/posts/img/rdp/rdpsnd-bodysize.png target=_blank><img src=/posts/img/rdp/rdpsnd-bodysize.png alt="RDPSND BodySize"></a></p><p>It is too easy for the fuzzer to mutate the BodySize field and break it, in which case most of the mutations go to waste.</p><p>You cannot tell WinAFL to have constraints on your mutations, such as &ldquo;these two bytes should reflect the length of this buffer&rdquo;. AFL&rsquo;s mutational engine is not intended to work this way.</p><p><strong>The harness can assume this role</strong> by calculating and <strong>overwriting</strong> this BodySize field. Of course, this is specific to RDPSND and such patches should happen in each channel.</p><p>Another obvious type of edge case is&mldr; <strong>crashes</strong>. If we find a crash, there&rsquo;s a high chance there are actually a lot of mutations that can trigger the same crash. You&rsquo;ll get tons of the same crashes in a row, which can heavily <strong>slow down</strong> fuzzing for certain periods of time. In this case, modifying the harness to <strong>prevent the client from crashing</strong> is a good idea.</p><h2 id=analyzing-crashes>Analyzing crashes</h2><p>As mentioned, analyzing a crash can range from easy to nearly impossible.</p><p>When WinAFL finds a crash, the only thing it pretty much does is save the mutation in the <code>crashes/</code> folder, under a name such as <code>id_000000_00_EXCEPTION_ACCESS_VIOLATION</code>.</p><p>From there, there are two possibilities:</p><ul><li>You are able to reproduce the crash manually. In this case, just reverse to understand the root cause, analyze risk, and maybe grow the crash into a bigger vulnerability.</li><li>You are not able to reproduce the crash manually. In this case: lie down, try not to cry, cry a lot.</li></ul><p>On a more serious note, if you can&rsquo;t reproduce the crash:</p><ul><li><strong>Dissect the guilty payload.</strong> Perhaps understanding the PDU will directly point towards a bug.<ul><li>For instance, if you notice the message type has a field which is an array of dynamic length, and that this length is coded inside another field and does not seem to match the actual number of elements in the array, maybe it&rsquo;s an out-of-bounds bug about improper length checking.</li></ul></li><li>If dissecting the payload does not yield anything, maybe it&rsquo;s a &ldquo;stateful bug&rdquo; and you&rsquo;re doomed.</li></ul><p>Too often I found crashes that I couldn&rsquo;t reproduce and had no idea how to analyze. To try and mitigate this a bit, I <strong>modified</strong> WinAFL to incorporate a feature that proved to be rather vital during my research: <strong>logging more information about crashes</strong>.</p><p>More specifically, everytime a crash is encountered, WinAFL/DynamoRIO will now log the exception address, module and offset, timestamp, and also exception information (like if there&rsquo;s an access violation on read, which address was tried to be read).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> ((exception_code <span style=color:#f92672>==</span> EXCEPTION_ACCESS_VIOLATION) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    (exception_code <span style=color:#f92672>==</span> EXCEPTION_ILLEGAL_INSTRUCTION) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    (exception_code <span style=color:#f92672>==</span> EXCEPTION_PRIV_INSTRUCTION) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    (exception_code <span style=color:#f92672>==</span> EXCEPTION_INT_DIVIDE_BY_ZERO) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    (exception_code <span style=color:#f92672>==</span> STATUS_HEAP_CORRUPTION) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    (exception_code <span style=color:#f92672>==</span> EXCEPTION_STACK_OVERFLOW) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    (exception_code <span style=color:#f92672>==</span> STATUS_STACK_BUFFER_OVERRUN) <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    (exception_code <span style=color:#f92672>==</span> STATUS_FATAL_APP_EXIT)) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(options.debug_mode) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>dr_fprintf</span>(winafl_data.log, <span style=color:#e6db74>&#34;crashed</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            mod_entry <span style=color:#f92672>=</span> <span style=color:#a6e22e>module_table_lookup</span>(winafl_data.cache, NUM_THREAD_MODULE_CACHE, module_table, (app_pc)excpt<span style=color:#f92672>-&gt;</span>record<span style=color:#f92672>-&gt;</span>ExceptionAddress);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>file_t</span> crash_log <span style=color:#f92672>=</span> <span style=color:#a6e22e>dr_open_file</span>(<span style=color:#e6db74>&#34;crash.log&#34;</span>, DR_FILE_WRITE_APPEND);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>time_t</span> ltime;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>time</span>(<span style=color:#f92672>&amp;</span>ltime);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>dr_fprintf</span>(crash_log, <span style=color:#e6db74>&#34;Crash at time %li</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, ltime);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (mod_entry <span style=color:#f92672>==</span> NULL <span style=color:#f92672>||</span> mod_entry<span style=color:#f92672>-&gt;</span>data <span style=color:#f92672>==</span> NULL) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>dr_fprintf</span>(
</span></span><span style=display:flex><span>                    crash_log,
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;Exception Address: %016llx / %016llx (unknown module)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>                    ((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span>) excpt<span style=color:#f92672>-&gt;</span>record<span style=color:#f92672>-&gt;</span>ExceptionAddress),
</span></span><span style=display:flex><span>                    ((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span>) excpt<span style=color:#f92672>-&gt;</span>record<span style=color:#f92672>-&gt;</span>ExceptionAddress) <span style=color:#f92672>-</span> module_start
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>dr_fprintf</span>(
</span></span><span style=display:flex><span>                    crash_log,
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;Exception Address: %016llx / %016llx (%s)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>                    ((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span>) excpt<span style=color:#f92672>-&gt;</span>record<span style=color:#f92672>-&gt;</span>ExceptionAddress),
</span></span><span style=display:flex><span>                    ((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span>) excpt<span style=color:#f92672>-&gt;</span>record<span style=color:#f92672>-&gt;</span>ExceptionAddress) <span style=color:#f92672>-</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>__int64</span>)mod_entry<span style=color:#f92672>-&gt;</span>data<span style=color:#f92672>-&gt;</span>start,
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>dr_module_preferred_name</span>(mod_entry<span style=color:#f92672>-&gt;</span>data)
</span></span><span style=display:flex><span>                );
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>dr_fprintf</span>(crash_log, <span style=color:#e6db74>&#34;Exception Information: %016llx %016llx</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, excpt<span style=color:#f92672>-&gt;</span>record<span style=color:#f92672>-&gt;</span>ExceptionInformation[<span style=color:#ae81ff>0</span>], excpt<span style=color:#f92672>-&gt;</span>record<span style=color:#f92672>-&gt;</span>ExceptionInformation[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>dr_fprintf</span>(crash_log, <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>dr_close_file</span>(crash_log);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>WriteCommandToPipe</span>(<span style=color:#e6db74>&#39;C&#39;</span>);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>WriteDWORDCommandToPipe</span>(exception_code);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dr_exit_process</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This allows to know precisely in <strong>which function</strong> and <strong>which instruction</strong> a crash happened. Usually it&rsquo;s in <code>mstscax.dll</code>, but it could also happen in another module. It is worth noting a crash in an &ldquo;unknown module&rdquo; could mean the execution flow was redirected, which accounts for the most interesting bugs&mldr; :)</p><p>Sadly, we can&rsquo;t do much more. Something very valuable would be having a call stack dump on crashes. However, DynamoRIO does not have such a feature, and we can&rsquo;t do it through <code>procdump</code> or <code>MiniDumpWriteDump</code> either because the client is already a debuggee of DynamoRIO (<code>drrun</code>).</p><p>Having the module and offset is already of a huge help in understanding crashes though: start reversing the client where it crashed and work your way backwards.</p><h2 id=assessing-fuzzing-quality>Assessing fuzzing quality</h2><p>Let&rsquo;s say we fuzzed a channel for a whole week-end. Everything works, everything is sunshine and rainbows, maybe we&rsquo;ve even been lucky enough to find bugs.</p><p><strong>When do we stop exactly?</strong> We&rsquo;re not gonna fuzz this channel forever, we&rsquo;ve still got many other places to fuzz.</p><p>If you plot the number of paths found over time, you will usually get something rather logarithmic that can look like this (this was not plotted from my fuzzing, this only serves as an illustration).</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/fuzzing-graph.png target=_blank><img src=/posts/img/rdp/fuzzing-graph.png alt="Number of paths found"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Usual appearance of « total paths found over time » while fuzzing</figcaption></figure></p><p>Fuzzing is gambling. Even though you may have reached a plateau and WinAFL hasn&rsquo;t discovered a new path in days, you could wait a few additional hours and have a lucky strike in which WinAFL finds a new mutation. This new mutation could snowball into dozens of new paths, including a crash that leads to the next big RCE.</p><p>The key question is: <strong>are we satisfied with our fuzzing?</strong></p><p>You could say you&rsquo;re satisfied with your fuzzing once you&rsquo;ve found a big vulnerability, but that&rsquo;s obviously a rather poor indicator of fuzzing quality.</p><p>Instead, it is preferable to assess fuzzing quality by looking at <strong>coverage quality</strong>. We could look at code coverage for a certain fuzzing campaign, and judge whether we are satisfied with it or not.</p><p>In order to do that, I modified WinAFL to add a new option: <code>-log_signal</code>. WinAFL will save <strong>all the basic blocks</strong> encountered at each fuzzing iteration in a temporary buffer (in the thread of interest). Then, if the iteration produced a new path, afl-fuzz will save the log into a file.</p><p>Therefore, for each new path, we have a corresponding basic block trace log. We can convert such a log into the Mod+Offset format that Lighthouse can read to visualize code coverage.</p><p>For RDPSND, we can get something like this.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/lighthouse-rdpsnd.png target=_blank><img src=/posts/img/rdp/lighthouse-rdpsnd.png alt="Code coverage for RDPSND"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Code coverage for our RDPSND fuzzing campaign using Lighthouse</figcaption></figure></p><p>The proportion of blocks hit in each &ldquo;audio&rdquo; function is a good indicator of quality. Though here, it is rarely >50% because there is a large proportion of error-handling blocks that are never triggered. Hence why all the functions are colored in red, but it is not very important.</p><p>Skimming through the functions, we can try to assess whether we&rsquo;re satisfied or not with the coverage. Although, this requires having reversed engineered the channel enough to have a good depiction of what&rsquo;s going on in mind &mdash; more specifically, knowing what are all the functions and basic blocks we are interested in.</p><h1 id=results>Results</h1><p>In this section, I will present <em>some</em> of my results in a few channels that I tried to fuzz.</p><table><thead><tr><th style=text-align:center>Channel</th><th style=text-align:left>Description</th><th style=text-align:center>Fuzzing level</th><th style=text-align:center>Bugs found</th></tr></thead><tbody><tr><td style=text-align:center><strong>RDPSND</strong></td><td style=text-align:left>Audio redirection</td><td style=text-align:center>2</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center><strong>CLIPRDR</strong></td><td style=text-align:left>Clipboard</td><td style=text-align:center>1</td><td style=text-align:center>1</td></tr><tr><td style=text-align:center><strong>DRDYNVC</strong></td><td style=text-align:left>Dynamic channels support</td><td style=text-align:center>0</td><td style=text-align:center></td></tr><tr><td style=text-align:center><strong>RDPDR</strong></td><td style=text-align:left>Filesystem redirection, printers, smart cards&mldr;</td><td style=text-align:center>2</td><td style=text-align:center>3</td></tr></tbody></table><p><em>Fuzzing level</em> is a <strong>subjective scale</strong> to assess how much I fuzzed each channel:</p><ul><li>0 = Could not fuzz</li><li>1 = Could fuzz more or better</li><li>2 = Quite satisfied with my fuzzing campaigns (but there might be more to fuzz&mldr;)</li></ul><h2 id=rdpsnd>RDPSND</h2><p><strong>RDPSND</strong> is a static virtual channel that transports <strong>audio data</strong> from server to client, so that the client can play sound originating from the server. It is opened by default.</p><p>I fuzzed most of the message types referenced in the <a href=https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-RDPEA/%5bMS-RDPEA%5d.pdf#%5B%7B%22num%22%3A65%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C69%2C738%2C0%5D>specification</a>. Each message type was fuzzed for hours and the channel as a whole for days. Fuzzing coverage is decent.</p><p>I found one bug that crashed the client: an <strong>Out-of-Bounds Read</strong> that is unfortunately unexploitable. The crash itself is not especially interesting, but I will still detail it because it&rsquo;s a great example of <em>stateful bug</em>.</p><h3 id=out-of-bounds-read-in-rdpsnd>Out-of-Bounds Read in RDPSND</h3><p>The crash happened upon receipt of a <em>Wave2 PDU</em> (<code>0x0D</code>), at <code>CRdpAudioController::OnWaveData+0x27D</code>.</p><p>Let&rsquo;s dissect the PDU:</p><pre tabindex=0><code>0d 00 10 00 // Header
16 a1       // wTimeStamp
0f 00       // wFormatNo
20          // cBlockNo
f5 00 00    // bPad
c2 b8 b3 0d // dwAudioTimeStamp
de 20 be ef // Data
</code></pre><p>Nothing particularly shocking right away. On a purely semantic level, fields that could be good candidates for a crash are <code>wFormatNo</code> or <code>cBlockNo</code>, because they could be used for indexing an array.</p><p>Reversing the <code>OnWaveData</code> function will surely make things clearer. Here&rsquo;s the interesting piece:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>wFormatNo <span style=color:#f92672>=</span> PDU<span style=color:#f92672>-&gt;</span>Body.wFormatNo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Has wFormatNo changed since the last Wave PDU?
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> (wFormatNo <span style=color:#f92672>!=</span> this<span style=color:#f92672>-&gt;</span>lastFormatNo) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Load the new format
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>CRdpAudioController<span style=color:#f92672>::</span><span style=color:#a6e22e>OnNewFormat</span>(this, wFormatNo)) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Error, exit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  this<span style=color:#f92672>-&gt;</span>lastFormatNo <span style=color:#f92672>=</span> wFormatNo;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Fetch the audio format of index wFormatNo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>savedAudioFormats <span style=color:#f92672>=</span> this<span style=color:#f92672>-&gt;</span>savedAudioFormats;
</span></span><span style=display:flex><span>targetFormat <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(AudioFormat <span style=color:#f92672>**</span>)(savedAudioFormats <span style=color:#f92672>+</span> <span style=color:#ae81ff>8</span> <span style=color:#f92672>*</span> wFormatNo);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>wFormatTag <span style=color:#f92672>=</span> targetFormat<span style=color:#f92672>-&gt;</span>wFormatTag;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (wFormatTag <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>The out-of-bounds read is quite evident: we control <code>wFormatNo</code> (unsigned short). However, manually sending the malicious PDU again does not do anything &ndash; we are unable to reproduce the bug.</p><p>This is a case of stateful bug in which a <strong>sequence</strong> of PDUs crashed the client, and we only know the last PDU. We&rsquo;re gonna have to manually reconstruct the puzzle pieces!</p><p>Since no length checking seems to be performed on <code>wFormatNo</code> here, the fact that we cannot reproduce the bug must come from the condition above in the code. Indeed, we find out there actually is length checking inside <code>OnNewFormat</code>. We need to find a way to skip this condition to trigger the bug.</p><p>In order to skip the condition, we need to send a format number that is equal to the last one we sent. But to trigger a bug, we want the format number to be bigger than the number of formats; how do we achieve that by not changing the format number?</p><p>The answer lies in the <em>Server Audio Formats and Version PDU</em>.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/rdpsnd-0x07.png target=_blank><img src=/posts/img/rdp/rdpsnd-0x07.png alt="Server Audio Formats PDU"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>RDPSND Server Audio Formats PDU structure (haven&rsquo;t we already met before?)</figcaption></figure></p><p>This PDU is used by the server to send a list of supported audio formats to the client. The client will save this list of formats in <code>this->savedAudioFormats</code>. So we can simply send a Format PDU between two Wave PDUs to make the list <strong>smaller</strong>. Here&rsquo;s the idea:</p><ol><li>Send ∳n > 1∳ formats to the client through a Format PDU.</li><li>Send a Wave PDU with <code>wFormatNo</code> set to ∳n∳.</li><li>Send a new Format PDU with ∳k &lt; n∳ formats: the format list is freed and reconstructed.</li><li>Send the same Wave PDU than in step 2: since <code>lastFormatNo</code> is ∳n∳, we bypass length-checking inside <code>OnNewFormat</code> and trigger the out-of-bounds read.</li></ol><p>Now, we can&rsquo;t do much with this primitive: we can probably read arbitrary memory, but <code>wFormatTag</code> is only used in a weak comparison (<code>wFormatTag == 1</code>). We can&rsquo;t leak much information remotely.</p><p>All in all, this bug is still interesting because it highlights how <strong>mixed message type fuzzing can help find new bugs</strong>. WinAFL managed to find a sequence of PDUs which bypasses a certain condition to trigger a crash &mdash; and we could have very well overlooked it if we were manually searching for a vulnerability.</p><h2 id=cliprdr>CLIPRDR</h2><p><strong>CLIPRDR</strong> is a static <em>virtual channel</em> dedicated to synchronization of the <strong>clipboard</strong> between the server and the client. It allows to copy several types of data (text, image, files&mldr;) from server to client and from client to server. It is opened by default.</p><p>There&rsquo;s a twist with this channel: it&rsquo;s a state machine. By that, I mean that unlike the other channels, it&rsquo;s a real state machine with proper <strong>state verification</strong>, and it is even <a href=https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-RDPECLIP/%5bMS-RDPECLIP%5d.pdf#%5B%7B%22num%22%3A68%2C%22gen%22%3A0%7D%2C%7B%22name%22%3A%22XYZ%22%7D%2C69%2C296%2C0%5D>documented</a>.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/clipboard_state_machine.png target=_blank><img src=/posts/img/rdp/clipboard_state_machine.png alt="CLIPRDR state machine"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>CLIPRDR state machine diagram from the specification</figcaption></figure></p><p>Indeed, each PDU sub-handler (logic for a certain message type) calls the <code>CheckClipboardStateTable</code> function prior to anything else. This function tracks and ensures the client is in the <strong>correct state</strong> to process the PDU. If it&rsquo;s not in the correct state, it just drops the message and does not do anything.</p><p>This is a problem for two major reasons:</p><ul><li>If we are performing mixed message type fuzzing, a lot of our <strong>fuzzing effort will go to waste</strong>. Few PDU sequences will actually make sense and bring the client to the right state at the right time.</li><li><strong>We can&rsquo;t perform fixed message type fuzzing</strong>, unless for each message type we find a way to force the client to be in the right state. This is a lot of effort to characterize and implement.</li></ul><p>There&rsquo;s a second twist with this channel: incoming PDUs are dispatched <strong>asynchronously</strong>.</p><p>The <code>CClipRdrPduDispatcher::DispatchPdu</code> function is where PDUs arrive and are dispatched based on <strong>msgType</strong>. It contains many dynamic calls that all lead to <code>CTSCoreEventSource::FireASyncNotification</code>. The PDU sub-handling logic is therefore run in <strong>a different thread</strong>.</p><p>This means we can&rsquo;t use the <code>-thread_coverage</code> option anymore if we target <code>DispatchPdu</code>&mldr; So <strong>we can&rsquo;t perform mixed message type fuzzing</strong> with reliable coverage anymore. On the other hand, as we said, we can&rsquo;t perform fixed message type fuzzing either at all because of state verification.</p><p>Therefore, we don&rsquo;t have much choice but to perform <em>blind mixed message type fuzzing</em> (without thread coverage).</p><p>I was still able to identify a little bug with this fuzzing strategy.</p><h3 id=arbitrary-malloc-dos-in-cliprdr>Arbitrary Malloc DoS in CLIPRDR</h3><p>As I was fuzzing CLIPRDR, I often had a problem in which my virtual machine would eventually <strong>freeze</strong>, and I couldn&rsquo;t do anything but hard reboot it.</p><p>The thing is, I spent an unreasonable amount of time thinking: &ldquo;this problem sucks, I can&rsquo;t go any further because of it, my setup is broken, I don&rsquo;t know why, and I am doomed because I cannot fuzz anymore&rdquo;.</p><p>I kept blaming myself because the fuzzing setup is complex, unstable, and this was not the first time I was encoutering weird bugs. Sometimes strange stuff just happens, like WinAFL itself randomly crashing and stopping the fuzzing in the middle of a week-end or something.</p><p>Whereas what I should have been thinking all this time is: &ldquo;<strong>something is broken, and that&rsquo;s <em>good</em></strong> because that&rsquo;s what I&rsquo;m aiming for. If something behaves strangely, then I need to find the reason why. Maybe this will lead me to new findings, and even a reproducible bug.&rdquo;</p><p>I feel like <strong>attitude plays a great role in fuzzing</strong>. Often you get results you don&rsquo;t know how to interpret, and the way you decide to react to them can greatly impact your findings and overall success.</p><p>But it is very easy to let yourself get discouraged at seeing you haven&rsquo;t had any result in weeks. It&rsquo;s easy to lack motivation to have the right attitude at the right time towards a certain type of result, and actually getting stuff done (investigating, confirming/rejecting hypotheses, etc.).</p><p>Fuzzing is a battle against the binary, but it is also a battle against yourself.</p><hr><p>The freezing always happened at a random time since I was fuzzing in non-deterministic mode. I eventually switched to deterministic and noticed it usually happened around 5 minutes of fuzzing.</p><p>I modified my VC Server to integrate a <strong>slow mode</strong>. This way, I could have time to monitor which PDU was guilty and what exactly happened when it was sent.</p><p>It turns out the client was actually causing <strong>memory overcommitment</strong> leading to <strong>RAM explosion</strong>. The virtual machine&rsquo;s RAM would very quickly fill up, until at some point having to start filling up swap. When no more swap memory is left, the system becomes awfully slow and unresponsive, until happens what a few sources call <strong>death by swap</strong> or swap death.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/cliprdr-malloc-poc.png target=_blank><img src=/posts/img/rdp/cliprdr-malloc-poc.png alt="CLIPRDR death by swap"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Top 10 Haunting Pictures Taken Seconds Before Disaster</figcaption></figure></p><p>I was able to isolate the malicious PDU and reproduce the bug with a minimal case:</p><pre tabindex=0><code>0A 00       // msgType
00 00       // msgFlags
04 00 00 00 // dataLen
01 69 63 6B // clipDataId
</code></pre><p>It is a <em>Lock Clipboard Data PDU</em> (<code>0x000A</code>), which basically only contains a <code>clipDataId</code> field. In the function <code>CClipBase::OnLockClipData</code>, this field is used with some kind of &ldquo;smart array&rdquo; object:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#a6e22e>EnterCriticalSection</span>(...);
</span></span><span style=display:flex><span>v5 <span style=color:#f92672>=</span> SmartArray<span style=color:#f92672>&lt;</span>CFileContentsReaderManager<span style=color:#f92672>&gt;::</span><span style=color:#a6e22e>AddAt</span>(
</span></span><span style=display:flex><span>  this,
</span></span><span style=display:flex><span>  PDU<span style=color:#f92672>-&gt;</span>clipDataId,
</span></span><span style=display:flex><span>  v9
</span></span><span style=display:flex><span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>?</span> <span style=color:#ae81ff>0x8007000E</span> <span style=color:#f92672>:</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>LeaveCriticalSection</span>(...);
</span></span></code></pre></div><p>Eventually, the function <code>DynArray&lt;SmartArray&lt;RdpStagingSurface,unsigned long>::CCleanType,unsigned long>::Grow</code> is called and performs:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>v5 <span style=color:#f92672>=</span> operator <span style=color:#a6e22e>new</span>(<span style=color:#a6e22e>saturated_mul</span>(<span style=color:#ae81ff>32</span> <span style=color:#f92672>+</span> clipDataId, <span style=color:#ae81ff>8u</span>i64));
</span></span></code></pre></div><p>My guess is that an array of dynamic length is used to store information, such as a lock tag, about file streams based on their id (if this is really the case, then it is probably poor choice of data structure). If the array is not big enough when trying to access a certain index, then it is reallocated with sufficient size.</p><p>This leads to a <strong>malloc</strong> of size ∳8 \times (32 + \text{clipDataId})∳, which means at maximum a little more than <strong>32 GB</strong>. Of course, on systems with a moderate amount of RAM like an employee&rsquo;s laptop, this may be dangerous.</p><p>Risk-wise, this is a case of <strong>remote system-wide denial of service</strong>. Obviously, it&rsquo;s less impressive on a client than on a server, but it&rsquo;s still nastier than your usual mere crash.</p><p><strong>Microsoft acknowledged the bug, but unsurprisingly closed the case as a <em>low severity DOS vulnerability</em>.</strong> I still think it could have deserved a little fix. Imagine a Windows machine that hosts several critical services, and from which you can connect to another machine through RDP &mdash; since the DOS hangs the entire system, these critical services would be impacted too.</p><p>While writing a PoC, I noticed something interesting. Depending on how much available RAM there is left on the client, you cannot just send a PDU with <code>0xFFFFFFFF</code> as <code>clipDataId</code>. The client will try to allocate <em>too much</em> at once, and malloc will return <code>ERROR_NOT_ENOUGH_MEMORY</code>. But you still need to make the client allocate enough memory to reach death by swap. Thus, my exploit sends the malicious payloads with smaller 128 MB increments to adapt to the amount of RAM on the victim&rsquo;s system.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> payload[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x0A</span>, <span style=color:#ae81ff>0x00</span>,             <span style=color:#75715e>// msgType
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,             <span style=color:#75715e>// msgFlags
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x04</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// dataLen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0xFF</span>, <span style=color:#ae81ff>0xFF</span>, <span style=color:#ae81ff>0xFF</span>, <span style=color:#ae81ff>0x00</span>  <span style=color:#75715e>// clipDataId
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>connect_to_virtual_channel</span>(<span style=color:#e6db74>&#34;cliprdr&#34;</span>, <span style=color:#ae81ff>10</span>, STATIC_CHANNEL);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> c <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; c <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>256</span>; c<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    payload[<span style=color:#ae81ff>11</span>] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>char</span>)c; <span style=color:#75715e>// Allocate memory with 128MB increments
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>write_to_virtual_channel</span>(payload, <span style=color:#66d9ef>sizeof</span>(payload));
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>close_virtual_channel</span>();
</span></span></code></pre></div><p>From this bug, we learned a golden rule of fuzzing: that it is not only about crashes.</p><p><strong>Side effects of fuzzing on a system can reveal bugs too.</strong></p><h2 id=drdynvc>DRDYNVC</h2><p><strong>DRDYNVC</strong> is a <em>Static Virtual Channel</em> dedicated to the <strong>support of dynamic virtual channels</strong>. It allows to create/open and close DVCs, and data transported through DVCs is actually transported over DRDYNVC, which acts as a wrapping layer. It is opened by default.</p><p>When I got started on this channel, I began studying the <a href=https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-RDPEDYC/%5bMS-RDPEDYC%5d.pdf>specification</a>, message types, reversing the client, identifying all the relevant functions&mldr; Until realizing a major issue: I was <strong>unable to open the channel</strong> through the WTS API (<code>ERROR_ACCESS_DENIED</code>).</p><p>I thought it could be an issue with <code>WTSVirtualChannelOpen</code> specifically, so I tried with its counterpart <code>WTSVirtualChannelOpenEx</code>. No luck.</p><p>I spent a lot of time on this issue because I had no idea where the opening could fail. I had struggle investigating it by debugging because I didn&rsquo;t know anything about RPC.</p><p>Indeed, WTSAPI32 eventually ends up in <strong>RPCRT4.DLL</strong>, responsible for <strong>Remote Procedure Calls</strong> in Windows.</p><p>I tried logging debug strings from <code>winsta!WinStationVirtualOpenEx</code> with <a href=https://github.com/CobaltFusion/DebugViewPP>DebugView++</a>. This requires patching <code>winsta.dll</code> to activate <code>g_bDebugSpew</code>:</p><pre tabindex=0><code>WINSTA: ERR::RpcCreateVirtualChannel failed: 0x80070005 in CreateVirtualChannel
</code></pre><p>With some help, we eventually managed to identify the <strong>endpoint of the RPC call</strong>, in <code>termsrv.dll</code>. There are two functions of interest:</p><ul><li><code>CRCMPublicRpc::Start</code>, which starts listening for RPC calls and sets up ACL;</li><li><code>RpcCreateVirtualChannel</code>, which handles the call.</li></ul><p>The issue must come either from ACL, or from the handling logic. ACL is set up with an SDDL string, which is Microsoft&rsquo;s way of describing a <em>security descriptor</em>.</p><pre tabindex=0><code>D:(A;;GRGWGX;;;WD)(A;;GRGWGX;;;RC)(A;;GA;;;BA)(A;;GA;;;OW)(A;;GRGWGX;;;AC)(A;;GRGWGX;;;S-1-15-3-1024-1864111754-776273317-3666925027-2523908081-3792458206-3582472437-4114419977-1582884857)
</code></pre><p>PowerShell can help transform this into something more human-readable, but it does not yield any remarkable permission that could prevent us from making the call.</p><p>The issue then probably comes, as hinted by the debug spew, from <code>RpcCreateVirtualChannel</code>.</p><p>I debugged the TermService svchost process and stepped until ending up inside <strong>rdpcorets.dll</strong>. The function <code>CUMRDPConnection::CreateVirtualChannel</code> answers our inquiry.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span><span style=color:#a6e22e>_stricmp</span>(<span style=color:#e6db74>&#34;DRDYNVC&#34;</span>, a2) 
</span></span><span style=display:flex><span>  <span style=color:#f92672>||</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>_stricmp</span>(<span style=color:#e6db74>&#34;rdpgrfx&#34;</span>, a2)
</span></span><span style=display:flex><span>  <span style=color:#f92672>||</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>_stricmp</span>(<span style=color:#e6db74>&#34;rdpinpt&#34;</span>, a2)
</span></span><span style=display:flex><span>  <span style=color:#f92672>||</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>_stricmp</span>(<span style=color:#e6db74>&#34;rdpcmd&#34;</span>, a2)
</span></span><span style=display:flex><span>  <span style=color:#f92672>||</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>_stricmp</span>(<span style=color:#e6db74>&#34;rdplic&#34;</span>, a2)
</span></span><span style=display:flex><span>  <span style=color:#f92672>||</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>_stricmp</span>(<span style=color:#e6db74>&#34;Microsoft::Windows::RDS::Graphics&#34;</span>, a2) )
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  v16 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x80070005</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>goto</span> LABEL_58;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>DRDYNVC is really <strong>banned</strong> from being opened through the WTS API&mldr;!</p><p>We also notice a few more channels that are blacklisted the same way. I tried patching <code>rdpcorets.dll</code> to bypass this condition, but then I started getting new errors, so I gave up. Perhaps this channel is <em>really</em> meant not to be opened with the WTS API&mldr;</p><h2 id=rdpdr>RDPDR</h2><p><strong>RDPDR</strong> is a <em>Static Virtual Channel</em> dedicated to redirecting access from the server to the <strong>client file system</strong>. It is opened by default. It is also the base channel that hosts several sub-extensions such as the <strong>smart card extension</strong>, the <strong>printing extension</strong> or the <strong>ports extension</strong>. Finally, it is probably the most complex and interesting channel I&rsquo;ve had to fuzz among the few ones I&rsquo;ve studied!</p><p>Here&rsquo;s what the architecture of the channel&rsquo;s client implementation resembles:</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/rdpdr-architecture.png target=_blank><img src=/posts/img/rdp/rdpdr-architecture.png alt="RDPDR channel architecture"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>RDPDR channel architecture in mstscax.dll</figcaption></figure></p><p>When I tried to start fuzzing RDPDR, there was a little hardship. After around a hundred iterations, the fuzzing would become very slow. The reason was that the client <strong>closes the channel</strong> as soon as the smallest thing goes wrong while handling an incoming PDU (length checking failure, unrecognized enum value&mldr;). Once the channel is closed, we can&rsquo;t send PDUs anymore.</p><p>More specifically, the client calls <code>VCManager::ChannelClose</code> which calls <code>VirtualChannelCloseEx</code>. This is funny because this function sounds like it&rsquo;s from the WTS API, but it&rsquo;s not. It looks more like legacy. We can find a description of this function in an older RDP reference page:</p><blockquote><p><em>This function closes the client end of a virtual channel. This function is a virtual extension that can be used to protect per-session data in the virtual channel client DLL.</em></p></blockquote><p>So it seems that it is indeed used, rightfully, for security purposes. This means we probably won&rsquo;t be able to find a lot of stateful bugs, if a PDU in a sequence triggers the channel closing. However, bugs can still happen before channel is closed, and some bugs may even not trigger it.</p><p>I <strong>patched</strong> <code>mstscax.dll</code> to get rid of this measure, by nopping out the dynamic call to <code>VirtualChannelCloseEx</code> and bypassing the error handler. We have to be extra careful with patches though, because they can modify the client&rsquo;s behavior. As a result, real bugs in the RDP client will only constitute a <em>subset</em> of the bugs we will find with the patched DLL.</p><p>With this new gear, I fuzzed the whole channel, including, how Microsoft calls them, its <em>sub-protocols</em> (Printer, Smart Cards&mldr;). <strong>I eventually identified three bugs</strong>.</p><h3 id=arbitrary-malloc-dos-in-rdpdr>Arbitrary Malloc DoS in RDPDR</h3><p>This bug is very similar to the one I found in CLIPRDR, so I won&rsquo;t expand a lot.</p><p>It was found within a few minutes of fuzzing. At first, my virtual machine had only 4 GB of RAM, so death by swap (which we know of and are used to by now) would happen. Upgrading to 8 GB of RAM solved the issue, meaning the memory overcommitment was not as violent as in the CLIPRDR bug. Fuzzing with 8 GB RAM showed funny things:</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/rdpdr-ram-spikes.png target=_blank><img src=/posts/img/rdp/rdpdr-ram-spikes.png alt="RDPDR RAM spikes"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>RAM spikes in the Task Manager while fuzzing RDPDR</figcaption></figure></p><p>Here&rsquo;s what the guilty PDU looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> payload[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0x72</span>, <span style=color:#ae81ff>0x44</span>, <span style=color:#ae81ff>0x52</span>, <span style=color:#ae81ff>0x49</span>, <span style=color:#75715e>// Header
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x01</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// DeviceId
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0xf8</span>, <span style=color:#ae81ff>0x01</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// FileId
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x08</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// CompletionId
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x0e</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// MajorFunction (Device Control Request)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// MinorFunction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0xff</span>, <span style=color:#75715e>// OutputBufferLength
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0xff</span>, <span style=color:#ae81ff>0x10</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// InputBufferLength
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0xa8</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x09</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// IoControlCode
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x11</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// Padding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// Padding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// Padding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// Padding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>  <span style=color:#75715e>// Padding
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><p>It is a <em>Device I/O Request</em> PDU (<code>0x4952</code>) of sub-type <em>Device Control Request</em> (<code>0x000e</code>). More specifically, the I/O Request handler, <code>DrDevice::ProcessIORequest</code>, dispatches the PDU to a Smart Card sub-protocol handler (<code>W32SCard::MsgIrpDeviceControl</code>). Eventually, the value of the field <code>OutputBufferLength</code> (DWORD) is used for a <strong>malloc call</strong> on the client (inside <code>DrUTL_AllocIOCompletePacket</code>).</p><p>This bug is less powerful than the CLIPRDR one because it only goes up to a <strong>4 GB</strong> allocation. Also, it only works once (the payload won&rsquo;t work twice in the same RDP session), so the value of <code>OutputBufferField</code> should be premedidated &mdash; we can&rsquo;t do small increments.</p><p>However, it still accounts for a <strong>remote system-wide denial of service</strong> for target clients with around 4 GB of RAM on their system.</p><h3 id=remote-heap-leak--aslr-leak-in-rdpdr>Remote Heap Leak / ASLR Leak in RDPDR</h3><p>This vulnerability resides in RDPDR&rsquo;s <em>Printer</em> sub-protocol. It was assigned <a href=https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-38665><strong>CVE-2021-38665</strong></a>.</p><p>I covered it in depth in a dedicated article: <a href=/posts/leaking-aslr-through-rdp-printer-cache-registry/><strong>Remote ASLR Leak in Microsoft&rsquo;s RDP Client through Printer Cache Registry</strong></a>.</p><p>If you haven&rsquo;t already, check it out now (or after having finished reading this article)!</p><h3 id=deserialization-bug--heap-corruption-in-rdpdr>Deserialization Bug / Heap Corruption in RDPDR</h3><p>This vulnerability resides in RDPDR&rsquo;s <em>Smart Card</em> sub-protocol. It was assigned <a href=https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-38666><strong>CVE-2021-38666</strong></a>.</p><p>Likewise, I covered it in depth in a dedicated article: <a href=/posts/deserialization-bug-through-rdp-smart-card-extension/><strong>Remote Deserialization Bug in Microsoft&rsquo;s RDP Client through Smart Card Extension</strong></a>.</p><h1 id=conclusion>Conclusion</h1><p>I would like to thank Thalium for giving me the opportunity to work on this subject which I had a lot of fun with, and that also allowed me to skill up in Windows reverse engineering and fuzzing.</p><p>Even though I couldn&rsquo;t find any &ldquo;ground-breaking&rdquo; vulnerability such as an RCE with a working exploit, I am very happy with my results, especially as part of an internship.</p><p>To recap, my findings led to:</p><ul><li><a href=https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-38665><strong>CVE-2021-38665</strong></a> (Remote ASLR Leak in Microsoft&rsquo;s RDP Client through RDPDR)</li><li><a href=https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-38666><strong>CVE-2021-38666</strong></a> (Remote Deserialization Bug in Microsoft&rsquo;s RDP Client through RDPDR)</li></ul><p>I also got two CVEs in <strong>FreeRDP</strong>. I didn&rsquo;t talk about these because they&rsquo;re not about the Microsoft client, they&rsquo;re not the most interesting and the article is getting really long either way, but feel free to look them up:</p><ul><li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-37594"><strong>CVE-2021-37594</strong></a> (Remote Memory Leak in FreeRDP through CLIPRDR)</li><li><a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-37595"><strong>CVE-2021-37595</strong></a> (Remote Arbitrary File Read in FreeRDP through CLIPRDR)</li></ul><h2 id=timeline>Timeline</h2><ul><li>2021-07-22 &mdash; Sent vulnerability reports to Microsoft Security Response Center.</li><li>2021-07-22 &mdash; Sent vulnerability reports to FreeRDP; they pushed a fix on the same day.</li><li>2021-07-23 &mdash; Microsoft started reviewing and reproducing.</li><li><strong>2021-07-27 &mdash; MITRE assigned <code>CVE-2021-37594</code> and <code>CVE-2021-37595</code> to my FreeRDP findings.</strong></li><li>2021-07-28 &mdash; FreeRDP released version 2.4.0 of the client and published <a href=https://github.com/FreeRDP/FreeRDP/security/advisories/GHSA-qg62-jcfp-46fw>security advisories</a>.</li><li>2021-07-30 &mdash; Microsoft assessed the CLIPRDR malloc DoS bug as low-severity and closed the case.</li><li>2021-07-31 &mdash; Microsoft acknowledged the RDPDR deserialization bug and started developing a fix. They also started reviewing this case for a potential bounty award.</li><li>2021-08-03 &mdash; Microsoft acknowledged the RDPDR heap leak bug and started developing a fix. They also started reviewing this case for a potential bounty award.</li><li><strong>2021-08-04 &mdash; Microsoft assessed the RDPDR deserialization bug as <em>Remote Code Execution</em> with <em>Important</em> severity. Bounty award: $5,000.</strong></li><li><strong>2021-08-04 &mdash; Microsoft assessed the RDPDR heap leak bug as <em>Information Disclosure</em> with <em>Important</em> severity. Bounty award: $1,000.</strong></li><li><strong>2021-08-13 &mdash; The vulnerabilities were assigned CVE-2021-38665 and CVE-2021-38666.</strong></li><li>2021-08-26 &mdash; Microsoft assessed the RDPDR malloc DoS bug as low-severity and closed the case.</li><li><strong>2021-11-09 &mdash; Microsoft released the security patch.</strong> For some reason, the severity of CVE-2021-38666 was revised to <em>Critical</em> when it was published.</li></ul></div><footer class=post-footer><div class=post-footer-data><div class=tags><div class=tag><a href=/tags/rdp>#RDP</a></div><div class=tag><a href=/tags/fuzzing>#Fuzzing</a></div><div class=tag><a href=/tags/winafl>#WinAFL</a></div><div class=tag><a href=/tags/vulnerability-research>#Vulnerability Research</a></div><div class=tag><a href=/tags/cve>#CVE</a></div></div><span class=date>2021-11-10
<span class=author>by
Valentino Ricotta</span></span></div></footer></article><footer><div class=social-links-footer><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>GitHub</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div><div class=copyright>Copyright (c) 2020, all rights reserved.</div><div class=poweredby>Powered by <a href=https://gohugo.io/>Hugo</a>.</div></footer></div></body></html>