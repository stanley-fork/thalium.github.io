<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=author content="Thalium Team"><meta name=description content="Thalium blog."><meta name=keywords content="blog,tech"><meta name=viewport content="width=device-width,minimum-scale=1,initial-scale=1"><meta name=generator content="Hugo 0.120.3"><link rel=canonical href=/posts/leveraging-android-permissions/><meta property="og:title" content="Leveraging Android Permissions: A Solver Approach"><meta property="og:description" content="The Android permission management system has already suffered from several vulnerabilities in the past. Such weaknesses can grant dangerous permissions to a malevolent application, an example being CALL_LOG, which gives access to all incoming and outgoing calls.
This post dives into the Android permission system and how a solver was leveraged to find new vulnerabilities. With this approach, a privilege escalation was identified, which was fixed and assigned CVE-2023-20947 by Google.
"><meta property="og:type" content="article"><meta property="og:url" content="/posts/leveraging-android-permissions/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-20T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Leveraging Android Permissions: A Solver Approach"><meta name=twitter:description content="The Android permission management system has already suffered from several vulnerabilities in the past. Such weaknesses can grant dangerous permissions to a malevolent application, an example being CALL_LOG, which gives access to all incoming and outgoing calls.
This post dives into the Android permission system and how a solver was leveraged to find new vulnerabilities. With this approach, a privilege escalation was identified, which was fixed and assigned CVE-2023-20947 by Google.
"><meta itemprop=name content="Leveraging Android Permissions: A Solver Approach"><meta itemprop=description content="The Android permission management system has already suffered from several vulnerabilities in the past. Such weaknesses can grant dangerous permissions to a malevolent application, an example being CALL_LOG, which gives access to all incoming and outgoing calls.
This post dives into the Android permission system and how a solver was leveraged to find new vulnerabilities. With this approach, a privilege escalation was identified, which was fixed and assigned CVE-2023-20947 by Google.
"><meta itemprop=datePublished content="2023-06-20T00:00:00+00:00"><meta itemprop=dateModified content="2023-06-20T00:00:00+00:00"><meta itemprop=wordCount content="1811"><meta itemprop=keywords content="Android,Permissions,CVE,Vulnerability Research,"><link rel=stylesheet href=/css/layout.css><link rel=stylesheet href=/css/default-dark.css><link rel=icon href=/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-141692648-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><title>Leveraging Android Permissions: A Solver Approach
</title><script>MathJax={tex:{inlineMath:[["∳","∳"]],displayMath:[["∳∳","∳∳"]],processEscapes:!0},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script></head><body><style>@font-face{font-family:days_one;src:url(/days_one.ttf)format('truetype')}.siteTitle{margin-top:24px}.siteTitle img{display:inline-block;vertical-align:middle;margin-top:-24px;margin-right:-10px}.siteTitle span{font-family:days_one,Fallback,sans-serif;color:#fff;font-size:160%}</style><div class=main><header><div class=header-bar><nav><div class=siteTitle><a href=/><img src=/shard_only_no_background.png width=12%></img>
<span>THALIUM</span></a></div><a class=nav-item href=/posts/><div class=nav-item-title>Posts</div></a><a class=nav-item href=/joinus/><div class=nav-item-title>Join Us</div></a><a class=nav-item href=/about/><div class=nav-item-title>About</div></a></nav><div class=social-links-header><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>Github</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div></div></header><article class=post><h1 class=title>Leveraging Android Permissions: A Solver Approach</h1><div class=content><p>The work presented in this post was part of an <strong>internship</strong> carried out in 2022 within Thalium.</p><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#introduction>Introduction</a></li><li><a href=#case-study-cve-2021-0307>Case study: CVE-2021-0307</a><ul><li><a href=#exploitation-overview>Exploitation overview</a></li><li><a href=#root-cause>Root cause</a></li><li><a href=#fix>Fix</a></li></ul></li><li><a href=#solver-approach>Solver Approach</a><ul><li><a href=#modelling>Modelling</a></li><li><a href=#vulnerability-research>Vulnerability Research</a></li></ul></li><li><a href=#proof-of-concept>Proof of Concept</a></li><li><a href=#conclusion>Conclusion</a></li></ul><h1 id=introduction>Introduction</h1><p>Since its inception, Android has identified applications as a security threat. As a consequence, applications run in a sandboxed environment, leveraging various Linux mechanisms, as well as access control mechanisms known as <a href=https://developer.android.com/guide/topics/permissions/overview>permissions</a>.</p><p>Whenever an application needs access to resources owned by the system or other applications, it usually must be granted the permissions to do so. Those permissions must be declared in the application&rsquo;s manifest, and depending on their protection level, they sometimes require user consent.</p><p>Starting from Android Marshmallow (API level 23), runtime permissions protect privacy sensitive assets such as access to the camera or phone calls related data. These permissions are system-defined, contrary to application-defined ones, which are called <strong>custom permissions</strong>.</p><p>Granting runtime permissions requires user consent. To smoothen user experience, runtime permissions are grouped, and if a permission of a group has been granted, then every requested permission from this group would be <strong>mechanically</strong> granted.</p><p>To add an extra layer of security, Android 11 (API level 30) implements a feature called <a href=https://developer.android.com/training/permissions/requesting#one-time><strong>one-time permission</strong></a>. A few runtime permissions — microphone, location and camera — may be granted once to an application. The permission is automatically revoked when the application is stopped, or after a short while.</p><p>This new feature does not seem to have been the subject of specific research and thus has caught our attention. To sum up, permissions:</p><ul><li>are either <em>defined by an application</em> (<strong>custom</strong>), or <em>by the system</em> (<strong>system</strong>).</li><li>have a <em>protection level</em> such as <strong>normal</strong>, <strong>dangerous</strong>, <strong>signature</strong> or <strong>special</strong>.</li><li>can be <em>part of a group</em>.</li></ul><p>The logic of the rules behind this system are mostly implemented in two framework services: <em>PermissionManagerService</em> and <em>PackageManagerService</em>.</p><p>Recently, those components have suffered from several vulnerabilities <a href=https://ieeexplore.ieee.org/document/9519385>that were found through fuzzing</a>. They led to critical privilege escalation without user consent.</p><p>In this blog post, we first present a case study of a permission management vulnerability. Then, we describe the solver approach we followed to help in the vulnerability research. Eventually, we explain a new vulnerability that was discovered thanks to the solver, and which was reported to Google.</p><h1 id=case-study-cve-2021-0307>Case study: CVE-2021-0307</h1><p>A malevolent application could leverage CVE-2021-0307 to silently obtain any system permission part of a group. Android 10 and 11 were affected by this vulnerability.</p><h2 id=exploitation-overview>Exploitation overview</h2><p>Three applications are needed: <em>app-exp</em>, <em>app-eop</em> and <em>app-exp-update</em>.
The permissions defined or used in the respective manifests are the following:</p><ul><li>App-exp:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!-- Defines custom permission as normal --&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;permission</span> <span style=color:#a6e22e>android:name=</span><span style=color:#e6db74>&#34;com.example.cve0307.perm&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><ul><li>App-eop:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!-- Use custom permission and system permission PHONE --&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;uses-permission</span> <span style=color:#a6e22e>android:name=</span><span style=color:#e6db74>&#34;com.example.cve0307.perm&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;uses-permission</span> <span style=color:#a6e22e>android:name=</span><span style=color:#e6db74>&#34;android.permission.CALL_PHONE&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><ul><li>App-exp-update:</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#75715e>&lt;!-- Re-defines custom permission as dangerous and grouped with PHONE --&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;permission</span> <span style=color:#a6e22e>android:name=</span><span style=color:#e6db74>&#34;com.example.cve0307.perm&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>android:protectionLevel=</span><span style=color:#e6db74>&#34;dangerous&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>android:permissionGroup=</span><span style=color:#e6db74>&#34;android.permission-group.PHONE&#34;</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/permission&gt;</span>
</span></span></code></pre></div><p>The actions to perform are:</p><ol><li>Install <em>app-exp</em></li><li>Install <em>app-eop</em></li><li>Uninstall <em>app-exp</em></li><li>Install <em>app-exp-update</em></li></ol><p>The <em>PHONE</em> group is then granted to <em>app-eop</em> without the user having authorized it.</p><h2 id=root-cause>Root cause</h2><p>The <em>PackageManagerService</em> refreshes the registration and the granting status of all permissions, when an application is updated or uninstalled; if a dangerous custom permission definition is removed during this process, its grants will also be revoked from applications. Therefore, if a normal or signature custom permission definition is removed, the applications will keep the granted status.</p><p>If an application defines a normal or signature custom permission, and the application defining it is uninstalled, the applications requesting it will keep the granted status as normal or signature. Therefore, if the user installs an application which redefines the custom permission, the applications that have the granted status will be allowed to use the permission without the user&rsquo;s consent, even if the redefined permission is now dangerous.</p><p>In the proof of concept, <em>app-exp</em> defines a normal custom permission, which is requested by <em>app-eop</em>. Then <em>app-exp</em> is uninstalled, consequently <em>app-eop</em> will keep the granted status of <em>com.example.cve0307.perm</em> as normal, even if the permission is not defined. Later, if an update of <em>app-exp</em> (<em>app-exp-update</em>) is installed, and redefines the custom permission as dangerous and belongs to the permission group <em>PHONE</em>; <em>app-eop</em> requests the dangerous <em>CALL_PHONE</em> permission and will be allowed to use it without the user&rsquo;s consent.</p><h2 id=fix>Fix</h2><p>Google fixed the issue by making sure the install permissions status are revoked when the application that defined them is uninstalled.</p><h1 id=solver-approach>Solver Approach</h1><p>To model the Android permission system, our choice is to use <a href=https://potassco.org/>Clingo</a>, an open-source answer set programming (ASP) system. Answer set programming is a declarative programming paradigm used for solving logic problems.</p><p>Clingo allows users to specify a problem in a high-level language, and then automatically translates that specification into a set of logical rules that can be used to reason about the problem. By setting rules and facts, Clingo will find all possible &ldquo;answer sets&rdquo; that satisfy them.</p><p>Here is an example:</p><pre tabindex=0><code>innocent(Suspect) :- motive(Suspect), not guilty(Suspect).
motive(harry).
motive(sally).
guilty(harry).
</code></pre><p>A solution to the above rule and the three facts is the answer set containing all three facts as well as the proposition <em>innocent(sally)</em>.</p><pre tabindex=0><code>&gt; clingo example.lp
clingo version 5.4.1
Reading from example.lp
Solving...
Answer: 1
motive(harry) motive(sally) guilty(harry) innocent(sally)
SATISFIABLE

Models       : 1
Calls        : 1
Time         : 0.004s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.001s
</code></pre><h2 id=modelling>Modelling</h2><p>The goal of modelling the Android permission system is to find new design vulnerabilities, but first we need to model this system.</p><p>As clingo generates answer sets, we give the parameters which will be used as bounds in the model, such as the number of applications and permissions that we want to generate, and how many actions are possible.</p><p>Next, through facts and rules, we define applications, permissions, manifests and the number of actions. The possible actions are: <code>install</code>, <code>uninstall</code>, <code>run</code>, <code>stop</code>, <code>grant</code>, <code>grantAuto</code>, <code>grantOneTime</code>, <code>update</code>, <code>reboot</code>.</p><p>The important part is the definition of the system’s behavior. The easiest way to be in line is to perform tests by developing simple applications and transcribing them in the model. Later, to refine the model, the Android Open Source Project (AOSP) can be used.</p><p>For example, the model must be in line either when a permission is updated or after a system reboot, which is typically an action that cannot be easily performed using an application.</p><p>The following model’s snippet defines that: <em>&ldquo;If at step S the install action of an application A with a manifest M is performed, then the application with its manifest is installed at S+1. And if an application is not installed, then the run action can not be performed.&rdquo;</em></p><pre tabindex=0><code>installed(A,M,S+1) :- install(A,M,S).
:- run(A,S), not installed(A,_,S).
</code></pre><p>Many rules must be defined in the system. The more accurate the model is, the more likely the discovery of a vulnerability. To that end, the CVEs can be of precious help, either to try to find them, or to improve our modelling.</p><p>This leads to the question <em>&ldquo;how to find a vulnerability&rdquo;</em> with the model.</p><h2 id=vulnerability-research>Vulnerability Research</h2><p>To find a vulnerability, constraints must be defined. Here, a vulnerability would be to have a permission granted while the <em>grant</em> action has not been performed.</p><pre tabindex=0><code># grant action can not be performed
:- grant(_,_,_).

# system permission is granted to app user at the end
:- not granted(A, P, S), A=userApp, P=systPerm, S=step+1.
</code></pre><p>So, if Clingo finds a solution where a system permission is granted after <code>S</code> actions, there is an issue. Armed with this method, we can try to rediscover CVEs, and then try to find new bugs. Since Clingo&rsquo;s output can be messy, we made a <a href=https://github.com/Ghizmoo/DroidSolver>helper tool</a> to simplify it.</p><p>With a model in line with the latest AOSP, many solutions are found but they can be grouped under one. One of these solutions is the following:</p><pre tabindex=0><code>Solving...
Answer: 1
install(2,3,1) run(2,2) grantOneTime(2,1,3) grantAuto(2,2,4) stop(2,5) run(2,6) grantAuto(2,1,7)
SATISFIABLE

Models : 1+
</code></pre><p>The output is simplified for better understanding, but it tells us the steps to perform:</p><ol><li>Install user app (2) which defines dangerous custom perm (2) which is grouped with a system perm (1), and use these two perms.</li><li>Run the app (2).</li><li>Do a one-time grant of the system perm (1) to the app (2).</li><li>The custom perm (2) is mechanically granted to the app (2) while requesting it.</li><li>Stop the app (2).</li><li>Run the app (2).</li><li>The dangerous perm (1) is mechanically granted to the app (2) while requesting it.</li></ol><p>This is potentially a vulnerability because a dangerous permission is granted after some actions, while the <code>grant</code> action has not been performed by the user.</p><h1 id=proof-of-concept>Proof of Concept</h1><p>For the sake of testing, let&rsquo;s define a custom permission belonging to the same group as <em>android.permission.CAMERA</em>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;permission</span> <span style=color:#a6e22e>android:name=</span><span style=color:#e6db74>&#34;com.example.cp&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>android:protectionLevel=</span><span style=color:#e6db74>&#34;dangerous&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>android:permissionGroup=</span><span style=color:#e6db74>&#34;android.permission-group.CAMERA&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;uses-permission</span> <span style=color:#a6e22e>android:name=</span><span style=color:#e6db74>&#34;com.example.cp&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;uses-permission</span> <span style=color:#a6e22e>android:name=</span><span style=color:#e6db74>&#34;android.permission.CAMERA&#34;</span> <span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p>Once installed, the application may turn the <em>android.permission.CAMERA</em> one-time grant into a permanent grant.</p><p><a href=/posts/img/leveraging-android-permissions/poc.png target=_blank><img src=/posts/img/leveraging-android-permissions/poc.png alt="PoC CVE-2023-20947"></a></p><ol><li>The malicious application requests for <em>android.permission.CAMERA</em>.</li><li>Android checks if there is any granted permission which is in the same group, but there is none: it asks the user to give or deny consent.</li><li>The user gives a one-time consent: the granted permission will be revoked after a period of time. Exactly when it is revoked depends on a few conditions listed in the Android documentation.</li><li>The malicious application requests for <em>com.example.cp</em>, which is a custom permission defined by itself, and member of the same group as <em>android.permission.CAMERA</em>; the permission is mechanically granted, without the user knowing.</li><li>After force killing the application, <em>android.permission.CAMERA</em> is automatically revoked by Android. As detailed before there are a few other configurations that lead to this behavior.</li><li>The malicious application requests <em>android.permission.CAMERA</em> again. The previous grant has been revoked, but this time the application already has a permission in the same group, the custom permission <em>com.example.cp</em> it purposely defined and had granted previously. <strong>The user is not asked for their consent, and the runtime permission is silently granted</strong>.</li></ol><video class=video-shortcode preload controls width=100%>
<source src=/posts/img/leveraging-android-permissions/cve-2023-20947.webm type=video/webm></video><p>To sum up, there is an issue where an app can get a permission A granted permanently while the user granted it <em>one-time</em>. If the user has granted a <em>one-time</em> permission A, which is in the same group as permission B, then the permission B is granted permanently without user interaction. The app can then further use that permanent grant on permission B to get the permission A granted permanently.</p><p>Android 11, 12 and 13 have been tested, and they exhibit the same behavior. The issue was reported and assigned <strong>CVE-2023-20947</strong>.</p><h1 id=conclusion>Conclusion</h1><p>A solver approach led to the discovery of a vulnerability in the Android permission system. However, the model is not perfect: it does not necessarily represent the system perfectly, and still has room for improvement. The more accurate the model, the better our chances at finding a vulnerability.</p><p>The Android permission system is one of the applications where the solver approach is interesting, but that can be applied to many systems, and a variety of other interesting tools could be explored, such as <a href=https://www.swi-prolog.org>Prolog</a>.</p></div><footer class=post-footer><div class=post-footer-data><div class=tags><div class=tag><a href=/tags/android>#Android</a></div><div class=tag><a href=/tags/permissions>#Permissions</a></div><div class=tag><a href=/tags/cve>#CVE</a></div><div class=tag><a href=/tags/vulnerability-research>#Vulnerability Research</a></div></div><span class=date>2023-06-20
<span class=author>by
Jérémy Breton</span></span></div></footer></article><footer><div class=social-links-footer><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>GitHub</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div><div class=copyright>Copyright (c) 2020, all rights reserved.</div><div class=poweredby>Powered by <a href=https://gohugo.io/>Hugo</a>.</div></footer></div></body></html>